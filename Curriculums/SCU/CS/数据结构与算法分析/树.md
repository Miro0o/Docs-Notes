# 树
树的定义

## 树的储存
双亲表示法
孩子表示法
孩子兄弟表示法

##  二叉树

+ 建表/复制 ： 先序遍历
	+
###  [线索二叉树](https://blog.csdn.net/S_999999/article/details/86157532)
		
		
+ 性质
	+ 线索二叉树 本质是 线性化 非线性结构（树）。
	+ 线索化之后就可以以链表的形式顺序访问原树。（先序，中序，后序；链表支持的顺序与线索化方式有关）
+ 操作
	+ 中序遍历建表
		+ 对于一个有n个结点的二叉链表，每个节点都有指向左右孩子的两个指针域，一共有2n个指针域。而n个结点的二叉树又有n-1条分支线数(除了头结点，每一条分支都指向一个结点)，也就是存在2n-(n-1)=n+1个空指针域。这些指针域只是白白的浪费空间。因此, 可以用空链域来存放结点的前驱和后继。线索二叉树就是利用n+1个空链域来存放结点的前驱和后继结点的信息。
		+  之前的左右指针域 变为 ：左指针指向中序前驱，右指针指向中序后继。
	+  先序遍历？
	+  后序遍历？
+  改良
	+  加入头指针。


### [二叉树、树、森林的互相转换](https://www.cnblogs.com/zhanggui/p/4649114.html)
1. 树转二叉树
	1. 加线。在所有的兄弟结点之间加一条线。
    2. 去线。树中的每个结点，只保留它与第一个孩子结点的连线，删除其他孩子结点之间的连线。
    3. 调整。以树的根结点为轴心，将整个树调节一下（第一个孩子是结点的左孩子，兄弟转过来的孩子是结点的右孩子）
    
3. 森林转二叉树
	1. 把每棵树转换为二叉树
	2. 第一棵二叉树不动，从第二棵二叉树开始，一次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。
	
2. 二叉树转树
	1. 加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子的右孩子结点。。。都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。
	2. 去线。删除原二叉树中所有结点与其右孩子结点的连线。
	3. 层次调整。
	
4. 二叉树转换为森林

 > 前提：   假如一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则转换为一棵树。

+ 
	1. 从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连续删除。直到所有这些根结点与右孩子的连线都删除为止。
	2.  将每棵分离后的二叉树转换为树。

### [[查找#树表查找|二叉排序树、平衡二叉树, etc...]]
二叉排序树:
左子树节点均小于根节点，右子树节点均大于根节点。


## 树和森林的遍历

先序遍历，先根遍历，中、后同。

+ 前序遍历的非递归实现。了解拓宽一下思维而已。中序后序同。
+ 链接给出https://blog.csdn.net/baiye_xing/article/details/75198255
```C++
 public void preOrder(Node root) {
        Stack<Node> stack = new Stack<>();
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                System.out.print(root.getData()+" ");
                stack.push(root);
                root = root .getLchild();
            }
            if (!stack.isEmpty()) {
                root = stack.pop();
                root = root.getRchild();
            }
        }
    }
————————————————
版权声明：本文为CSDN博主「白夜行515」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/baiye_xing/article/details/75198255
```
