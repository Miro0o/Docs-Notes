# Computer Languages & Programming Methodology

[TOC]



## Res
### Related Topics
â†— [Automata Theory and (Formal) Language Theory](../../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)
â†— [SCA (Static Code Analysis) & SAST](../../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ‘š%20SCA%20(Static%20Code%20Analysis)%20&%20SAST/SCA%20(Static%20Code%20Analysis)%20&%20SAST.md)
â†— [Programming Language Processing & Program Execution](../ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/Programming%20Language%20Processing%20&%20Program%20Execution.md)
- â†— [Program Language Processing & Compilation Theory (Compile-time)](../ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸš®%20Program%20Language%20Processing%20&%20Compilation%20Theory%20(Compile-time)/Program%20Language%20Processing%20&%20Compilation%20Theory%20(Compile-time).md)
â†— [The Essence of Computing - Programs & The Semantics of Programs](../../ğŸ—º%20CS%20Overview/The%20Essence%20of%20Computing%20-%20Programs%20&%20The%20Semantics%20of%20Programs.md)

â†— [Computing Methodologies](../../ğŸ§ %20Computing%20Methodologies/Computing%20Methodologies.md)
- â†— [Concurrent Computing](../../ğŸ§ %20Computing%20Methodologies/âš¡ï¸%20High%20Performance%20Computing/Concurrent%20Computing/Concurrent%20Computing.md)
- â†— [Distributed Computing & Systems](../../ğŸ§ %20Computing%20Methodologies/Distributed%20Computing%20&%20Systems/Distributed%20Computing%20&%20Systems.md)
- â†— [Parallel Computing & Programming](../../ğŸ§ %20Computing%20Methodologies/âš¡ï¸%20High%20Performance%20Computing/Parallel%20Computing%20&%20Programming/Parallel%20Computing%20&%20Programming.md)
- â†— [Quantum Computing (and Communication)](../../ğŸ§ %20Computing%20Methodologies/Quantum%20Computing%20(and%20Communication)/Quantum%20Computing%20(and%20Communication).md)
- etc.

â†— [Algorithm & Data Structure](../ğŸ§™â€â™‚ï¸%20Algorithm%20&%20Data%20Structure/Algorithm%20&%20Data%20Structure.md)

â†— [Database Languages](Other%20Languages%20for%20Specific%20Areas/Database%20Languages/Database%20Languages.md)
â†— [HDL (Hardware Definition Languages)](../../Computer%20Engineering,%20Embedded%20&%20IoT/Embedded%20Programming%20&%20Software%20Development/Languages/HDL%20(Hardware%20Definition%20Languages)/HDL%20(Hardware%20Definition%20Languages).md)
â†— [Web Templating Engines & Languages](../../Software%20Engineering/â˜ï¸%20Application%20Software%20Engineering/ğŸ•¸ï¸%20Web%20Development%20&%20The%20Internet/ğŸ–¥ï¸%20Web%20FrontEnd%20Dev/â¬†ï¸%20Frontend%20Optimization/Web%20Templating/Web%20Templating%20Engines%20&%20Languages/Web%20Templating%20Engines%20&%20Languages.md)

â†— [Information, Data, Number and Math in Digital Systems](../../ğŸ—º%20CS%20Overview/ğŸ’‹%20Intro%20to%20Computer%20Science/ğŸ˜¤%20Information,%20Data,%20Number%20and%20Math%20in%20Digital%20Systems/Information,%20Data,%20Number%20and%20Math%20in%20Digital%20Systems.md)
â†— [System Software Engineering](../../Software%20Engineering/ğŸ‘‡%20System%20Software%20Engineering/System%20Software%20Engineering.md)
- â†— [Computer (IO Devices) Drivers & Programming](../ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Computer%20Interfaces%20&%20Hardware%20Drivers/ğŸ›%20Computer%20(IO%20Devices)%20Drivers%20&%20Programming/Computer%20(IO%20Devices)%20Drivers%20&%20Programming.md)
- â†— [Compute Unified Device Architecture & CUDA Programming](../ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Computer%20Interfaces%20&%20Hardware%20Drivers/ğŸ›%20Computer%20(IO%20Devices)%20Drivers%20&%20Programming/Graphics%20Devices%20Drivers/Compute%20Unified%20Device%20Architecture%20&%20CUDA%20Programming/Compute%20Unified%20Device%20Architecture%20&%20CUDA%20Programming.md)
â†— [Network Programming & RPC](../ğŸï¸%20Computer%20Networking%20and%20Communication/Network%20Programming%20&%20RPC/Network%20Programming%20&%20RPC.md)
- â†— [DPDK (Data Plane Development Kits)](../ğŸï¸%20Computer%20Networking%20and%20Communication/ğŸš€%20High%20Performance%20Network%20(HPN)%20&%20IDC%20Technologies/DPDK%20(Data%20Plane%20Development%20Kits)/DPDK%20(Data%20Plane%20Development%20Kits).md)
â†— [Foundation Models & Development & SDKs](../../ğŸ§ %20Computing%20Methodologies/ğŸ‘½%20Artificial%20Intelligence/ğŸ—ï¸%20AI%20(Data)%20Infrastructure%20&%20Techniques%20Stack/ğŸ›«%20Foundation%20Models%20&%20Development%20&%20SDKs/Foundation%20Models%20&%20Development%20&%20SDKs.md)
- â†— [ML Programming & Frameworks](../../ğŸ§ %20Computing%20Methodologies/ğŸ‘½%20Artificial%20Intelligence/ğŸ—ï¸%20AI%20(Data)%20Infrastructure%20&%20Techniques%20Stack/ğŸ›«%20Foundation%20Models%20&%20Development%20&%20SDKs/ML%20Programming%20&%20Frameworks/ML%20Programming%20&%20Frameworks.md)
- â†— [ML Toolkits & Runtimes](../../ğŸ§ %20Computing%20Methodologies/ğŸ‘½%20Artificial%20Intelligence/ğŸ—ï¸%20AI%20(Data)%20Infrastructure%20&%20Techniques%20Stack/ğŸ›«%20Foundation%20Models%20&%20Development%20&%20SDKs/ğŸ“Œ%20ML%20Toolkits%20&%20Runtimes/ML%20Toolkits%20&%20Runtimes.md)
â†— [Computer Graphics Programming](../../Software%20Engineering/â˜ï¸%20Application%20Software%20Engineering/ğŸ¨%20Computer%20Graphics%20Programming/Computer%20Graphics%20Programming.md)
â†— [Concurrent Programming](../ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/OS%20Processes%20&%20Automata%20Management%20(CPU%20+%20Main%20Memory%20Resource)/Concurrent%20Programming.md)
â†— [Embedded Programming & Software Development](../../Computer%20Engineering,%20Embedded%20&%20IoT/Embedded%20Programming%20&%20Software%20Development/Embedded%20Programming%20&%20Software%20Development.md)

â†— [Software Engineering](../../Software%20Engineering/Software%20Engineering.md)
â†— [Galleries & Awesome SE](../../Software%20Engineering/ğŸ‡%20Galleries%20&%20Awesome%20SE/Galleries%20&%20Awesome%20SE.md)

â†— [Software Security](../../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/Software%20Security.md)
â†— [Software (Program) Analysis & Binary Engineering](../../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/Software%20(Program)%20Analysis%20&%20Binary%20Engineering.md)

â†— [Natural Language Processing (NLP) & Computational Linguistics](../../ğŸ§ %20Computing%20Methodologies/ğŸ‘½%20Artificial%20Intelligence/âšœï¸%20Natural%20Language%20Processing%20(NLP)%20&%20Computational%20Linguistics/Natural%20Language%20Processing%20(NLP)%20&%20Computational%20Linguistics.md)


### Other Resources
[List Of Some Of The Software Development Trends That Have Dominated The Year 2020](https://www.cisin.com/coffee-break/trends/list-of-some-of-the-software-development-trends-that-have-dominated-the-year-2020.html)

ğŸªœ https://www.tiobe.com/tiobe-index/
TIOBE - programming language rank

ğŸ¬ã€å®éªŒç”Ÿå­˜æŒ‡å—ï¼šä»£ç é£æ ¼å’Œå®šåˆ¶åŒ– gdb è°ƒè¯• [å—äº¬å¤§å­¦2023æ“ä½œç³»ç»Ÿ-P18] (è’‹ç‚å²©)ã€‘ https://www.bilibili.com/video/BV1aT411H77C/?share_source=copy_web&vd_source=7740584ebdab35221363fc24d1582d9d

https://github.com/jobbole
ä¼¯ä¹åœ¨çº¿ - å„ç§ç¼–ç¨‹èµ„æºå¤§å…¨

ğŸ  https://www.microsoft.com/en-us/makecode
ğŸ“‚ https://makecode.microbit.org/docs
Microsoft MakeCode is a free online learn-to-code platform where anyone can build games, code devices, and mod Minecraft!

https://awesome-programming-books.github.io/
ğŸ“šç»å…¸æŠ€æœ¯ä¹¦ç± PDF æ–‡ä»¶ï¼Œæ¶µç›–ï¼šç¼–ç¨‹è¯­è¨€ã€è®¡ç®—æœºç³»ç»Ÿã€ç½‘ç»œåè®®ã€æ•°æ®åº“ã€ä»£ç è‰ºæœ¯ã€è®¾è®¡æ¨¡å¼ã€ç®—æ³•ä¸æ•°æ®ç»“æ„ã€ç³»ç»Ÿæ¶æ„ã€å¾®æœåŠ¡ã€æµ‹è¯•ã€ç¨‹åºå‘˜èŒä¸šä¿®ç‚¼ç­‰ç›¸å…³ä¹¦ç±ã€‚



## Intro
### 0ï¸âƒ£ Formal Languages ğŸ†š Natural Languages
> â†— [Language & Literature /The Importance of Language: Natural Language ğŸ†š Formal Language](../../../Other%20Networks%20of%20Knowledge/Arts%20&%20Cultures/ğŸ“ƒ%20Language%20&%20Literature/Language%20&%20Literature.md#The%20Importance%20of%20Language:%20Natural%20Language%20ğŸ†š%20Formal%20Language)
> â†— [Linguistics](../../../Other%20Networks%20of%20Knowledge/Arts%20&%20Cultures/ğŸ“ƒ%20Language%20&%20Literature/Linguistics/Linguistics.md)
> â†— [Mathematical Logic (Foundations of Mathematics)](../../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/Mathematical%20Logic%20(Foundations%20of%20Mathematics).md)

> ğŸ”— https://runestone.academy/ns/books/published/thinkcspy/GeneralIntro/FormalandNaturalLanguages.html

**Natural languages**Â are the languages that people speak, such as English, Spanish, and French. They were not designed by people (although people try to impose some order on them); they evolved naturally.

**Formal languages**Â are languages that are designed by people for specific applications. For example, the notation that mathematicians use is a formal language that is particularly good at denoting relationships among numbers and symbols. Chemists use a formal language to represent the chemical structure of molecules. And most importantly:

> Programming languages are formal languages that have been designed to express computations.

Formal languages tend to have strict rules about syntax. For example,Â `3+3=6`Â is a syntactically correct mathematical statement, butÂ `3=+6$`Â is not. H2O is a syntactically correct chemical name, butÂ 2Zz is not.

Syntax rules come in two flavors, pertaining toÂ **tokens**Â and **structure**. Tokens are the basic elements of the language, such as words, numbers, and chemical elements. One of the problems withÂ `3=+6$`Â is thatÂ `$`Â is not a legal token in mathematics (at least as far as we know). Similarly,Â 2Zz is not legal because there is no element with the abbreviationÂ `Zz`.

The second type of syntax rule pertains to theÂ **structure**Â of a statementâ€” that is, the way the tokens are arranged. The statementÂ `3=+6$`Â is structurally illegal because you canâ€™t place a plus sign immediately after an equal sign. Similarly, molecular formulas have to have subscripts after the element name, not before.

When you read a sentence in English or a statement in a formal language, you have to figure out what the structure of the sentence isÂ (although in a natural language you do this subconsciously). This process is calledÂ **parsing**.

For example, when you hear the sentence, â€œThe other shoe fellâ€, you understand that the other shoe is the subject and fell is the verb. Once you have parsed a sentence, you can figure out what it means, or theÂ **semantics**Â of the sentence. Assuming that you know what a shoe is and what it means to fall, you will understand the general implication of this sentence.

Although formal and natural languages have many features in common â€” tokens, structure, syntax, and semantics â€” there are many **differences**:
- ambiguity
	- Natural languages are full ofÂ ambiguity, which people deal with by using contextual clues and other information. Formal languages are designed to be nearly or completely unambiguous, which means that any statement has exactly one meaning, regardless of context.
- redundancy
	- In order to make up for ambiguity and reduce misunderstandings, natural languages employ lots of redundancy. As a result, they are often verbose. Formal languages are less redundant and more concise.
- literalness
	- Formal languages mean exactly what they say. On the other hand, natural languages are full of idiom and metaphor. If someone says, â€œThe other shoe fellâ€, there is probably no shoe and nothing falling.
#### \* Linguistics and Semiotics
> â†— [Language & Literature](../../../Other%20Networks%20of%20Knowledge/Arts%20&%20Cultures/ğŸ“ƒ%20Language%20&%20Literature/Language%20&%20Literature.md) 
> â†— [Linguistics](../../../Other%20Networks%20of%20Knowledge/Arts%20&%20Cultures/ğŸ“ƒ%20Language%20&%20Literature/Linguistics/Linguistics.md)

> ğŸ”— https://en.wikipedia.org/wiki/Linguistics

Linguistics is the scientific study of language. The areas of linguistic analysis are syntax (rules governing the structure of sentences), semantics (meaning), morphology (structure of words), phonetics (speech sounds and equivalent gestures in sign languages), phonology (the abstract sound system of a particular language, and analogous systems of sign languages), and pragmatics (how the context of use contributes to meaning). Subdisciplines such as biolinguistics (the study of the biological variables and evolution of language) and psycholinguistics (the study of psychological factors in human language) bridge many of these divisions. 

> ğŸ”— https://en.wikipedia.org/wiki/Semiotics

Semiotics (/ËŒsÉ›miËˆÉ’tÉªks/ SEM-ee-OT-iks) is the systematic study of sign processes and the communication of meaning. In semiotics, a sign is defined as anything that communicates intentional and unintentional meaning or feelings to the sign's interpreter.

Semiosis is any activity, conduct, or process that involves signs. Signs often are communicated by verbal language, but also by gestures, or by other forms of language, e.g. artistic ones (music, painting, sculpture, etc.). Contemporary semiotics is a branch of science that generally studies meaning-making (whether communicated or not) and various types of knowledge.[1]

Unlike linguistics, semiotics also studies non-linguistic sign systems. Semiotics includes the study of indication, designation, likeness, analogy, allegory, metonymy, metaphor, symbolism, signification, and communication.
#### Mathematical Logic & Formal Logic Language
â†— [Mathematical Logic Basics (Formal Logic)](../../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Mathematical%20Logic%20Basics%20(Formal%20Logic).md)


###  1ï¸âƒ£ Computer Languages
> ğŸ”— https://en.wikipedia.org/wiki/Computer_language

AÂ **computer language**Â is aÂ [formal language](https://en.wikipedia.org/wiki/Formal_language "Formal language")Â used to communicate with aÂ [computer](https://en.wikipedia.org/wiki/Computer "Computer"). Types of computer languages include:
- [Construction language](https://en.wikipedia.org/wiki/Software_construction#Construction_languages "Software construction")Â â€“ all forms of communication by which a human canÂ [specify an executable problem solution to a computer](https://en.wikipedia.org/wiki/Computer_programming "Computer programming")
    - [Command language](https://en.wikipedia.org/wiki/Command_language "Command language")Â â€“ a language used to control the tasks of the computer itself, such as starting programs
    - [Configuration language](https://en.wikipedia.org/wiki/Configuration_file#Configuration_languages "Configuration file")Â â€“ a language used to writeÂ [configuration files](https://en.wikipedia.org/wiki/Configuration_files "Configuration files")
    - [Programming language](https://en.wikipedia.org/wiki/Programming_language "Programming language")Â â€“ a formal language designed to communicate instructions to a machine, particularly a computer
        - [Scripting language](https://en.wikipedia.org/wiki/Scripting_language "Scripting language")Â â€“ a type of programming language which typically is interpreted at runtime rather than being compiled
    - [Query language](https://en.wikipedia.org/wiki/Query_language "Query language")Â â€“ a language used to makeÂ [queries](https://en.wikipedia.org/wiki/Information_retrieval "Information retrieval")Â inÂ [databases](https://en.wikipedia.org/wiki/Databases "Databases")Â andÂ [information systems](https://en.wikipedia.org/wiki/Information_systems "Information systems")
    - [Transformation language](https://en.wikipedia.org/wiki/Transformation_language "Transformation language")Â â€“ designed to transform some input text in a certain formal language into a modified output text that meets some specific goal
- [Data exchange language](https://en.wikipedia.org/wiki/Data_exchange#Data_exchange_languages "Data exchange")Â â€“ a language that is domain-independent and can be used for data from any kind of discipline; examples:Â [JSON](https://en.wikipedia.org/wiki/JSON "JSON"),Â [XML](https://en.wikipedia.org/wiki/XML "XML")
- [Markup language](https://en.wikipedia.org/wiki/Markup_language "Markup language")Â â€“ a grammar for annotating a document in a way that is syntactically distinguishable from the text, such asÂ [HTML](https://en.wikipedia.org/wiki/HTML "HTML")
- [Modeling language](https://en.wikipedia.org/wiki/Modeling_language "Modeling language")Â â€“ an artificial language used to express information or knowledge, often for use in computer system design
    - [Architecture description language](https://en.wikipedia.org/wiki/Architecture_description_language "Architecture description language")Â â€“ used as a language (or a conceptual model) to describe and represent system architectures
    - [Hardware description language](https://en.wikipedia.org/wiki/Hardware_description_language "Hardware description language")Â â€“ used to modelÂ [integrated circuits](https://en.wikipedia.org/wiki/Integrated_circuits "Integrated circuits")
- [Page description language](https://en.wikipedia.org/wiki/Page_description_language "Page description language")Â â€“ describes the appearance of a printed page in a higher level than an actual outputÂ [bitmap](https://en.wikipedia.org/wiki/Bitmap "Bitmap")
- [Simulation language](https://en.wikipedia.org/wiki/Simulation_language "Simulation language")Â â€“ a language used to describeÂ [simulations](https://en.wikipedia.org/wiki/Simulations "Simulations")
- [Specification language](https://en.wikipedia.org/wiki/Specification_language "Specification language")Â â€“ a language used to describe what a system should do
- [Style sheet language](https://en.wikipedia.org/wiki/Style_sheet_language "Style sheet language")Â â€“ a computer language that expresses the presentation of structured documents, such asÂ [CSS](https://en.wikipedia.org/wiki/CSS "CSS")
- [Expression language](https://en.wikipedia.org/wiki/Expression_language) -- aÂ [computer language](https://en.wikipedia.org/wiki/Computer_language "Computer language")Â for creating aÂ [machine readable](https://en.wikipedia.org/wiki/Machine_readable "Machine readable")Â representation of specificÂ [domain knowledge](https://en.wikipedia.org/wiki/Domain_knowledge "Domain knowledge"). Examples include:
	- [Advanced Boolean Expression Language](https://en.wikipedia.org/wiki/Advanced_Boolean_Expression_Language "Advanced Boolean Expression Language"), an obsolete hardware description language for hardware descriptions
	- [Data Analysis Expressions](https://en.wikipedia.org/wiki/Data_Analysis_Expressions "Data Analysis Expressions")Â (DAX), an expression language developed by Microsoft and used in Power Pivot, among other places
	- [Jakarta Expression Language](https://en.wikipedia.org/wiki/Jakarta_Expression_Language "Jakarta Expression Language"), a domain-specific language used in Jakarta EE web applications. Formerly known as "Unified Expression Language", "Expression Language" or just "the Expression Language").
	- [Rights Expression Languages](https://en.wikipedia.org/wiki/Rights_Expression_Language "Rights Expression Language"), machine processable language used for representing immaterial rights such as copyright and license information


### 2ï¸âƒ£ Programming Language
> ğŸ”— https://en.wikipedia.org/wiki/Programming_language

A programming language is a system of notation for writing computer programs. Programming languages are described in terms of their **syntax (form)** and **semantics (meaning)**, usually defined by a formal language. Languages usually provide features such as a **type system**, **variables**, and **mechanisms for error handling**. An implementation of a programming language is required in order to execute programs, namely an interpreter or a compiler. An interpreter directly executes the source code, while a compiler produces an executable program.

Computer architecture has strongly influenced the design of programming languages, with the most common type (imperative languagesâ€”which implement operations in a specified order) developed to perform well on the popular von Neumann architecture. While early programming languages were closely tied to the hardware, over time they have developed more abstraction to hide implementation details for greater simplicity.

![](../../../Assets/Pics/Screenshot%202025-04-23%20at%2012.18.18.png)
<small><a>https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80#%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5</a></small>
#### History & Generations of (High-Level) Programming Languages
> â†— https://en.wikipedia.org/wiki/Hyponymy_and_hypernymy 

![](../../../Assets/Pics/600px-Hyponym_and_hypernym.png)


> â†— https://zh.wikipedia.org/zh-cn/ç¨‹å¼èªè¨€æ­·å²
+ Hyponymy & hyperymy

> ğŸ“– Compilers Principles Techniques and Tools 2nd Edition



> â†— https://en.wikipedia.org/wiki/History_of_programming_languages

1. Early History
	1. During 1842â€“1849, **Ada Lovelace** translated the memoir of Italian mathematician Luigi Menabrea about Charles Babbage's newest proposed machine: the **Analytical Engine**; she supplemented the memoir with notes that specified in detail a method for calculating Bernoulli numbers with the engine, recognized by most of historians as the **world's first published computer program**.
	2. **Jacquard Looms** and **Charles Babbage**'s **Difference Engine** both were designed to utilize punched cards, which would describe the sequence of operations that their programmable machines should perform.
	3. The **first computer codes** were specialized for their applications: e.g., Alonzo Church was able to express the lambda calculus in a formulaic way and the Turing machine was an abstraction of the operation of a tape-marking machine.
	4. In the 1940s, the **first recognizably modern electrically powered computers** were created. The limited speed and memory capacity forced programmers to write hand-tuned assembly language programs. It was eventually realized that programming in assembly language required a great deal of intellectual effort. An early proposal for a high-level programming language was PlankalkÃ¼l, developed by Konrad Zuse for his Z1 computer between 1942 and 1945 but not implemented at the time. 
	5. The **first functioning programming languages** designed to communicate instructions to a computer were written in the early 1950s. John Mauchly's Short Code, proposed in 1949, was one of the first high-level languages ever developed for an electronic computer. Unlike machine code, Short Code statements represented mathematical expressions in understandable form. However, the program had to be interpreted into machine code every time it ran, making the process much slower than running the equivalent machine code.
2. 1950 ï½ 1967
	1. Some notable languages that were developed in this period include:
	2. 1951 â€“Â [Regional Assembly Language](https://en.wikipedia.org/wiki/Assembly_language "Assembly language")
	3. 1952 â€“Â [Autocode](https://en.wikipedia.org/wiki/Autocode "Autocode")
	4. 1954 â€“Â [IPL](https://en.wikipedia.org/wiki/Information_Processing_Language "Information Processing Language")Â (forerunner to LISP)
	5. 1955 â€“Â [FLOW-MATIC](https://en.wikipedia.org/wiki/FLOW-MATIC "FLOW-MATIC")Â (led to COBOL)
	6. 1957 â€“Â [FORTRAN](https://en.wikipedia.org/wiki/Fortran "Fortran")Â (first compiler)
	7. 1957 â€“Â [COMTRAN](https://en.wikipedia.org/wiki/COMTRAN "COMTRAN")Â (precursor to COBOL)
	8. 1958 â€“Â [LISP](https://en.wikipedia.org/wiki/Lisp_\(programming_language\) "Lisp (programming language)")
	9. 1958 â€“Â [ALGOL 58](https://en.wikipedia.org/wiki/ALGOL_58 "ALGOL 58")
	10. 1959 â€“Â [FACT](https://en.wikipedia.org/wiki/FACT_computer_language "FACT computer language")Â (forerunner to COBOL)
	11. 1959 â€“Â [COBOL](https://en.wikipedia.org/wiki/COBOL "COBOL")
	12. 1959 â€“Â [RPG](https://en.wikipedia.org/wiki/IBM_RPG "IBM RPG")
	13. 1960 â€“Â [ALGOL 60](https://en.wikipedia.org/wiki/ALGOL_60 "ALGOL 60")
	14. 1962 â€“Â [APL](https://en.wikipedia.org/wiki/APL_\(programming_language\) "APL (programming language)")
	15. 1962 â€“Â [Simula](https://en.wikipedia.org/wiki/Simula "Simula")
	16. 1962 â€“Â [SNOBOL](https://en.wikipedia.org/wiki/SNOBOL "SNOBOL")
	17. 1963 â€“Â [CPL](https://en.wikipedia.org/wiki/Combined_Programming_Language "Combined Programming Language")Â (forerunner to C)
	18. 1964 â€“Â [Speakeasy](https://en.wikipedia.org/wiki/Speakeasy_\(computational_environment\) "Speakeasy (computational environment)")
	19. 1964 â€“Â [BASIC](https://en.wikipedia.org/wiki/BASIC "BASIC")
	20. 1964 â€“Â [PL/I](https://en.wikipedia.org/wiki/PL/I "PL/I")
	21. 1966 â€“Â [JOSS](https://en.wikipedia.org/wiki/JOSS "JOSS")
	22. 1966 â€“Â [MUMPS](https://en.wikipedia.org/wiki/MUMPS "MUMPS")
	23. 1967 â€“Â [BCPL](https://en.wikipedia.org/wiki/BCPL "BCPL")Â (forerunner to C)
	24. 1967 â€“Â [Logo](https://en.wikipedia.org/wiki/Logo_\(programming_language\) "Logo (programming language)")Â (an educational language that later influencedÂ [Smalltalk](https://en.wikipedia.org/wiki/Smalltalk "Smalltalk")Â andÂ [Scratch](https://en.wikipedia.org/wiki/Scratch_\(programming_language\) "Scratch (programming language)")).
3. 1967 ï½ 1978
	1. Some notable languages that were developed in this period include:
	2. 1967 â€“Â [BCPL](https://en.wikipedia.org/wiki/BCPL "BCPL")Â (forerunner to B)
	3. 1967 â€“Â [Logo](https://en.wikipedia.org/wiki/Logo_\(programming_language\) "Logo (programming language)")
	4. 1969 â€“Â [B](https://en.wikipedia.org/wiki/B_\(programming_language\) "B (programming language)")Â (forerunner to C)
	5. 1970 â€“Â [Pascal](https://en.wikipedia.org/wiki/Pascal_\(programming_language\) "Pascal (programming language)")
	6. 1970 â€“Â [Forth](https://en.wikipedia.org/wiki/Forth_\(programming_language\) "Forth (programming language)")
	7. 1972 â€“Â [C](https://en.wikipedia.org/wiki/C_\(programming_language\) "C (programming language)")
	8. 1972 â€“Â [Smalltalk](https://en.wikipedia.org/wiki/Smalltalk "Smalltalk")
	9. 1972 â€“Â [Prolog](https://en.wikipedia.org/wiki/Prolog "Prolog")
	10. 1973 â€“Â [ML](https://en.wikipedia.org/wiki/ML_\(programming_language\) "ML (programming language)")
	11. 1975 â€“Â [Scheme](https://en.wikipedia.org/wiki/Scheme_\(programming_language\) "Scheme (programming language)")
	12. 1978 â€“Â [SQL](https://en.wikipedia.org/wiki/SQL "SQL")Â (a query language, later extended)
4. 1980 ï½
	1. Some notable languages that were developed in this period include:
	2. 1980 â€“Â [C++](https://en.wikipedia.org/wiki/C%2B%2B "C++")Â (asÂ [C with classes](https://en.wikipedia.org/wiki/C_with_classes "C with classes"), renamed inÂ 1983)
	3. 1983 â€“Â [Ada](https://en.wikipedia.org/wiki/Ada_\(programming_language\) "Ada (programming language)")
	4. 1984 â€“Â [Common Lisp](https://en.wikipedia.org/wiki/Common_Lisp "Common Lisp")
	5. 1984 â€“Â [MATLAB](https://en.wikipedia.org/wiki/MATLAB "MATLAB")
	6. 1984 â€“ dBase III, dBase III Plus ([Clipper](https://en.wikipedia.org/wiki/Clipper_\(programming_language\) "Clipper (programming language)")Â andÂ [FoxPro](https://en.wikipedia.org/wiki/FoxPro "FoxPro")Â asÂ [FoxBASE](https://en.wikipedia.org/wiki/FoxBASE "FoxBASE"))
	7. 1985 â€“Â [Eiffel](https://en.wikipedia.org/wiki/Eiffel_\(programming_language\) "Eiffel (programming language)")
	8. 1986 â€“Â [Objective-C](https://en.wikipedia.org/wiki/Objective-C "Objective-C")
	9. 1986 â€“Â [LabVIEW](https://en.wikipedia.org/wiki/LabVIEW "LabVIEW")Â ([visual programming language](https://en.wikipedia.org/wiki/Visual_programming_language "Visual programming language"))
	10. 1986 â€“Â [Erlang](https://en.wikipedia.org/wiki/Erlang_\(programming_language\) "Erlang (programming language)")
	11. 1987 â€“Â [Perl](https://en.wikipedia.org/wiki/Perl "Perl")
	12. 1988 â€“Â [PIC (markup language)](https://en.wikipedia.org/wiki/PIC_\(markup_language\) "PIC (markup language)")
	13. 1988 â€“Â [Tcl](https://en.wikipedia.org/wiki/Tcl "Tcl")
	14. 1988 â€“Â [Wolfram Language](https://en.wikipedia.org/wiki/Wolfram_Language "Wolfram Language")Â (as part ofÂ [Mathematica](https://en.wikipedia.org/wiki/Mathematica "Mathematica"), only got a separate name in June 2013)
	15. 1989 â€“Â [FL](https://en.wikipedia.org/wiki/FL_\(programming_language\) "FL (programming language)")Â (Backus)
5. 1990 ï½
	1. Some notable languages that were developed in this period include:
	2. 1990 â€“Â [Haskell](https://en.wikipedia.org/wiki/Haskell "Haskell")
	3. 1991 â€“Â [Python](https://en.wikipedia.org/wiki/Python_\(programming_language\) "Python (programming language)")
	4. 1991 â€“Â [Visual Basic](https://en.wikipedia.org/wiki/Visual_Basic_\(classic\) "Visual Basic (classic)")
	5. 1993 â€“Â [Lua](https://en.wikipedia.org/wiki/Lua_\(programming_language\) "Lua (programming language)")
	6. 1993 â€“Â [R](https://en.wikipedia.org/wiki/R_\(programming_language\) "R (programming language)")
	7. 1994 â€“Â [CLOS](https://en.wikipedia.org/wiki/CLOS "CLOS")Â (part of ANSIÂ [Common Lisp](https://en.wikipedia.org/wiki/Common_Lisp "Common Lisp"))
	8. 1995 â€“Â [Ruby](https://en.wikipedia.org/wiki/Ruby_\(programming_language\) "Ruby (programming language)")
	9. 1995 â€“Â [Ada 95](https://en.wikipedia.org/wiki/Ada_95 "Ada 95")
	10. 1995 â€“Â [Java](https://en.wikipedia.org/wiki/Java_\(programming_language\) "Java (programming language)")
	11. 1995 â€“Â [Delphi](https://en.wikipedia.org/wiki/Delphi_\(software\) "Delphi (software)")Â ([Object Pascal](https://en.wikipedia.org/wiki/Object_Pascal "Object Pascal"))
	12. 1995 â€“Â [Visual FoxPro](https://en.wikipedia.org/wiki/Visual_FoxPro "Visual FoxPro")
	13. 1995 â€“Â [JavaScript](https://en.wikipedia.org/wiki/JavaScript "JavaScript")
	14. 1995 â€“Â [PHP](https://en.wikipedia.org/wiki/PHP "PHP")
	15. 1996 â€“Â [OCaml](https://en.wikipedia.org/wiki/OCaml "OCaml")
	16. 1997 â€“Â [Rebol](https://en.wikipedia.org/wiki/Rebol "Rebol")
6. 2000 ï½ 
	1. Some notable languages developed during this period include:
	2. 2000 â€“Â [ActionScript](https://en.wikipedia.org/wiki/ActionScript "ActionScript")
	3. 2001 â€“Â [C#](https://en.wikipedia.org/wiki/C_Sharp_\(programming_language\) "C Sharp (programming language)")
	4. 2001 â€“Â [D](https://en.wikipedia.org/wiki/D_\(programming_language\) "D (programming language)")
	5. 2002 â€“Â [Scratch](https://en.wikipedia.org/wiki/Scratch_\(programming_language\) "Scratch (programming language)")
	6. 2003 â€“Â [Groovy](https://en.wikipedia.org/wiki/Groovy_\(programming_language\) "Groovy (programming language)")
	7. 2003 â€“Â [Scala](https://en.wikipedia.org/wiki/Scala_\(programming_language\) "Scala (programming language)")
	8. 2005 â€“Â [F#](https://en.wikipedia.org/wiki/F_Sharp_\(programming_language\) "F Sharp (programming language)")
	9. 2005 â€“Â [Haxe](https://en.wikipedia.org/wiki/Haxe "Haxe")
	10. 2006 â€“Â [PowerShell](https://en.wikipedia.org/wiki/Windows_PowerShell "Windows PowerShell")
	11. 2007 â€“Â [Clojure](https://en.wikipedia.org/wiki/Clojure "Clojure")
	12. 2008 â€“Â [Nim](https://en.wikipedia.org/wiki/Nim_\(programming_language\) "Nim (programming language)")
	13. 2009 â€“Â [Go](https://en.wikipedia.org/wiki/Go_\(programming_language\) "Go (programming language)")
7. 2010 ~
	1. Some notable languages developed during this period include:
	2. 2011 â€“Â [Dart](https://en.wikipedia.org/wiki/Dart_\(programming_language\) "Dart (programming language)")
	3. 2011 â€“Â [Kotlin](https://en.wikipedia.org/wiki/Kotlin_\(programming_language\) "Kotlin (programming language)")
	4. 2012 â€“Â [Julia](https://en.wikipedia.org/wiki/Julia_\(programming_language\) "Julia (programming language)")
	5. 2012 â€“Â [TypeScript](https://en.wikipedia.org/wiki/TypeScript "TypeScript")
	6. 2012 â€“Â [Elixir](https://en.wikipedia.org/wiki/Elixir_\(programming_language\) "Elixir (programming language)")
	7. 2014 â€“Â [Swift](https://en.wikipedia.org/wiki/Swift_\(programming_language\) "Swift (programming language)")
	8. 2014 â€“Â [Hack](https://en.wikipedia.org/wiki/Hack_\(programming_language\) "Hack (programming language)")
	9. 2015 â€“Â [Rust](https://en.wikipedia.org/wiki/Rust_\(programming_language\) "Rust (programming language)")
	10. 2015 â€“Â [Raku](https://en.wikipedia.org/wiki/Raku_\(programming_language\) "Raku (programming language)")
	11. 2016 â€“Â [Ring](https://en.wikipedia.org/wiki/Ring_\(programming_language\) "Ring (programming language)")
	12. 2016 â€“Â [Zig](https://en.wikipedia.org/wiki/Zig_\(programming_language\) "Zig (programming language)")
8. 2020 ~
	1. Some notable new programming languages include:
	2. 2021 â€“Â [Power Fx](https://en.wikipedia.org/wiki/Microsoft_Power_Fx "Microsoft Power Fx")
	3. 2022 â€“Â [Carbon](https://en.wikipedia.org/wiki/Carbon_\(programming_language\) "Carbon (programming language)")
	4. 2023 â€“Â [Mojo](https://en.wikipedia.org/wiki/Mojo_\(programming_language\) "Mojo (programming language)")

---
> ğŸ”— https://cs.stackexchange.com/a/102417/174354

There are supposedly generations of languages. According toÂ [Wikipedia](https://en.wikipedia.org/wiki/Fifth_generation_computer):
- First generation: Machine language.
- Second generation: Low-level programming languages such as assembly language.
- Third generation: Structured high-level programming languages such as C, COBOL and FORTRAN.
- Fourth generation: Domain-specific high-level programming languages such as SQL (for database access) and TeX (for text formatting)
- The fifth generation was supposed to be developed by Japan's fifth generation project in the 1980s but didn't really go anywhere. Some people consider constraint-based languages to be fifth generation ([Wikipedia](https://en.wikipedia.org/wiki/Fifth-generation_programming_language)).

There is also a supposed hierarchy of language power, expressed by Paul Graham as the "[Blub Paradox](https://en.wikipedia.org/wiki/Paul_Graham_\(programmer\)#The_Blub_paradox)" in his essayÂ [Beating the Averages](http://www.paulgraham.com/avg.html). In this controversial approach, languages such as Basic and Cobol are low in the hierarchy, Python and Perl would be in the middle, and Lisp would be at the top.

![](../../../Assets/Pics/Screenshot%202023-06-24%20at%208.14.09%20PM.png)
#### Programming Language Theory: The Designing of A Programming Language
> â†— [Programming Language Theory (PLT)](ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Programming%20Language%20Theory%20(PLT).md)

> ğŸ”— https://en.wikipedia.org/wiki/Programming_language_theory

Programming language theory (PLT) is a branch of computer science that deals with the design, implementation, analysis, characterization, and classification of formal languages known as programming languages. Programming language theory is closely related to other fields including mathematics, software engineering, and linguistics.



## Programming Languages Taxonomy
### Lists of Programming Languages
> ğŸ”— https://en.wikipedia.org/wiki/Lists_of_programming_languages
> 
> This is an index to notable programming languages, in current or historical use. Dialects of BASIC (which have their own page), esoteric programming languages, and markup languages are not included. A programming language does not need to be imperative or Turing-complete, but must be executable and so does not include markup languages such as HTML or XML, but does include domain-specific languages such as SQL and its dialects.

Â - [List of programming languages](https://en.wikipedia.org/wiki/List_of_programming_languages "List of programming languages")
Â - [List of programming languages by type](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type "List of programming languages by type")
Â - [Lists of programming languages](https://en.wikipedia.org/wiki/Lists_of_programming_languages "Lists of programming languages")
Â - [List of programming languages for artificial intelligence](https://en.wikipedia.org/wiki/List_of_programming_languages_for_artificial_intelligence "List of programming languages for artificial intelligence")
Â - [List of audio programming languages](https://en.wikipedia.org/wiki/List_of_audio_programming_languages "List of audio programming languages")
Â - [List of BASIC dialects](https://en.wikipedia.org/wiki/List_of_BASIC_dialects "List of BASIC dialects")
Â - [List of C-family programming languages](https://en.wikipedia.org/wiki/List_of_C-family_programming_languages "List of C-family programming languages")
Â - [List of CLI languages](https://en.wikipedia.org/wiki/List_of_CLI_languages "List of CLI languages")
Â - [List of concurrent and parallel programming languages](https://en.wikipedia.org/wiki/List_of_concurrent_and_parallel_programming_languages "List of concurrent and parallel programming languages")
Â - [List of educational programming languages](https://en.wikipedia.org/wiki/List_of_educational_programming_languages "List of educational programming languages")
Â - [Generational list of programming languages](https://en.wikipedia.org/wiki/Generational_list_of_programming_languages "Generational list of programming languages")
Â - [List of JVM languages](https://en.wikipedia.org/wiki/List_of_JVM_languages "List of JVM languages")
Â - [List of Lisp-family programming languages](https://en.wikipedia.org/wiki/List_of_Lisp-family_programming_languages "List of Lisp-family programming languages")
Â - [List of open-source programming languages](https://en.wikipedia.org/wiki/List_of_open-source_programming_languages "List of open-source programming languages")
Â - [Non-English-based programming languages](https://en.wikipedia.org/wiki/Non-English-based_programming_languages "Non-English-based programming languages")
Â - [List of object-oriented programming languages](https://en.wikipedia.org/wiki/List_of_object-oriented_programming_languages "List of object-oriented programming languages")
Â - [List of reflective programming languages and platforms](https://en.wikipedia.org/wiki/List_of_reflective_programming_languages_and_platforms "List of reflective programming languages and platforms")
Â - [Timeline of programming languages](https://en.wikipedia.org/wiki/Timeline_of_programming_languages "Timeline of programming languages")
Â - [Unisys MCP programming languages](https://en.wikipedia.org/wiki/Unisys_MCP_programming_languages "Unisys MCP programming languages")


### ğŸ‘‰ By Programming Eco/Platform/Frameworks
#### [.NET](https://zh.wikipedia.org/wiki/.NET%E6%A1%86%E6%9E%B6 ".NETæ¡†æ¶")
- [C#](https://zh.wikipedia.org/wiki/C%E2%99%AF "Câ™¯") 
    - [Visual C#](https://zh.wikipedia.org/wiki/Microsoft_Visual_C%E2%99%AF "Microsoft Visual Câ™¯")
- [C++/CLI](https://zh.wikipedia.org/wiki/C%2B%2B/CLI "C++/CLI") 
	- [Visual C++](https://zh.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B "Microsoft Visual C++")
- [F#](https://zh.wikipedia.org/wiki/F%E2%99%AF "Fâ™¯")
- [PowerShell](https://zh.wikipedia.org/wiki/PowerShell "PowerShell")
- [IronPython](https://zh.wikipedia.org/wiki/IronPython "IronPython")
- [IronScheme](https://zh.wikipedia.org/w/index.php?title=IronScheme&action=edit&redlink=1)
- [VB.NET](https://zh.wikipedia.org/wiki/Visual_Basic_.NET "Visual Basic .NET")
- [Small Basic](https://zh.wikipedia.org/wiki/Microsoft_Small_Basic "Microsoft Small Basic")
#### JVM
- [Java](https://zh.wikipedia.org/wiki/Java "Java") 
    - [AspectJ](https://zh.wikipedia.org/w/index.php?title=AspectJ&action=edit&redlink=1)
    - [JSP](https://zh.wikipedia.org/wiki/JSP "JSP")
- [Scala](https://zh.wikipedia.org/wiki/Scala "Scala")
- [Clojure](https://zh.wikipedia.org/wiki/Clojure "Clojure")
- [JRuby](https://zh.wikipedia.org/wiki/JRuby "JRuby")
- [Jython](https://zh.wikipedia.org/wiki/Jython "Jython")
- [Kawa](https://zh.wikipedia.org/w/index.php?title=Kawa&action=edit&redlink=1)
- [Groovy](https://zh.wikipedia.org/wiki/Groovy "Groovy")
- [Kotlin](https://zh.wikipedia.org/wiki/Kotlin "Kotlin")
#### [Xcode](https://zh.wikipedia.org/wiki/Xcode "Xcode")
- [Objective-C](https://zh.wikipedia.org/wiki/Objective-C "Objective-C")
- [AppleScript](https://zh.wikipedia.org/wiki/AppleScript "AppleScript")
- [Swift](https://zh.wikipedia.org/wiki/Swift_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80) "Swift (ç¨‹å¼èªè¨€)")


### ğŸ‘‰ By Programming Paradigm
> ğŸ”— https://www.geeksforgeeks.org/introduction-of-programming-paradigms/

**Paradigm**Â can also be termed as method to solve some problem or do some task. Programming paradigm is an approach to solve problem using some programming language or also we can say it is a method to solve a problem using tools and techniques that are available to us following some approach. There are lots for programming language that are known but all of them need to follow some strategy when they are implemented and this methodology/strategy is paradigms.

![img](../../../Assets/Pics/1-344.png)
<small><a>https://www.geeksforgeeks.org/introduction-of-programming-paradigms/</a></small>
#### 1ï¸âƒ£ Declarative Programming Paradigm
> ğŸ’¡ [Reactive Programming](https://en.wikipedia.org/wiki/Reactive_programming) is aÂ declarative programming paradigmÂ concerned withÂ data streams and the propagation of change. With this paradigm, it's possible to express static (e.g., arrays) or dynamic (e.g., event emitters) data streams with ease, and also communicate that an inferred dependency within the associated execution model exists, which facilitates the automatic propagation of the changed data flow.
> 
> My notes of Reactive Programing Paradigm can be found in â†— [Software Engineering/Dev Pattern/RX](../../Software%20Engineering/Software%20Development%20Pattern/RX%20(ReactiveX)/RX%20(ReactiveX).md)

It is divided as Logic, Functional, Database. In computer science theÂ _declarative programming_Â is **a style of building programs that expresses logic of computation without talking about its control flow**. It often considers programs as theories of some logic. It may simplify writing parallel programs. The focus is on what needs to be done rather how it should be done basically emphasize on what code is actually doing. It just declares the result we want rather how it has be produced. This is the only difference between imperative (how to do) and declarative (what to do) programming paradigms. Getting into deeper we would see logic, functional and database.
##### 1. Logic Programming Paradigm
It can be termed as abstract model of computation. It would solve logical problems like puzzles, series etc. In logic programming we have a knowledge base which we know before and along with the question and knowledge base which is given to machine, it produces result. In normal programming languages, such concept of knowledge base is not available but while using the concept of artificial intelligence, machine learning we have some models like Perception model which is using the same mechanism.Â   
In logical programming the main emphasize is on knowledge base and the problem. The execution of the program is very much like proof of mathematical statement, e.g., Prolog.

â†— [Logic Programming Languages](Other%20Languages%20for%20Specific%20Areas/Logic%20Programming%20Languages/Logic%20Programming%20Languages.md)
- ğŸ‘‰ [Lambda Calculus (Î»-Calculus)](Other%20Languages%20for%20Specific%20Areas/Logic%20Programming%20Languages/Lambda%20Calculus%20(Î»-Calculus).md)
- ğŸ‘‰ [Prolog (Programmation en Logique)](Other%20Languages%20for%20Specific%20Areas/Logic%20Programming%20Languages/Prolog%20(Programmation%20en%20Logique)/Prolog%20(Programmation%20en%20Logique).md)
- ğŸ‘‰ [Datalog (Data Logic)](Other%20Languages%20for%20Specific%20Areas/Logic%20Programming%20Languages/Datalog%20(Data%20Logic)/Datalog%20(Data%20Logic).md)
##### 2. Functional Programming
e.g.
- ğŸ‘‰ [ECMAScript-Based Languages & JavaScript](Compiled%20Languages/ğŸ%20ECMAScript-Based%20Languages%20&%20JavaScript/ECMAScript-Based%20Languages%20&%20JavaScript.md): developed by Brendan Eich
- ğŸ‘‰ [Haskell](Other%20Languages%20for%20Specific%20Areas/Functional%20Programming%20Languages/Haskell/Haskell.md): developed by Lennart Augustsson, Dave Barton
- ğŸ‘‰ [Scala](Compiled%20+%20Interpreted%20Languages/âš°ï¸%20JVM-Based%20Languages/Scala/Scala.md): developed by Martin Odersky
- ğŸ‘‰ **Erlang**: developed by Joe Armstrong, Robert Virding
- â†— [Lisp-Based Languages](Compiled%20Languages/Lisp-Based%20Languages/Lisp-Based%20Languages.md)
	- ğŸ‘‰ [Lisp](Compiled%20Languages/Lisp-Based%20Languages/Lisp/Lisp.md): developed by John Mccarthy
	- ğŸ‘‰ **ML**: developed by Robin Milner
	- ğŸ‘‰ [Clojure](Compiled%20Languages/Lisp-Based%20Languages/Clojure/Clojure.md): developed by Rich Hickey
##### 3. Database Processing Approach
e.g.
- â†— [Database Languages](Other%20Languages%20for%20Specific%20Areas/Database%20Languages/Database%20Languages.md)
	- â†— [Record-Based Data Model Languages](Other%20Languages%20for%20Specific%20Areas/Database%20Languages/Record-Based%20Data%20Model%20Languages/Record-Based%20Data%20Model%20Languages.md)
	- â†— [Object-Based Data Model Languages](Other%20Languages%20for%20Specific%20Areas/Database%20Languages/Object-Based%20Data%20Model%20Languages/Object-Based%20Data%20Model%20Languages.md)
	- â†— [Query Languages (Data Query Languages, DQL)](Other%20Languages%20for%20Specific%20Areas/Database%20Languages/ğŸ¦†%20Query%20Languages%20(Data%20Query%20Languages,%20DQL)/Query%20Languages%20(Data%20Query%20Languages,%20DQL).md)
		- â†— [SQL (Structured Query Language)](Other%20Languages%20for%20Specific%20Areas/Database%20Languages/ğŸ¦†%20Query%20Languages%20(Data%20Query%20Languages,%20DQL)/ğŸ©¼%20SQL%20(Structured%20Query%20Language)/SQL%20(Structured%20Query%20Language).md)

```mysql
CREATE DATABASE databaseAddress;
CREATE TABLE Addr (
    PersonID int,
    LastName varchar(200),
    FirstName varchar(200),
    Address varchar(200),
    City varchar(200),
    State varchar(200)
);
```
#### 2ï¸âƒ£ Imperative Programming Paradigm
It is one of the oldest programming paradigm. It features close relation to machine architecture. It is based on Von Neumann architecture. It works by changing the program state through assignment statements. It performs step by step task by changing state. The main focus is on how to achieve the goal. The paradigm consist of several statements and after execution of all the result is stored.

> Examples of **Imperative** programming paradigm:
> 
> **C**: developed by Dennis Ritchie and Ken Thompson
> **Fortran**: developed by John Backus for IBM
> **Basic**: developed by John G Kemeny and Thomas E Kurtz
##### 1. Procedural Programming Paradigm
e.g.
- â†— [C-Based Languages](Compiled%20Languages/ğŸ‘”%20C-Based%20Languages/C-Based%20Languages.md)
- â†— [C & CPP](Compiled%20Languages/ğŸ‘”%20C-Based%20Languages/ğŸ¥%20C%20&%20CPP/C%20&%20CPP.md)
	- ğŸ‘‰ **C**: developed by Dennis Ritchie and Ken Thompson
	- ğŸ‘‰ **C++**: developed by Bjarne Stroustrup
- â†— [JVM-Based Languages](Compiled%20+%20Interpreted%20Languages/âš°ï¸%20JVM-Based%20Languages/JVM-Based%20Languages.md)
	- ğŸ‘‰ [Java](Compiled%20+%20Interpreted%20Languages/âš°ï¸%20JVM-Based%20Languages/â˜•ï¸%20Java/Java.md): developed by James Gosling at Sun Microsystems
- ğŸ‘‰ **ColdFusion**: developed by J J Allaire
- ğŸ‘‰ **Pascal**: developed by Niklaus Wirth
##### 2. Object Oriented Programming (OOP)
e.g.
- ğŸ‘‰ **Simula**: first OOP language
- ğŸ‘‰ [Java](Compiled%20+%20Interpreted%20Languages/âš°ï¸%20JVM-Based%20Languages/â˜•ï¸%20Java/Java.md): developed by James Gosling at Sun Microsystems
- ğŸ‘‰ **C++**: developed by Bjarne Stroustrup
- ğŸ‘‰ [Objective-C](Compiled%20Languages/ğŸ‘”%20C-Based%20Languages/Objective-C/Objective-C.md): designed by Brad Cox
- ğŸ‘‰ [Dot.Net-Based Languages](Compiled%20+%20Interpreted%20Languages/Dot.Net-Based%20Languages/Dot.Net-Based%20Languages.md): developed by Microsoft
- ğŸ‘‰ [Python](Interpreted%20Languages/ğŸ%20Python/Python.md): developed by Guido van Rossum
- ğŸ‘‰ [Ruby](Interpreted%20Languages/Ruby/Ruby.md): developed by Yukihiro Matsumoto
- ğŸ‘‰ **Smalltalk**: developed by Alan Kay, Dan Ingalls, Adele Goldberg
##### 3. Parallel Processing Approach
Parallel processing is the processing of program instructions by dividing them among multiple processors. A parallel processing system posses many numbers of processor with the objective of running a program in less time by dividing them. This approach seems to be like divide and conquer. 

Examples are NESL (one of the oldest one) and C/C++ also supports because of some library function.


### ğŸ‘‰ By Programming Scenario
1. scientific computing
2. application development
3. OS/kernel/driver development
4. other?



## Programming Language Basics
### 1ï¸âƒ£ Programming Model (Designer's Perspective)
![](../../../Assets/Pics/Pasted%20image%2020250726224307.png)
<small>Above is a complete Java programÂ â˜•ï¸ BinarySearch.java (<a>https://algs4.cs.princeton.edu/11model/BinarySearch.java.html</a>)Â that illustrates many of the basic features of our programming model. It implement a classic algorithm known asÂ <b>binary search</b>Â and tests it for an application known asÂ <b>allowlist filtering</b>.<br><a>https://algs4.cs.princeton.edu/11model/</a></small>
#### ğŸ“Œ The Evolution of Computing Model: From Finite Sates Machine to Turing Machine
â†— [Mathematical Logic (Foundations of Mathematics)](../../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/Mathematical%20Logic%20(Foundations%20of%20Mathematics).md)
- â†— [First-Order Logic & Predicate Calculus -ï¼ˆä¸€é˜¶ï¼‰è°“è¯é€»è¾‘](../../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Classical%20Logic%20(Standard%20Logic)/First-Order%20Logic%20&%20Predicate%20Calculus%20-ï¼ˆä¸€é˜¶ï¼‰è°“è¯é€»è¾‘.md)
â†— [Automata Theory and (Formal) Language Theory](../../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)
#### Components and Grammars
> ğŸ”— https://algs4.cs.princeton.edu/11model/
> The book takes OOP Language of java for example. However, contents below generalize to other languages as well.

- Primitive data types and expressions
	- AÂ _data type_Â is a set of values and a set of operations on those values.The following four primitive data types are the basis of the Java language:
		- _Integers_, with arithmetic operations (int)
		- _Real numbers_, again with arithmetic operations (double)
		- _Booleans_, the set of values {Â _true_,Â _false_Â } with logical operations (boolean)
		- _Characters_, the alphanumeric characters and symbols that you type (char)
	- A (Java) program manipulatesÂ _variables_Â that are named withÂ _identifiers_. Each variable is associated with a data type and stores one of the permissible data-type values. We useÂ _expressions_Â to apply the operations associated with each type.
![](../../../Assets/Pics/Pasted%20image%2020250727163941.png)
<small>Example: Java Language<br><a>https://algs4.cs.princeton.edu/11model/</a></small>

- Other important data types:
	- _**Abstract data types (ADT).**_Â AnÂ _abstract data type_Â is a data type whose internal representation is hidden from the client.
	- **Bags, Queue, and the Stack. (ADT, basic data structures)** Several fundamental data types involve collections of objects. Specifically, the set of values is a collection of objects, and the operations revolve around adding, removing, or examining objects in the collection. They differ in the specification of which object is to be removed or examined next. â†— [Data Structures](../ğŸ§™â€â™‚ï¸%20Algorithm%20&%20Data%20Structure/ğŸ“Œ%20Algorithms%20Basics%20&%20Data%20Structure/Data%20Structures/Data%20Structures.md)
		- Array and resizing array implementations of collections.
		- Linked-list implementations of collections.
- Other operators:
	- bitwise logical operations
	- etc.

- Statements
	- A (Java) program is composed ofÂ _statements_, which define the computation by creating and manipulating variables, assigning data-type values to them, and controlling the flow of execution of such operations.
![](../../../Assets/Pics/Pasted%20image%2020250727163953.png)
<small>Example: Java Language<br><a>https://algs4.cs.princeton.edu/11model/</a></small>

- Arrays
	- AnÂ _array_Â stores a sequence of values that are all of the same type. If we haveÂ NÂ values, we can use the notationÂ a\[i\]Â to refer to theÂ ith value for any value ofÂ iÂ fromÂ 0Â toÂ N-1.

- Strings
	- A String is an indexed sequence of char values. A literal String is a sequence of characters within double quotes, such as "Hello, World". The data type String is a Java data type but it is not a primitive type. We consider String now because it is a fundamental data type that almost every (Java) program uses.
	- String values are similar to arrays of characters, but the two are not the same.
	- Computing with strings is an essential component of modern computing.

- Methods & API
	- Static methods
		- Static methods are calledÂ _functions_Â in many programming languages, since they can behave like mathematical functions. Each static method is a sequence of statements that are executed, one after the other, when the static method isÂ _called_.
		- ![](../../../Assets/Pics/Pasted%20image%2020250731215615.png)
		- <small>Example: Java Language<br><a>https://algs4.cs.princeton.edu/11model/</a></small>
	- Dynamic methods
	- Libraries and modular programming
		- (quote from the book *Algorithhms 4th Edition by Robert Sedgewick, Kevin Wayne*)
		- Of critical importance in this model is that libraries of static methods enable modular programming where we build libraries of static methods (modules) and a static method in one library can call static methods defined in other libraries. This approach has many important advantages. It allows us to
			- Work with modules of reasonable size, even in program involving a large amount of code
			- Share and reuse code without having to reimplement it
			- Easily substitute improved implementations
			- Develop appropriate abstract models for addressing programming problems
			- Localize debugging (see the paragraph below on unit testing)
			- etc.
	- API (Application Programming Interface)
		- To specify the behavior of an abstract data type, we use anÂ _application programming interface_Â (API), which (in Java) is a list ofÂ _constructors_Â andÂ _instance methods_Â (operations), with an informal description of the effect of each.
			- ![](../../../Assets/Pics/Pasted%20image%2020250729185842.png)
			- <small>Example: Java Language<br><a>https://algs4.cs.princeton.edu/13stacks/</a></small>
		- We use the term *client* to refer to a program that calls a method in another library and the term *implementation* to describe the code that implements the methods in an API.
		- (quote from the book *Algorithms 4th Edition by Robert Sedgewick, Kevin Wayne*)
			- **The purpose of an API** is to separate the client from the implementation: the client should know nothing about the implementation other than information given in the API, and the implementation should not take properties of any particular client into account. APIs enable us to separately develop code for various purposes, then reuse it widely. No Java library can contain all the methods that we might need for a given computation, so this ability is a crucial step in addressing complex programming applications. Accordingly, programmers normally think of the API as a contract between the client and the implementation that is a clear specification of what each method is to do. Our goal when developing an implementation is to honor the terms of the contract. Often, there are many ways to do so, and separating client code from implementation code gives us the freedom to substitute new and improved implementations. In the study of algorithms, this ability is an important ingredient in our ability to understand the impact of algorithmic improvements that we develop.
			- **Maintaining multiple implementations.** Multiple implementations of the same API can present maintenance and nomenclature issues. In some cases, we simply want to replace an old implementation with an improved one. In others, we may need to maintain two implementations, one suitable for some clients, the other suitable for others.
				- For this reason, we generally adopt an informal naming convention where we:
					- Identify different implementations of the same API by prepending a descriptive modifier. For example, we might name our Date implementations on the previous page BasicDate and SmallDate, and we might wish to develop a SmartDate implementation that can validate that dates are legal.
					- Maintain a reference implementation with no prefix that makes a choice that should be suitable for most clients. That is, most clients should just use Date. (while for other implementations use specific prefixes to indicate the purpose of this particular implementation)
				- In a large system, this solution is not ideal, as it might involve changing client code. For example, if we were to develop a new implementation ExtraSmallDate, then our only options are to change client code or to make it the reference implementation for use by all clients. Java has various advanced language mechanisms for maintaining multiple implementations without needing to change client code, but we use them sparingly because their use is challenging (and even controversial) even for experts, especially in conjunction with other advanced language features that we do value (generics and iterators). These issues are important (for example, ignoring them led to the celebrated Y2K problem at the turn of the millennium, because many programs used their own implementations of the date abstraction that did not take into account the first two digits of the year), but detailed consideration of these issues would take us rather far afield from the study of algorithms.
	- Unite testing
- Properties of methods
	- A complete detailed description of the properties of methods is beyond our scope, but the following points are worth noting:
		- Arguments are passed by value.
		- Method names can be overloaded.
		- A method has a single return value but may have multiple return statements.
		- A method can have side effects.
		- ==**Recursion**: a method can call itself.==
			- (quote from the book *Algorithhms 4th Edition by Robert Sedgewick, Kevin Wayne*)
			- We often use recursive implementations of methods because they can lead to compact, elegant code that is easier to understand than a corresponding implementation that does not use recursion.
			- There are three important rules of thumb in developing recursive programs:
				- The recursion has a base caseâ€”we always include a conditional statement as the first statement in the program that has a return.
				- Recursive calls must address subproblems that are smaller in some sense, so that recursive calls converge to the base case. In the code below, the difference between the values of the fourth and the third arguments always decreases.
				- Recursive calls should not address subproblems that overlap. In the code below, the portions of the array referenced by the two subproblems are disjoint.
			- Violating any of these guidelines is likely to lead to incorrect results or a spectacularly inefficient program (see Exercises 1.1.19 and 1.1.27). Adhering to them is likely to lead to a clear and correct program whose performance is easy to understand. Another reason to use recursive methods is that they lead to mathematical models that we can use to understand performance. We address this issue for binary search in Section 3.2 and in several other instances throughout the book.

- Input & Output
	- â†— [Shell & Terminals (Console)](../ğŸ¥·ğŸ¼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/ğŸš%20Shell%20&%20Terminals%20(Console)/Shell%20&%20Terminals%20(Console).md)
	- Commands and arguments
	- Standard Input /Output (STD I/O)
	- Formatted Output
	- Redirection & Piping
---

(JAVA /OOP specific:)

> ğŸ“– Algorithhms 4th Edition by Robert Sedgewick, Kevin Wayne

==A Java program ( class) is either a library of static methods (functions) or a data type definition. ==To create libraries of static methods and data-type definitions, we use the following five components, the basis of programming in Java and many other modern languages:
- Primitive data types precisely define the meaning of terms like integer, real number, and boolean value within a computer program. Their definition includes the set of possible values and operations on those values, which can be combined into expressions like mathematical expressions that define values.
- Statements allow us to define a computation by creating and assigning values to variables, controlling execution flow, or causing side effects. We use six types of statements: declarations, assignments, conditionals, loops, calls, and returns.
- Arrays allow us to work with multiple values of the same type. Static methods allow us to encapsulate and reuse code and to develop programs as a set of independent modules.
- Strings are sequences of characters. Some operations on them are built in to Java.
- Input/output sets up communication between programs and the outside world.
- Data abstraction extends encapsulation and reuse to allow us to define non-primitive data types, thus supporting object-oriented programming.

...

==Modern programming goes one step further by the idea of **data abstraction**, sometimes known as **object-oriented programming**.== Simply put, the idea behind data abstraction is to allow a program to define data types (sets of values and sets of operations on those values), not just static methods that operate on predefined data types.

...

Programming in Java is largely based on building data types known as **reference types** with the familiar Java class. This style of programming is known as object-oriented programming, as it revolves around the concept of an object, an entity that holds a data type value. With Javaâ€™s primitive types we are largely confined to programs that operate on numbers, but with reference types we can write programs that operate on strings, pictures, sounds, any of hundreds of other abstractions that are available in Javaâ€™s standard libraries or on our booksite. Even more significant than libraries of predefined data types is that the range of data types available in Java programming is open-ended, because you can define your own data types to implement any abstraction whatsoever.


> â†— [Java](Compiled%20+%20Interpreted%20Languages/âš°ï¸%20JVM-Based%20Languages/â˜•ï¸%20Java/Java.md)
> ğŸ”— https://algs4.cs.princeton.edu/12oop/

- _**Abstract data types (ADT).**_Â AnÂ _abstract data type_Â is a data type whose internal representation is hidden from the client. (i.e. object as in OOP)
	- ![](../../../Assets/Pics/Screenshot%202025-07-31%20at%2023.11.25.png)
	- <small>Algorithms 4th Edition by Robert Sedgewick, Kevin Wayne. 1.2 data abstraction</small>
- _**Client.**_Â A client is a program that uses a data type.
- _**Objects.**_Â AnÂ _object_Â is an entity that can take on a data-type value. 
	- (quote from the book *Algorithms 4th Edition by Robert Sedgewick, Kevin Wayne - page 67, section 1.2 data abstraction*)
	- Objects are characterized by three essential properties: state, identity, and behavior. The state of an object is a value from its data type. The identity of an object distinguishes one object from another. It is useful to think of an objectâ€™s identity as the place where its value is stored in memory. The behavior of an object is the heads effect of data-type operations. The implementation has the sole responsibility for maintaining an objectâ€™s identity, so that client code can use a data type without regard to the representation of its state by conforming to an API that describes an objectâ€™s behavior. An objectâ€™s state might be used to provide information to a client or cause a side effect or be changed by one of its data typeâ€™s operations, but the details of the representation of the data-type value are not relevant to client code.
	- A **reference** is a mechanism for accessing an object. Java nomenclature makes clear the distinction from primitive types (where variables are associated with values) by using the term reference types for non-primitive types. The details of implementing references vary in Java implementations, but it is useful to think of a reference as a memory address, as shown at right (for brevity, we use heads tails three-digit memory addresses in the diagram).
	- In Java, every value of any non-primitive type is an object.
	- Operations with an object:
		- creation
		- instance methods invoking
		- usage
			- aliasing & assignment statements
		- objects as arguments
		- objects as return values
		- arrays of objects
			- Arrays are objects (in java)

> ğŸ“– *Algorithhms 4th Edition by Robert Sedgewick, Kevin Wayne*
> 
> With this focus on objects, writing code that embraces data abstraction (defining and using data types, with data-type values held in objects) is widely referred to as object-oriented programming. The basic concepts that we have just covered are the starting point for object-oriented programming, so it is worthwhile to briefly summarize them. A data type is a set of values and a set of operations defined on those values. We implement data types in independent Java class modules and write client programs that use them. An object is an entity that can take on a data-type value or an instance of a data type. Objects are characterized by three essential properties: state, identity, and behavior. A data-type implementation supports clients of the data type as follows:
> - Client code can create objects (establish identity) by using the new construct to invoke a constructor that creates an object, initializes its instance variables, and returns a reference to that object.
> - Client code can manipulate data-type values (control an objectâ€™s behavior, possibly changing its state) by using a variable associated with an object to invoke an instance method that operates on that objectâ€™s instance variables.
> - Client code can manipulate objects by creating arrays of objects and passing them and returning them to methods, in the same way as for primitive-type values, except that variables refer to references to values, not the values themselves. These capabilities are the foundation of a flexible, modern, and widely useful programming style that we will use as the basis for studying algorithms in this book.

More about ADT and programming model:
- Use of ADT:
	- A client does not need to know how a data type is implemented in order to be able to use it.
- Implementation of ADT:
	- We implement ADTs with a _Java class_, putting the code in a file with the same name as the class, followed by the .java extension. The first statements in the file declareÂ _instance variables_Â that define the data-type values. Following the instance variables are theÂ _constructor_Â and theÂ _instance methods_Â that implement operations on data-type values.
	- ![](../../../Assets/Pics/Pasted%20image%2020250729130040.png)
	- ![](../../../Assets/Pics/Pasted%20image%2020250729130046.png)
- Designing ADT
	- _Encapsulation_
		- A hallmark of object-oriented programming is that it enables us to encapsulate data types within their implementations, to facilitate separate development of clients and data type implementations. Encapsulation enables modular programming, allowing us to
			- Independently develop of client and implementation code
			- Substitute improved implementations without affecting clients
			- Support programs not yet written (the API is a guide for any future client) Encapsulation also isolates data-type operations, which leads to the possibility of
			- Limiting the potential for error
			- Adding consistency checks and other debugging tools in implementations
			- Clarifying client code
	- _Designing APIs_
		- Â One of the most important and most challenging steps in building modern software is designing APIs. This task takes practice, careful deliberation, and many iterations, but any time spent designing a good API is certain to be repaid in time saved debugging or code reuse. Articulating an API might seem to be overkill when writing a small program, but you should consider writing every program as though you will need to reuse the code someday. 
		- Ideally, an API would clearly articulate behavior for all possible inputs, including side effects, and then we would have software to check that implementations meet the specification. Unfortunately, a fundamental result from theoretical computer science known as the specification problem implies that this goal is actually **impossible** to achieve. Briefly, such a specification would have to be written in a formal language like a programming language, and the problem of determining whether two programs perform the same computation is known, mathematically, to be undecidable. Therefore, our APIs are brief English-language descriptions of the set of values in the associated abstract data type along with a list of constructors and instance methods, again with brief English-language descriptions of their purpose, including side effects. To validate the design, we always include examples of client code in the text surrounding our APIs. 
		- Within this broad outline, there are numerous pitfalls that every API design is susceptible to (...) These considerations are sometimes summarized in yet another motto: ==provide to clients the methods they need and no others==.
	- _Algorithms and ADTs_
		- Data abstraction is naturally suited to the study of algorithms, because it helps us provide a framework within which we can precisely specify both what an algorithm needs to accomplish and how a client can make use of an algorithm.
	- Inheritance 
		- _Interface inheritance_
			- Java provides language support for defining relationships among objects, known asÂ _inheritance_. The first inheritance mechanism that we consider is known asÂ _subtyping_, which allows us to specify a relationship between otherwise unrelated classes by specifying in anÂ _interface_Â a set of common methods that each implementing class must contain. We use interface inheritance forÂ _comparison_Â and forÂ _iteration_.
		- _Implementation inheritance_
			- Java also supports another inheritance mechanism known asÂ _subclassing_, which is a powerful technique that enables a programmer to change behavior and add functionality without rewriting an entire class from scratch. The idea is to define a new class (_subclass_) that inherits instance methods and instance variables from another class (_superclass_). We avoid subclassing in this book because it generally works against encapsulation. Certain vestiges of the approach are built in to Java and therefore unavoidable: specifically, every class is a subclass ofÂ [Object](http://download.oracle.com/javase/6/docs/api/java/lang/Object.html).
	- _String conversion_
	- _Wrapper types_
		- Java supplies built-in reference types known asÂ _wrapper types_, one for each of the primitive types
			- boolean -> [Boolean](http://download.oracle.com/javase/6/docs/api/java/lang/Boolean.html)
			- byte -> [Byte](http://download.oracle.com/javase/6/docs/api/java/lang/Byte.html)
			- char -> [Character](http://download.oracle.com/javase/6/docs/api/java/lang/Character.html)
			- double -> [Double](http://download.oracle.com/javase/6/docs/api/java/lang/Double.html)
			- float -> [Float](http://download.oracle.com/javase/6/docs/api/java/lang/Float.html)
			- int -> [Integer](http://download.oracle.com/javase/6/docs/api/java/lang/Integer.html)
			- long -> [Long](http://download.oracle.com/javase/6/docs/api/java/lang/Long.html)
			- short -> [Short](http://download.oracle.com/javase/6/docs/api/java/lang/Short.html)
		- Java automatically converts from primitive types to wrapper types (_autoboxing_) and back (_auto-unboxing_) when warranted.
	- _Equality_
		- What does it mean for two objects to be equal? If we test equality withÂ (a == b)Â whereÂ aÂ andÂ bÂ are reference variables of the same type, we are testing whether they have the same identity: whether theÂ _references_Â are equal. Typical clients would rather be able to test whether theÂ _data-type values_Â (object state) are the same. Every Java type inherits the methodÂ equals()Â fromÂ [Object](http://download.oracle.com/javase/6/docs/api/java/lang/Object.html). Java provides natural implementations both for standard types such asÂ Integer,Â Double, andÂ StringÂ and for more complicated types such asÂ [java.io.File](http://download.oracle.com/javase/6/docs/api/java/io/File.html)Â andÂ [java.net.URL](http://download.oracle.com/javase/6/docs/api/java/net/URL.html). When we define our own data types we need to overrideÂ equals(). Java's convention is thatÂ equals()Â must be anÂ _equivalence relation_:
			- _Reflexive_:Â x.equals(x)Â is true.
			- _Symmetric_:Â x.equals(y)Â is true if and only ifÂ y.equals(x)Â is true.
			- _Transitive_: ifÂ x.equals(y)Â andÂ y.equals(z)Â are true, then so isÂ x.equals(z).
		- In addition, it must take anÂ ObjectÂ as argument and satisfy the following properties.
			- _Consistent_: multiple invocations ofÂ x.equals(y)Â consistently return the same value, provided neither object is modified.
			- _Not null_:Â x.equals(null)Â returns false.
		- Adhering to these Java conventions can be tricky, as illustrated forÂ [Date.java](https://algs4.cs.princeton.edu/12oop/Date.java.html)Â andÂ [Transaction.java](https://algs4.cs.princeton.edu/12oop/Transaction.java.html).
	- _Memory management_
	- _Immutability_
		- An immutable data type, such as Date, has the property that the value of an object never changes once constructed. By contrast, a mutable data type, such as Counter or Accumulator, manipulates object values that are intended to change. Javaâ€™s language support for helping to enforce immutability is the final modifier.
	- Visibility
		- public & private
	- Design by contract.
	- _Exceptions and errors_
	- _Assertions_

#### Control Flow

#### State Spaces


### 2ï¸âƒ£ Design Consideration of Programming Language (Compiler Engineer's Perspective)
> Compilers Principles Techniques and Tools 2nd Edition - 1 .6 Programming Language Basics
> In this section, we shall cover the most important terminology and distinctions that appear in the study of programming languages.
#### The Static/Dynamic Distinction

#### Environments and States

#### Static Scope and Block Structure

#### Explicit Access Control

#### Dynamic Scope

#### Parameter Passing Mechanisms

#### Aliasing


### 3ï¸âƒ£ Program in Practice: Data CRUD, Data Structure & Algorithm, and API Calling (Programmer's Perspective)
> Personally, I believe the best way to get to know the basic principles and practical details of programming languages, whether in order to learn a new programming language or to explore the designing principles of that language, is to learn in writing algorithms of that language.
> â†— [C & CPP](Compiled%20Languages/ğŸ‘”%20C-Based%20Languages/ğŸ¥%20C%20&%20CPP/C%20&%20CPP.md)
> â†— [Python](Interpreted%20Languages/ğŸ%20Python/Python.md)
> â†— [Java](Compiled%20+%20Interpreted%20Languages/âš°ï¸%20JVM-Based%20Languages/â˜•ï¸%20Java/Java.md)

> â†— [Algorithm & Data Structure](../ğŸ§™â€â™‚ï¸%20Algorithm%20&%20Data%20Structure/Algorithm%20&%20Data%20Structure.md)
> 
> https://algs4.cs.princeton.edu/11model/
> Algorithms, 4th edition, 1.1 section, Programming Model
> 
> https://introcs.cs.princeton.edu/java/home/
> Programming in Java Â  Â· Â  Computer Science Â  Â· Â  An Interdisciplinary Approach


### Program Execution: What's Under The Hood?
> â†— [The Essence of Computing - Programs & The Semantics of Programs](../../ğŸ—º%20CS%20Overview/The%20Essence%20of%20Computing%20-%20Programs%20&%20The%20Semantics%20of%20Programs.md)
> â†— [Program Compilation & Execution](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Program%20Compilation%20&%20Execution/Program%20Compilation%20&%20Execution.md)

![application_execution_and_computer_data_flow.excalidraw | 800](../../../Assets/Illustrations/Computer%20System/application_execution_and_computer_data_flow.excalidraw.md)
<small>Application Execution and Computer Data Flow</small>



## Ref
[ç¨‹åºç¿»è¯‘ä¸ç¨‹åºè§£é‡Š | cnblog]: https://www.cnblogs.com/jvStarBlog/p/11941513.html
![](../../../Assets/Pics/Pasted%20image%2020240606131637.png)

![](../../../Assets/Pics/Pasted%20image%2020240606131723.png)

**ç¡¬ä»¶é€»è¾‘å±‚**ï¼šä¸»è¦ç”±é—¨ç”µè·¯ã€è§¦å‘å™¨ç­‰é€»è¾‘ç”µè·¯ç»„æˆï¼Œå±äºç”µå­å·¥ç¨‹çš„é¢†åŸŸï¼Œè¿™é‡Œå°±ä¸å±•å¼€ä»‹ç»äº†ã€‚

**å¾®ç¨‹åºæœºå™¨å±‚**ï¼šç¼–ç¨‹è¯­è¨€ä¸»è¦æ˜¯å¾®æŒ‡ä»¤é›†ï¼Œå¾®æŒ‡ä»¤æ‰€ç»„æˆçš„å¾®ç¨‹åºç›´æ¥äº¤ç”±ç¡¬ä»¶æ‰§è¡Œï¼Œä¸»è¦æ˜¯ç”±ç”Ÿäº§ç¡¬ä»¶çš„å…¬å¸çš„ç¨‹åºå‘˜æ¥ç¼–å†™çš„ã€‚

**ä¼ ç»Ÿæœºå™¨å±‚**ï¼šç¼–ç¨‹è¯­è¨€ä¸»è¦æ˜¯CPUæŒ‡ä»¤é›†ï¼ˆæœºå™¨æŒ‡ä»¤ï¼‰ï¼Œå’Œç¡¬ä»¶æ˜¯ç›´æ¥ç›¸å…³çš„ï¼Œç¨‹åºå‘˜æ‰€ç”¨æœºå™¨æŒ‡ä»¤ç¼–å†™çš„ç¨‹åºå¯ä»¥äº¤ç”±å¾®ç¨‹åºç›´æ¥è¿›è¡Œè§£æï¼Œè€Œè¿™é‡Œæåˆ°çš„æŒ‡ä»¤é›†ï¼Œå­˜å‚¨åœ¨CPUå†…éƒ¨ï¼Œå¯¹CPUçš„è¿ç®—è¿›è¡ŒæŒ‡å¯¼å’Œä¼˜åŒ–ï¼Œæ‹¥æœ‰æŒ‡ä»¤é›†ï¼ŒCPUå°±å¯ä»¥æœ‰æ•ˆåœ°è¿è¡Œã€‚æˆ‘ä»¬çŸ¥é“ï¼ŒCPUçš„åˆ¶é€ å•†åˆ†ä¸ºAMDå’ŒIntelä¸¤å¤§é˜µè¥ï¼Œé‚£ä¹ˆè¿™ä¸¤å¤§å‚å•†ç”Ÿäº§çš„CPUæœ€å¤§çš„åŒºåˆ«æ˜¯â€”â€”æŒ‡ä»¤é›†ä¸åŒï¼ŒIntelçš„CPUæ‰€ä½¿ç”¨çš„æŒ‡ä»¤é›†ä¸é€‚åˆAMDçš„CPUï¼ŒåŒæ ·çš„ï¼ŒAMDçš„CPUæ‰€ä½¿ç”¨çš„æŒ‡ä»¤é›†ä¹Ÿä¸é€‚åˆIntelã€‚é™¤äº†ä¸åŒå‚å•†ä»¥åï¼ŒåŒä¸€ä¸ªå‚å•†ä¹Ÿå¯ä»¥ç”Ÿäº§ä¸åŒæŒ‡ä»¤é›†çš„CPUï¼Œå³ä¸åŒæ¶æ„çš„CPUä½¿ç”¨ä¸åŒçš„CPUæŒ‡ä»¤é›†ã€‚

**æ“ä½œç³»ç»Ÿå±‚**ï¼šæ“ä½œç³»ç»Ÿï¼Œä¸€æ–¹é¢ï¼Œå‘ä¸Šæä¾›äº†ç®€æ˜“çš„æ“ä½œç•Œé¢ï¼Œä½¿å¾—ç”¨æˆ·èƒ½å¤Ÿå®¹æ˜“åœ°æ“ä½œè®¡ç®—æœºï¼›åŒæ—¶ï¼Œå‘ä¸‹å¯¹æ¥äº†æŒ‡ä»¤ç³»ç»Ÿï¼Œç®¡ç†ç¡¬ä»¶èµ„æºã€‚æ“ä½œç³»ç»Ÿå¯¹ç”¨æˆ·ç¨‹åºæ‰€ä½¿ç”¨æœºå™¨çš„å„ç§èµ„æºè¿›è¡Œç®¡ç†å’Œåˆ†é…ï¼ŒåŒ…æ‹¬CPUã€å­˜å‚¨å™¨ç­‰ç­‰ï¼Œæ¯”å¦‚è¯´ï¼Œå½“ä¸€ä¸ªç”¨æˆ·ç¨‹åºéœ€è¦è¿è¡Œçš„æ—¶å€™ï¼Œé¦–å…ˆç”±æ“ä½œç³»ç»Ÿå°†å…¶åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œè¿™å°±éœ€è¦æ“ä½œç³»ç»Ÿé¦–å…ˆä¸ºå…¶åˆ†é…å†…å­˜ç©ºé—´æ¥è¿›è¡Œå­˜å‚¨ã€‚å†æ¯”å¦‚è¯´ï¼ŒæŸä¸€ä¸ªç¨‹åºéœ€è¦ä½¿ç”¨æŸä¸€ä¸ªè¾“å‡ºè®¾å¤‡è¿›è¡Œç»“æœè¾“å‡ºçš„æ—¶å€™ï¼Œéœ€è¦æ“ä½œç³»ç»Ÿä¸ºå…¶æä¾›è¯¥è®¾å¤‡çš„æ§åˆ¶æƒã€‚ç”±æ­¤å¯è§ï¼Œæ“ä½œç³»ç»Ÿæ˜¯åœ¨è½¯ä»¶å’Œç¡¬ä»¶ä¹‹é—´çš„é€‚é…å±‚ã€‚

**æ±‡ç¼–è¯­è¨€å±‚**ï¼šç¼–ç¨‹è¯­è¨€æ˜¯æ±‡ç¼–è¯­è¨€ï¼Œæ±‡ç¼–è¯­è¨€å¯ä»¥ç¿»è¯‘æˆå¯ç›´æ¥æ‰§è¡Œçš„æœºå™¨è¯­è¨€ï¼Œå®Œæˆè¿™ä¸ªç¿»è¯‘è¿‡ç¨‹çš„ç¨‹åºå°±æ˜¯æ±‡ç¼–å™¨ã€‚ä»è¿™ä¸€å±‚å¼€å§‹ï¼Œå®ƒä»¬æ‰€ä½¿ç”¨çš„ç¼–ç¨‹è¯­è¨€å°±æ˜¯äººç±»æ¯”è¾ƒå®¹æ˜“ç†è§£çš„è¯­è¨€äº†ã€‚

**é«˜çº§è¯­è¨€å±‚**ï¼šç¼–ç¨‹è¯­è¨€å°±æ˜¯ä¸ºå¹¿å¤§ç¨‹åºå‘˜æ‰€æ¥å—çš„é«˜çº§è¯­è¨€ï¼Œç§ç±»éå¸¸å¤šï¼Œæœ‰å‡ ç™¾ç§ï¼Œå¸¸è§çš„ç¼–ç¨‹è¯­è¨€æœ‰Pythonã€Javaã€C/C++ã€Golangç­‰ã€‚

**åº”ç”¨å±‚**ï¼šè®¡ç®—æœºé’ˆå¯¹æŸç§ç”¨é€”è€Œè®¾è®¡çš„åº”ç”¨ï¼ŒåƒWordã€Excelç­‰ã€‚