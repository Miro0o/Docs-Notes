# SAT (Boolean Satisfiability Problem) Solvers

[TOC]



## Res
### Related Topics
â†— [Mathematical Logic Basics (Formal Logic)](../../../../../../ðŸ§®%20Mathematics/ðŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ðŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Mathematical%20Logic%20Basics%20(Formal%20Logic).md)
â†— [Zeroth-Order Logic & Propositional Logic - (é›¶é˜¶) å‘½é¢˜é€»è¾‘](../../../../../../ðŸ§®%20Mathematics/ðŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ðŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Classical%20Logic%20(Standard%20Logic)/Zeroth-Order%20Logic%20&%20Propositional%20Logic%20-%20(é›¶é˜¶)%20å‘½é¢˜é€»è¾‘.md)
â†— [Boolean Algebra](../../../../../../ðŸ§®%20Mathematics/ðŸ§Š%20Algebra/ðŸŽƒ%20Algebraic%20Structure%20&%20Abstract%20Algebra%20&%20Modern%20Algebra/Lattice%20(Group%20Theory)%20&%20Lattice-Like%20Algebraic%20Structure/Boolean%20Algebra/Boolean%20Algebra.md)

â†— [Computability (Recursion) Theory - Turing Machine and R.E. Language](../../../../../../ðŸ§®%20Mathematics/ðŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ðŸ˜¶â€ðŸŒ«ï¸%20Theory%20of%20Computation/Computability%20(Recursion)%20Theory%20-%20Turing%20Machine%20and%20R.E.%20Language/Computability%20(Recursion)%20Theory%20-%20Turing%20Machine%20and%20R.E.%20Language.md)
â†— [Complexity Theory & Computational Complexity](../../../../../../ðŸ§®%20Mathematics/ðŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ðŸ˜¶â€ðŸŒ«ï¸%20Theory%20of%20Computation/Complexity%20Theory%20&%20Computational%20Complexity/Complexity%20Theory%20&%20Computational%20Complexity.md)

â†— [Symbolic Execution & Concolic Execution](../../../../../ðŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ðŸ¦%20Software%20Security/ðŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ðŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ðŸ‘™%20DCA%20(Dynamic%20Code%20Analysis)%20&%20DAST/Symbolic%20Execution%20&%20Concolic%20Execution/Symbolic%20Execution%20&%20Concolic%20Execution.md)



## Intro: SAT Problem
InÂ [logic](https://en.wikipedia.org/wiki/Logic "Logic")Â andÂ [computer science](https://en.wikipedia.org/wiki/Computer_science "Computer science"), theÂ **Boolean satisfiability problem**Â (sometimes calledÂ **propositional satisfiability problem**Â and abbreviatedÂ **SATISFIABILITY**,Â **SAT**Â orÂ **B-SAT**) asks whether there exists anÂ [interpretation](https://en.wikipedia.org/wiki/Interpretation_\(logic\) "Interpretation (logic)")Â thatÂ [satisfies](https://en.wikipedia.org/wiki/Satisfiability "Satisfiability")Â a givenÂ [Boolean](https://en.wikipedia.org/wiki/Boolean_logic "Boolean logic")Â [formula](https://en.wikipedia.org/wiki/Formula_\(mathematical_logic\) "Formula (mathematical logic)"). In other words, it asks whether the formula's variables can be consistently replaced by the values TRUE or FALSE to make the formula evaluate to TRUE. If this is the case, the formula is calledÂ _satisfiable_, elseÂ _unsatisfiable_. For example, the formula "_a_Â AND NOTÂ _b_" is satisfiable because one can find the valuesÂ _a_Â = TRUE andÂ _b_Â = FALSE, which make (_a_Â AND NOTÂ _b_) = TRUE. In contrast, "_a_Â AND NOTÂ _a_" is unsatisfiable.

SAT is the first problem that was proven to beÂ [NP-complete](https://en.wikipedia.org/wiki/NP-complete "NP-complete")â€”this is theÂ [Cookâ€“Levin theorem](https://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem "Cookâ€“Levin theorem"). This means that all problems in the complexity classÂ [NP](https://en.wikipedia.org/wiki/NP_\(complexity\) "NP (complexity)"), which includes a wide range of natural decision and optimization problems, are at most as difficult to solve as SAT. There is no known algorithm that efficiently solves each SAT problem (where "efficiently" means "deterministically inÂ [polynomial time](https://en.wikipedia.org/wiki/Time_complexity#Polynomial_time "Time complexity")"). Although such an algorithm is generally believed not to exist, this belief has not been proven or disproven mathematically. Resolving the question of whether SAT has aÂ [polynomial-time](https://en.wikipedia.org/wiki/Polynomial-time "Polynomial-time")Â algorithm would settle theÂ [P versus NP problem](https://en.wikipedia.org/wiki/P_versus_NP_problem "P versus NP problem")Â - one of the most important open problems in the theory of computing.

Nevertheless, as of 2007, heuristic SAT-algorithms are able to solve problem instances involving tens of thousands of variables and formulas consisting of millions of symbols,Â which is sufficient for many practical SAT problems occurring inÂ [artificial intelligence](https://en.wikipedia.org/wiki/Artificial_intelligence "Artificial intelligence"),Â [circuit design](https://en.wikipedia.org/wiki/Circuit_design "Circuit design"),Â andÂ [automatic theorem proving](https://en.wikipedia.org/wiki/Automatic_theorem_proving "Automatic theorem proving").


### Complexity of SAT Problem
SAT was the first problem known to beÂ [NP-complete](https://en.wikipedia.org/wiki/NP-complete "NP-complete"), as proved byÂ [Stephen Cook](https://en.wikipedia.org/wiki/Stephen_Cook "Stephen Cook")Â at theÂ [University of Toronto](https://en.wikipedia.org/wiki/University_of_Toronto "University of Toronto")Â in 1971Â and independently byÂ [Leonid Levin](https://en.wikipedia.org/wiki/Leonid_Levin "Leonid Levin")Â at theÂ [Russian Academy of Sciences](https://en.wikipedia.org/wiki/Russian_Academy_of_Sciences#The_Academy_of_Sciences_of_the_USSR "Russian Academy of Sciences")Â in 1973.Â Until that time, the concept of an NP-complete problem did not even exist. The proof shows how every decision problem in theÂ [complexity class](https://en.wikipedia.org/wiki/Complexity_class "Complexity class")Â [NP](https://en.wikipedia.org/wiki/NP_\(complexity\) "NP (complexity)")Â can beÂ [reduced](https://en.wikipedia.org/wiki/Reduction_\(complexity\) "Reduction (complexity)")Â to the SAT problem for CNFÂ formulas, sometimes calledÂ **CNFSAT**. A useful property of Cook's reduction is that it preserves the number of accepting answers. For example, deciding whether a givenÂ [graph](https://en.wikipedia.org/wiki/Graph_\(discrete_mathematics\) "Graph (discrete mathematics)")Â has aÂ [3-coloring](https://en.wikipedia.org/wiki/Graph_coloring#Vertex_coloring "Graph coloring")Â is another problem in NP; if a graph has 17 valid 3-colorings, then the SAT formula produced by the Cookâ€“Levin reduction will have 17 satisfying assignments.

NP-completeness only refers to the run-time of the worst case instances. Many of the instances that occur in practical applications can be solved much more quickly. SeeÂ [Â§Algorithms for solving SAT](https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#Algorithms_for_solving_SAT)Â below.
#### 3-Satisfiability (3SAT)
#### Special instances of 3SAT

#### Not 3SAT problems


### Extensions of SAT
> â†— [SMT (Satisfiability Modulo Theory) Solvers](../SMT%20(Satisfiability%20Modulo%20Theory)%20Solvers/SMT%20(Satisfiability%20Modulo%20Theory)%20Solvers.md)

An extension that has gained significant popularity since 2003 isÂ **[satisfiability modulo theories](https://en.wikipedia.org/wiki/Satisfiability_modulo_theories "Satisfiability modulo theories")**Â (**SMT**) that can enrich CNF formulas with linear constraints, arrays, all-different constraints,Â [uninterpreted functions](https://en.wikipedia.org/wiki/Uninterpreted_function "Uninterpreted function"),Â etc. Such extensions typically remain NP-complete, but very efficient solvers are now available that can handle many such kinds of constraints.

The satisfiability problem becomes more difficult if both "for all" ([âˆ€](https://en.wikipedia.org/wiki/%E2%88%80 "âˆ€")) and "there exists" ([âˆƒ](https://en.wikipedia.org/wiki/%E2%88%83 "âˆƒ"))Â [quantifiers](https://en.wikipedia.org/wiki/Quantifier_\(logic\) "Quantifier (logic)")Â are allowed to bind the Boolean variables. An example of such an expression would beÂ $âˆ€xÂ âˆ€yÂ âˆƒz \Â (xÂ âˆ¨Â yÂ âˆ¨Â z) âˆ§ (Â¬xÂ âˆ¨ Â¬yÂ âˆ¨ Â¬z)$; it is valid, since for all values ofÂ _x_Â andÂ _y_, an appropriate value ofÂ _z_Â can be found, viz.Â _z_=TRUE if bothÂ _x_Â andÂ _y_Â are FALSE, andÂ _z_=FALSE else. SAT itself (tacitly) uses only âˆƒ quantifiers. If only âˆ€ quantifiers are allowed instead, the so-calledÂ **[tautology](https://en.wikipedia.org/wiki/Tautology_\(logic\) "Tautology (logic)")Â problem**Â is obtained, which isÂ [co-NP-complete](https://en.wikipedia.org/wiki/Co-NP-complete "Co-NP-complete"). If any number of both quantifiers are allowed, the problem is called theÂ **[quantified Boolean formula problem](https://en.wikipedia.org/wiki/Quantified_Boolean_formula_problem "Quantified Boolean formula problem")**Â (**QBF**), which can be shown to beÂ [PSPACE-complete](https://en.wikipedia.org/wiki/PSPACE-complete "PSPACE-complete"). It is widely believed that PSPACE-complete problems are strictly harder than any problem in NP, although this has not yet been proved.

Ordinary SAT asks if there is at least one variable assignment that makes the formula true. A variety of variants deal with the number of such assignments:
- **MAJ-SAT**Â asks if at least half of all assignments make the formula TRUE. It is known to be complete forÂ [PP](https://en.wikipedia.org/wiki/PP_\(complexity\) "PP (complexity)"), a probabilistic class. Surprisingly,Â **MAJ-kSAT**Â is demonstrated to be in P for every finite integer k.
- **[#SAT](https://en.wikipedia.org/wiki/Sharp-SAT "Sharp-SAT")**, the problem of counting how many variable assignments satisfy a formula, is a counting problem, not a decision problem, and isÂ [#P-complete](https://en.wikipedia.org/wiki/Sharp-P-complete "Sharp-P-complete").
- **UNIQUE SAT**Â is the problem of determining whether a formula has exactly one assignment. It is complete forÂ [US](https://en.wikipedia.org/w/index.php?title=US_\(complexity\)&action=edit&redlink=1 "US (complexity) (page does not exist)"),Â theÂ [complexity class](https://en.wikipedia.org/wiki/Complexity_class "Complexity class")Â describing problems solvable by a non-deterministic polynomial timeÂ [Turing machine](https://en.wikipedia.org/wiki/Turing_machine "Turing machine")Â that accepts when there is exactly one nondeterministic accepting path and rejects otherwise.
- **UNAMBIGUOUS-SAT**Â is the name given to the satisfiability problem when the input formula isÂ [promised](https://en.wikipedia.org/wiki/Promise_problem "Promise problem")Â to have at most one satisfying assignment. The problem is also calledÂ **USAT**.Â A solving algorithm for UNAMBIGUOUS-SAT is allowed to exhibit any behavior, including endless looping, on a formula having several satisfying assignments. Although this problem seems easier, Valiant and Vazirani haveÂ [shown](https://en.wikipedia.org/wiki/Valiant%E2%80%93Vazirani_theorem "Valiantâ€“Vazirani theorem")Â that if there is a practical (i.e.Â [randomized polynomial-time](https://en.wikipedia.org/wiki/Bounded-error_probabilistic_polynomial "Bounded-error probabilistic polynomial")) algorithm to solve it, then all problems inÂ [NP](https://en.wikipedia.org/wiki/NP_\(complexity_class\) "NP (complexity class)")Â can be solved just as easily.
- **MAX-SAT**, theÂ [maximum satisfiability problem](https://en.wikipedia.org/wiki/Maximum_satisfiability_problem "Maximum satisfiability problem"), is anÂ [FNP](https://en.wikipedia.org/wiki/FNP_\(complexity\) "FNP (complexity)")Â generalization of SAT. It asks for the maximum number of clauses which can be satisfied by any assignment. It has efficientÂ [approximation algorithms](https://en.wikipedia.org/wiki/Approximation_algorithm "Approximation algorithm"), but is NP-hard to solve exactly. Worse still, it isÂ [APX](https://en.wikipedia.org/wiki/APX "APX")-complete, meaning there is noÂ [polynomial-time approximation scheme](https://en.wikipedia.org/wiki/Polynomial-time_approximation_scheme "Polynomial-time approximation scheme")Â (PTAS) for this problem unless P=NP.
- **WMSAT**Â is the problem of finding an assignment of minimum weight that satisfy a monotone Boolean formula (i.e. a formula without any negation). Weights of propositional variables are given in the input of the problem. The weight of an assignment is the sum of weights of true variables. That problem is NP-complete.

Other generalizations include satisfiability forÂ [first](https://en.wikipedia.org/wiki/First-order_predicate_calculus "First-order predicate calculus")- andÂ [second-order logic](https://en.wikipedia.org/wiki/Second-order_logic "Second-order logic"),Â [constraint satisfaction problems](https://en.wikipedia.org/wiki/Constraint_satisfaction_problem "Constraint satisfaction problem"),Â [0-1 integer programming](https://en.wikipedia.org/wiki/0-1_integer_programming "0-1 integer programming").



## SAT Solver
> ðŸ”— https://en.wikipedia.org/wiki/SAT_solver


### Algorithms For Solving SAT
> ðŸ”— https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#Algorithms_for_solving_SAT

Since the SAT problem is NP-complete, only algorithms with exponential worst-case complexity are known for it. In spite of this, efficient and scalable algorithms for SAT were developed during the 2000s and have contributed to dramatic advances in the ability to automatically solve problem instances involving tens of thousands of variables and millions of constraints (i.e. clauses).Â Examples of such problems inÂ [electronic design automation](https://en.wikipedia.org/wiki/Electronic_design_automation "Electronic design automation")Â (EDA) includeÂ [formal equivalence checking](https://en.wikipedia.org/wiki/Formal_equivalence_checking "Formal equivalence checking"),Â [model checking](https://en.wikipedia.org/wiki/Model_checking "Model checking"),Â [formal verification](https://en.wikipedia.org/wiki/Formal_verification "Formal verification")Â ofÂ [pipelined microprocessors](https://en.wikipedia.org/wiki/Microprocessor "Microprocessor"),Â [automatic test pattern generation](https://en.wikipedia.org/wiki/Automatic_test_pattern_generation "Automatic test pattern generation"),Â [routing](https://en.wikipedia.org/wiki/Routing_\(electronic_design_automation\) "Routing (electronic design automation)")Â ofÂ [FPGAs](https://en.wikipedia.org/wiki/FPGA "FPGA"),Â [planning](https://en.wikipedia.org/wiki/Automated_planning_and_scheduling "Automated planning and scheduling"), andÂ [scheduling problems](https://en.wikipedia.org/wiki/Scheduling_algorithm "Scheduling algorithm"), and so on. A SAT-solving engine is also considered to be an essential component in theÂ [electronic design automation](https://en.wikipedia.org/wiki/Electronic_design_automation "Electronic design automation")Â toolbox.

Major techniques used by modern SAT solvers include theÂ [Davisâ€“Putnamâ€“Logemannâ€“Loveland algorithm](https://en.wikipedia.org/wiki/Davis%E2%80%93Putnam%E2%80%93Logemann%E2%80%93Loveland_algorithm "Davisâ€“Putnamâ€“Logemannâ€“Loveland algorithm")Â (or DPLL),Â [conflict-driven clause learning](https://en.wikipedia.org/wiki/Conflict-driven_clause_learning "Conflict-driven clause learning")Â (CDCL), andÂ [stochastic](https://en.wikipedia.org/wiki/Stochastic "Stochastic")Â [local search](https://en.wikipedia.org/wiki/Local_search_\(constraint_satisfaction\) "Local search (constraint satisfaction)")Â algorithms such asÂ [WalkSAT](https://en.wikipedia.org/wiki/WalkSAT "WalkSAT"). Almost all SAT solvers include time-outs, so they will terminate in reasonable time even if they cannot find a solution. Different SAT solvers will find different instances easy or hard, and some excel at proving unsatisfiability, and others at finding solutions. Recent attempts have been made to learn an instance's satisfiability using deep learning techniques.

SAT solvers are developed and compared in SAT-solving contests.Â Modern SAT solvers are also having significant impact on the fields of software verification, constraint solving in artificial intelligence, andÂ [operations research](https://en.wikipedia.org/wiki/Operations_research "Operations research"), among others.

Theoretical algorithms with increasingly better worst-case runtime guarantees have been given in the last decades, including anÂ $O^{*}(1.0638^{L})$Â algorithm for clause sets of length (total literal count)Â $L$,Â anÂ $O^{*}(1.2226^{m})$Â algorithm for sets ofÂ m![{\displaystyle m}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0a07d98bb302f3856cbabc47b2b9016692e3f7bc)Â clauses,Â and anÂ $O^{*}(1.32793^{n})$Â algorithm for 3-SAT withÂ $n$Â variables.Â Here, the notation "$O^{*}(.)$" means "up to a polynomial factor", i.e.Â $O^{*}(f(n))=O(f(n)n^{O(1)})$. Earlier runtime guarantees are shown in the diagram.



## Ref
