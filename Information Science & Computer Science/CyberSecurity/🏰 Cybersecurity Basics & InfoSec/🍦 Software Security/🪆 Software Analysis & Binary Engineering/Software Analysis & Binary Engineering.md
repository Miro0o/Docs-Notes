# Software Analysis & Binary Engineering

[TOC]



## Res
### Related Topics
↗ [Theory of Computation](../../../../🧮%20Mathematics/🤼‍♀️%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/😶‍🌫️%20Theory%20of%20Computation/Theory%20of%20Computation.md)
↗ [First-Order Logic & Predicate Calculus -（一阶）谓词逻辑](../../../../🧮%20Mathematics/🤼‍♀️%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/📍%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Classical%20Logic%20(Standard%20Logic)/First-Order%20Logic%20&%20Predicate%20Calculus%20-（一阶）谓词逻辑.md)

↗ [Programming Language Theory (PLT)](../../../../🔑%20CS%20Core/👩‍💻%20Computer%20Languages%20&%20Programming%20Methodology/🐢%20Programming%20Language%20Theory%20(PLT)/Programming%20Language%20Theory%20(PLT).md)
↗ [Programming Language Processing & Program Execution](../../../../🔑%20CS%20Core/🛣️%20Programming%20Language%20Processing%20&%20Program%20Execution/Programming%20Language%20Processing%20&%20Program%20Execution.md)
- ↗ [Program Language Translation & Compilation Theory (Compile-time)](../../../../🔑%20CS%20Core/🛣️%20Programming%20Language%20Processing%20&%20Program%20Execution/🚮%20Program%20Language%20Translation%20&%20Compilation%20Theory%20(Compile-time)/Program%20Language%20Translation%20&%20Compilation%20Theory%20(Compile-time).md)

↗ [File Types & File Formats](../../../../🔑%20CS%20Core/👷🏾‍♂️%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/OS%20IO%20System/IO%20Generality%20(via%20Abstraction)/File%20&%20File%20System/File%20Types%20&%20File%20Formats.md)
- ↗ [Linux File Types & Formats](../../../../🔑%20CS%20Core/🥷🏼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Linux%20(Derived%20From%20UNIX%20Family)/🔩%20Linux%20Kernel/Linux%20IO%20&%20Files%20Management/🤔%20Linux%20File%20System/Linux%20File%20Types%20&%20Formats/Linux%20File%20Types%20&%20Formats.md)
	- ↗ [ELF (Executable and Linkable Format)](../../../../🔑%20CS%20Core/🥷🏼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Linux%20(Derived%20From%20UNIX%20Family)/🔩%20Linux%20Kernel/Linux%20IO%20&%20Files%20Management/🤔%20Linux%20File%20System/Linux%20File%20Types%20&%20Formats/ELF%20(Executable%20and%20Linkable%20Format)/ELF%20(Executable%20and%20Linkable%20Format).md)
- ↗ [Window File Types & Formats](../../../../🔑%20CS%20Core/🥷🏼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Microsoft%20Operating%20Systems/Windows/📌%20Windows%20NT%20(New%20Technology)%20Kernel/Windows%20IO%20&%20Files%20Management/Windows%20File%20System/Window%20File%20Types%20&%20Formats.md)
	- ↗ [Windows PE (Portable Executable) File](../../../../🔑%20CS%20Core/🥷🏼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Microsoft%20Operating%20Systems/Windows/📌%20Windows%20NT%20(New%20Technology)%20Kernel/Windows%20IO%20&%20Files%20Management/Windows%20File%20System/Windows%20PE%20(Portable%20Executable)%20File/Windows%20PE%20(Portable%20Executable)%20File.md)

↗ [Software Vulnerability & Weakness](../🐒%20Software%20Vulnerability%20&%20Weakness/Software%20Vulnerability%20&%20Weakness.md)
- ↗ [Vulnerability Discovery & Scanning（漏洞检测 & 扫描）](../🐒%20Software%20Vulnerability%20&%20Weakness/Vulnerability%20Mangement%20Sections/Vulnerability%20Discovery%20&%20Scanning（漏洞检测%20&%20扫描）.md)
- ↗ [Vulnerability Disclosure（漏洞挖掘）](../🐒%20Software%20Vulnerability%20&%20Weakness/Vulnerability%20Mangement%20Sections/Vulnerability%20Disclosure（漏洞挖掘）.md)
↗ [Techniques - Vulnerability Disclosure & Discovery](../🐒%20Software%20Vulnerability%20&%20Weakness/🏴‍☠️%20Techniques%20-%20Vulnerability%20Disclosure%20&%20Discovery/Techniques%20-%20Vulnerability%20Disclosure%20&%20Discovery.md)

↗ [Software Quality Assurance (SQA)](../../../../Software%20Engineering/🎭%20Software%20Quality%20Assurance%20(SQA)/Software%20Quality%20Assurance%20(SQA).md)
- ↗ [Software Testing](../../../../Software%20Engineering/🎭%20Software%20Quality%20Assurance%20(SQA)/🧪%20Software%20Testing/Software%20Testing.md)
- ↗ [Security Audit & Security Audit Trail](../../../⛈️%20Risk%20Management/🐺%20Risk%20Countermeasures%20&%20Security%20Control/Security%20Audit%20&%20Security%20Audit%20Trail/Security%20Audit%20&%20Security%20Audit%20Trail.md)
	- ↗ [Code Review](../../../⛈️%20Risk%20Management/🐺%20Risk%20Countermeasures%20&%20Security%20Control/Security%20Audit%20&%20Security%20Audit%20Trail/Code%20Review.md)
- ↗ [Formal Methods & Formal Verification (FV)](📌%20Software%20Analysis%20Basics/🙇‍♂️%20Formal%20Methods%20&%20Formal%20Verification%20(FV)/Formal%20Methods%20&%20Formal%20Verification%20(FV).md)

↗ [Operating System Security](../../../System%20Security/🧸%20Operating%20System%20Security/Operating%20System%20Security.md)
↗ [Operating System Kernel (Kernel Mode)](../../../../🔑%20CS%20Core/👷🏾‍♂️%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/😴%20Operating%20System%20Components%20&%20Runtime%20Libraries/Operating%20System%20Kernel%20(Kernel%20Mode).md)
↗ [Operating Systems & Kernels (Engineering Part)](../../../../🔑%20CS%20Core/🥷🏼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Operating%20Systems%20&%20Kernels%20(Engineering%20Part).md)
↗ [Operating System & OS Kernel (Theory Part)](../../../../🔑%20CS%20Core/👷🏾‍♂️%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part).md)

↗ [Software Runtime Security](../../../System%20Security/🏃%20Software%20Runtime%20Security/Software%20Runtime%20Security.md)
 - ↗ [Memory Security](../../../System%20Security/🏃%20Software%20Runtime%20Security/📝%20Memory%20Security/Memory%20Security.md)

↗ [Software Analysis Tools](../../../☠️%20Kill%20Chain%20&%20Security%20Tool%20Box/🔞%20Software%20Analysis%20Tools/Software%20Analysis%20Tools.md)
↗ [Static Code Analysis Tools (SCAT)](../../../☠️%20Kill%20Chain%20&%20Security%20Tool%20Box/🔞%20Software%20Analysis%20Tools/⛰️%20Static%20Code%20Analysis%20Tools%20(SCAT)/Static%20Code%20Analysis%20Tools%20(SCAT).md)
↗ [📌 Computer Profiling & System Visibility](../../../../🔑%20CS%20Core/🥷🏼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Linux%20(Derived%20From%20UNIX%20Family)/Linux%20Free%20Software%20&%20OSS%20(Open%20Source%20Software)/Host%20Management/📌%20Computer%20Profiling%20&%20System%20Visibility.md)

↗ [Program Debugging & Defensive Programming](../../../../🔑%20CS%20Core/👩‍💻%20Computer%20Languages%20&%20Programming%20Methodology/Program%20Debugging%20&%20Defensive%20Programming.md)

↗ [Reverse & Pwn](../../CTF%20&%20AWD/Reverse%20&%20Pwn/Reverse%20&%20Pwn.md)

↗ [LLM & Software Security and Analysis](../../../../Academics%20🎓%20(In%20CS)/🗒️%20My%20Academic%20Projects%20Workspace/LLM%20&%20Software%20Security%20and%20Analysis/LLM%20&%20Software%20Security%20and%20Analysis.md)


### Learning Resources
📂 https://www.scuctf.com/ctfwiki/pwn/
CTF PWN 入门 | SCU CTF WiKi

🏫 [Malicious Code Analysis](../../../../🗺%20CS%20Overview/💋%20Intro%20to%20Computer%20Science/👩🏼‍🏫%20Courses%20of%20Universities/CMU/Malicious%20Code%20Analysis/Malicious%20Code%20Analysis.md)
🏫 [软件分析](../../../../🗺%20CS%20Overview/💋%20Intro%20to%20Computer%20Science/👩🏼‍🏫%20Courses%20of%20Universities/NJU%20南京大学/软件分析/软件分析.md)


📚 https://firmianay.gitbook.io/ctf-all-in-one/ (CTF竞赛权威指南(Pwn篇))
🚧 https://github.com/firmianay/CTF-All-In-One/tree/master
 
📚 [二进制安全学习笔记](https://binhack.readthedocs.io/zh/latest/index.html)

📚 c++反汇编与逆向分析技术揭秘第二版 钱林松 张延清

👨‍💻 http://ifsec.blogspot.com/2018/02/so-you-want-to-work-in-security-and-for.html 
So you want to work in security? (and for some reason ended up here rather than reading other people’s posts on the topic).

[ctf-wiki](https://ctf-wiki.org/)：涵盖了大部分 ctf pwn 题的漏洞利用方法，而且配有题目讲解。强烈推荐。

[how2heap](https://github.com/shellphish/how2heap)：教你各个版本下的 glibc ptmalloc2 堆利用方法。

https://scubsrgroup.github.io/BinaryDatabase/
Binary related materials


### Sites & Blogs
🫂 https://iosre.com i睿论坛

🫂 https://down.52pojie.cn 爱盘 - 在线破解工具包

🫂 https://www.52pojie.cn 吾爱破解

🫂 https://bbs.kanxue.com 看雪学苑

http://uuzdaisuki.com/categories/
一些 网安 & CTF 合集


### Research Papers
#### Surveys 
Y. Shoshitaishvili et al., "SOK: (State of) The Art of War: Offensive Techniques in Binary Analysis," 2016 IEEE Symposium on Security and Privacy (SP), San Jose, CA, USA, 2016, pp. 138-157, doi: 10.1109/SP.2016.17. https://ieeexplore.ieee.org/document/7546500?denied=

In short, we make the following contributions:
1. We reproduce many existing approaches in offensive binary analysis, in a single, coherent framework, to provide an understanding of the relative effectiveness of current offensive binary analysis techniques.
2. We show the difficulties (and solutions to those difficulties) of combining diverse binary analysis techniques and applying them on a large scale.
3. We open source our framework, `angr`, for the use of future generations of research into the analysis of binary code.
#### Trendings


### Others
🚧 https://github.com/0th3rs-Security-Team/Binary-Security-Advanced-References
本仓库内容旨在收集二进制安全相关的精品阅读材料，供学习者深入参考学习所用

📔 https://github.com/gh0stkey/Binary-Learning
二进制安全相关的学习笔记

📔 https://n0a110w.github.io
Just a collection of notes, snippets and other goodies..



## Intro to Software Analysis: Program & Binary Analysis
> ↗ [Software Analysis Basics](📌%20Software%20Analysis%20Basics/Software%20Analysis%20Basics.md)

![](../../../../../../Assets/Pics/Screenshot%202025-09-06%20at%2000.52.22.png)
<small>【南京大学《软件分析》课程01（Introduction）】 <a>https://www.bilibili.com/video/BV1b7411K7P4</a></small>

> 🎬 [Math's Fundamental Flaw - Veritasium](https://www.youtube.com/watch?v=HeQX2HjkcNo)


### Program Analysis (and Its Automation)
> 🔗 https://en.wikipedia.org/wiki/Program_analysis

In computer science, program analysis is the process of analyzing the behavior of computer programs regarding a property such as correctness, robustness, safety and liveness. Program analysis focuses on two major areas: **program optimization** and **program correctness**. The first focuses on improving the program’s performance while reducing the resource usage while the latter focuses on ensuring that the program does what it is supposed to do.

Program analysis can be performed without executing the program (static program analysis), during runtime (dynamic program analysis) or in a combination of both.

![](../../../../../Assets/Pics/Screenshot%202025-04-14%20at%2020.08.51.png)


### Binary Analysis and Its Automation
> 🔗 https://wpcdn.web.wsu.edu/wp-vcea/uploads/sites/3267/2022/06/BinaryAnalysis101.pdf

Binary analysis is the act of evaluating an executable program (or set of related programs and libraries) to determine characteristics of that program, usually cybersecurity related. 
What are three broad categories of sources of binaries we may want to evaluate?
1. The binary is untrusted and may contain malware.
2. The binary is developed in-house and needs to be evaluated for security vulnerabilities.
3. The binary is obtained from third-party and does not contain malware, but will be incororpated into one of our systems and needs to be evaluated for security vulnerabilities.
#### Trade-offs and Challenges
> Y. Shoshitaishvili et al., "SOK: (State of) The Art of War: Offensive Techniques in Binary Analysis," 2016 IEEE Symposium on Security and Privacy (SP), San Jose, CA, USA, 2016, pp. 138-157, doi: 10.1109/SP.2016.17. https://ieeexplore.ieee.org/document/7546500?denied=

It is not hard to see why binary analysis is challenging: in a sense, asking “will it crash?” is analogous to asking “will it stop?”, and any such analysis quickly runs afoul of the halting problem [32]. Program analyses, and especially offensive binary analyses, tend to be guided by carefully balanced theoretical trade-offs to maintain feasibility. There are two main areas where such trade-offs must be made:
##### Replayability
Bugs are not all created equal. Depending on the trade-offs made by the system, bugs discovered by a given analysis might not be _replayable_. This boils down to the _scope_ that an analysis operates on. Some analyses execute the whole application, from the beginning, so they can reason about what _exactly_ needs to be done to trigger a vulnerability. Other systems analyze individual pieces of an application: they might find a bug in a specific module, but cannot reason about how to _trigger_ the execution of that module, and therefore, cannot automatically _replay_ the crash.
##### Semantic Insight
Some analyses lack the ability to reason about the program in semantically meaningful ways. For example, a dynamic analysis might be able to trace the code executed by an application but not understand _why_ it was executed or _what parts_ of the input caused the application to act in that specific way. On the other hand, a symbolic analysis that can determine the specific bytes of input responsible for certain program behaviors would have a higher semantic understanding.

In order to offer replayability of input or semantic insight, analysis techniques must make certain trade-offs. For example, high replayability is associated with low coverage. This is intuitive: since an analysis technique that produces replayable input must understand how to reach any code that it wants to analyze, it will be unable to analyze as much code as an analysis that does not. On the other hand, without being able to replay triggering inputs to validate bugs, analyses that do not prioritize bug replayability suffer from a high level of _false positives_ (that is, flaw detections that do not represent actual vulnerabilities). In the absence of a replayable input, these false positives must be filtered by heuristics which can, in turn, introduce false negatives.

Likewise, in order to achieve semantic insight into the program being analyzed, an analysis must store and process a large amount of data. A semantically-insightful dynamic analysis, for example, might store the conditions that must hold in order for specific branches of a program to be taken. On the other hand, a static analysis tunes semantic insight through the chosen data domain – simpler data domains (i.e., by tracking _ranges_ instead of actual values) represent less semantic insight.

Analyses that attempt both reproducibility and a high semantic understanding encounter issues with scalability. Retaining semantic information for the entire application, from the entry point through all of the actions it might take, requires a processing capacity conceptually identical to the resources required to execute the program under all possible conditions. Such analyses do not scale, and, in order to be applicable, must discard information and sacrifice _soundness_ (that is, the guarantee that all potential vulnerabilities will be discovered).

Aside from these fundamental challenges, there are also implementation challenges. The biggest one of these is the _environment model_. Any analysis with a high semantic understanding must model the application's interaction with its environment. In modern operating systems, such interactions are incredibly complex. For example, modern versions of Linux include over three hundred system calls, and for an analysis system to be complete, it must model the effects of all of them.
##### Example
To demonstrate the various challenges of binary analysis, we provide a concrete example of a program with multiple vulnerabilities in Listing 1. For clarity and space reasons, this example is simplified, and it is meant only to expose the reader to ideas that will be discussed later in the paper.

Observe the three calls to memcpy: the ones on lines 10 and 30 will result in buffer overflows, while the one on line 16 will not. However, depending on the amount of information tracked, a static analysis technique might report all three calls to memcpy as potential bugs, including the one on line 16, because it would not have the information to determine that no buffer overflow is possible. Additionally, while the report from a static analysis would include the locations of these bugs, it will not provide inputs to trigger them.

A dynamic technique, such as fuzzing, has the benefit of creating actionable inputs that will trigger any bugs found. On the other hand, simple fuzzing techniques typically only find shallow bugs and fail to pass through code requiring precisely crafted input. In Listing 1, dynamic techniques will have difficulty finding the bug at line 10, because it requires a specific input for the condition to be satisfied. However, because the overflow on line 30 can be triggered through random testing, fuzzing techniques should be able to find an input which triggers the bug.

To find the bug on line 10, one could introduce an abstract data model to reason about many possible inputs at once. One such approach is Dynamic Symbolic Execution (DSE). However, dynamic symbolic techniques, while powerful, suffer from the “path explosion problem”, where the number of paths grows exponentially with each branch and quickly becomes intractable. A symbolic execution will detect the bug on line 10 and generate an input for it using a constraint solver. Additionally, it should be able to prove that the memcpy on line 16 cannot overflow. However, the execution will likely not be able to find the bug at line 30, as there are too many potential paths which do not trigger the bug.



## Ref
[ctf re/pwn入门书单]: https://eternalsakura13.com/2018/05/31/shudan/
逆向
- c++反汇编技术解密
	- 介绍：这本是完整看完了的，后面关于对象和类写的不错。
- 使用OllyDbg从零开始Cracking(已完结）
	- 介绍：学习od使用的教程，动手实践上不错，翻译和配套资料在看雪可以搜到。
- 逆向工程权威指南

pwn（浏览器、内核什么的书就不安利了……太多了，只写一下学ctf pwn看过的书）
- 0day安全2
	- 介绍：我只看了前半本的内容，书有点老了，感觉看不看没影响。
- 深入理解计算机系统
	- 介绍：必读书，读了大概一个周，不求全懂，大概用到的地方都看过了，其他的用到再查了，其实内容也不是很深。
- 程序员的自我修养
	- 介绍: 必读的基础书，讲Linux上的程序装载链接什么的，很有意义。
- glibc内存管理ptmalloc源代码分析
	- 介绍：理解Linux堆管理的必读书
- 漏洞战争
	- 介绍：很好的书，里面的案例能调的都值得调一下。

[二进制安全学习之路]: https://xz.aliyun.com/t/12402

[👍 脱壳技术 ｜ 看雪学苑]: https://bbs.kanxue.com/thread-58798.htm

CTF高质量PWN题之二叉树的漏洞利用 - yjlabs的文章 - 知乎
https://zhuanlan.zhihu.com/p/434745218

[hahbiubiubiub]: https://hahbiubiubiu.github.io/MyBook/#/

[Instrumentation 与 Profiling | CSDN]: https://blog.csdn.net/fenng/article/details/81362183?fromshare=blogdetail&sharetype=blogdetail&sharerId=81362183&sharerefer=PC&sharesource=weixin_43336330&sharefrom=from_link

看到有反馈说到《Oracle性能诊断艺术》中对于 Instrumentation 这个词的翻译问题。说实话，对这个词的处理当初挺让我头疼，这是个可以意会但很难用一个中文词汇对应的术语，一些翻译词典或是已有的翻译作品对这个词的处理也是五花八门。在图灵著译俱乐部里面提问得到很多回答（这里要致谢！）。权衡再三，最后根据整个章节的重点以及上下文选择用 “性能测量”。

我不喜欢用有些人说的测试领域内所用的术语”插桩”，实在是有点诡异。当然，如果这个词不翻译的话，或许更好。

另一个比较难以处理的就是 “Profiling” ，根据维基百科的解释 ，这个词指”动态程序分析的一种形式…根据程序执行收集到的信息调查程序的运行行为，通常用来查找程序中的瓶颈”。最后我用了”剖析”。(Updated: 中文是 “性能分析“。不过我觉得似乎有点容易混淆。)

这两个词很有趣，任何一个程序或者软件项目构建的初期，如果没有考虑 Instrumentation ，在程序或项目交付后，又不能做 Profiling ，那么这个程序或者项目肯定会是灾难。所以，能对 DBA 着重强调一下这一点或许要比看更多的同质化内容更有价值。

[通过大语言模型（LLM）识别与修复风险代码 | 字节跳动无恒实验室]: https://www.anquanke.com/post/id/289615

![](../../../../../../../Assets/Pics/Pasted%20image%2020240324141945.png)

[大模型遇上恶意软件：开启自主威胁时代 | CSDN]: http://t.csdnimg.cn/oI0OY

[👍 大模型与模糊测试进行结合的研究论文汇总｜技术进展]: https://mp.weixin.qq.com/s/DL4pGH-7nPi3eSRD-rlD-w

在软件起到重要作用的现代，软件安全和漏洞分析已经成为软件开发的关键。模糊测试作为一种高效的软件测试方法，被广泛应用于各个领域。此外，大语言模型（LLM）的快速发展也促进了其在软件测试领域的应用，并展示出其卓越的性能。考虑到现有的模糊测试技术并非完全自动化，而且软件漏洞仍在不断演变，采用基于大语言模型生成的模糊测试已成为一种趋势。本调查报告系统地概述了将LLM和模糊测试结合到软件测试中的方法。本文从三个方面对文献进行了统计分析和讨论，包括LLMs、模糊测试和基于LLMs生成的模糊测试，总结了截至 2024 年的最新方法。我们的调查还研究了基于LLM 生成的模糊测试技术在未来广泛部署和应用的潜力。

[🤔 How Effective Are They? Exploring Large Language Model Based Fuzz Driver Generation]: https://ui.adsabs.harvard.edu/abs/2023arXiv230712469Z/abstract

[🤔 AutoDroid | Github]: https://github.com/MobileLLM/AutoDroid

Source code for the paper "Empowering LLM to use Smartphone for Intelligent Task Automation"
[arxiv.org/abs/2308.15272](https://arxiv.org/abs/2308.15272 "https://arxiv.org/abs/2308.15272")

[👍 白泽SAST团队：将LLM织入SAST程序分析流程的实践]: https://mp.weixin.qq.com/s/xUpFyx8pfY8SezE8JGLFmQ

[LLM-Enhanced Static Anlysis for Pracise Identification of Vulnerable OSS Version]: https://arxiv.org/pdf/2408.07321
[AutoSafeCoder: A Multi-Agent Framework for Securing LLM Code Generation through Static Analysis and Fuzz Testing]: https://arxiv.org/abs/2409.10737
