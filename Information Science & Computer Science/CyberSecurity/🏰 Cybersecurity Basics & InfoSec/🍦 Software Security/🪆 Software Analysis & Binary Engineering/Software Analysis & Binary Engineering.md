# Software Analysis & Binary Engineering

[TOC]



## Res
### Related Topics
â†— [Theory of Computation](../../../../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/Theory%20of%20Computation.md)
â†— [First-Order Logic & Predicate Calculus -ï¼ˆä¸€é˜¶ï¼‰è°“è¯é€»è¾‘](../../../../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Classical%20Logic%20(Standard%20Logic)/First-Order%20Logic%20&%20Predicate%20Calculus%20-ï¼ˆä¸€é˜¶ï¼‰è°“è¯é€»è¾‘.md)

â†— [Programming Language Theory (PLT)](../../../../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Programming%20Language%20Theory%20(PLT).md)
â†— [Programming Language Processing & Program Execution](../../../../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/Programming%20Language%20Processing%20&%20Program%20Execution.md)
- â†— [Program Language Translation & Compilation Theory (Compile-time)](../../../../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸš®%20Program%20Language%20Translation%20&%20Compilation%20Theory%20(Compile-time)/Program%20Language%20Translation%20&%20Compilation%20Theory%20(Compile-time).md)

â†— [File Types & File Formats](../../../../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/OS%20IO%20System/IO%20Generality%20(via%20Abstraction)/File%20&%20File%20System/File%20Types%20&%20File%20Formats.md)
- â†— [Linux File Types & Formats](../../../../ğŸ”‘%20CS%20Core/ğŸ¥·ğŸ¼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Linux%20(Derived%20From%20UNIX%20Family)/ğŸ”©%20Linux%20Kernel/Linux%20IO%20&%20Files%20Management/ğŸ¤”%20Linux%20File%20System/Linux%20File%20Types%20&%20Formats/Linux%20File%20Types%20&%20Formats.md)
	- â†— [ELF (Executable and Linkable Format)](../../../../ğŸ”‘%20CS%20Core/ğŸ¥·ğŸ¼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Linux%20(Derived%20From%20UNIX%20Family)/ğŸ”©%20Linux%20Kernel/Linux%20IO%20&%20Files%20Management/ğŸ¤”%20Linux%20File%20System/Linux%20File%20Types%20&%20Formats/ELF%20(Executable%20and%20Linkable%20Format)/ELF%20(Executable%20and%20Linkable%20Format).md)
- â†— [Window File Types & Formats](../../../../ğŸ”‘%20CS%20Core/ğŸ¥·ğŸ¼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Microsoft%20Operating%20Systems/Windows/ğŸ“Œ%20Windows%20NT%20(New%20Technology)%20Kernel/Windows%20IO%20&%20Files%20Management/Windows%20File%20System/Window%20File%20Types%20&%20Formats.md)
	- â†— [Windows PE (Portable Executable) File](../../../../ğŸ”‘%20CS%20Core/ğŸ¥·ğŸ¼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Microsoft%20Operating%20Systems/Windows/ğŸ“Œ%20Windows%20NT%20(New%20Technology)%20Kernel/Windows%20IO%20&%20Files%20Management/Windows%20File%20System/Windows%20PE%20(Portable%20Executable)%20File/Windows%20PE%20(Portable%20Executable)%20File.md)

â†— [Software Vulnerability & Weakness](../ğŸ’%20Software%20Vulnerability%20&%20Weakness/Software%20Vulnerability%20&%20Weakness.md)
- â†— [Vulnerability Discovery & Scanningï¼ˆæ¼æ´æ£€æµ‹ & æ‰«æï¼‰](../ğŸ’%20Software%20Vulnerability%20&%20Weakness/Vulnerability%20Mangement%20Sections/Vulnerability%20Discovery%20&%20Scanningï¼ˆæ¼æ´æ£€æµ‹%20&%20æ‰«æï¼‰.md)
- â†— [Vulnerability Disclosureï¼ˆæ¼æ´æŒ–æ˜ï¼‰](../ğŸ’%20Software%20Vulnerability%20&%20Weakness/Vulnerability%20Mangement%20Sections/Vulnerability%20Disclosureï¼ˆæ¼æ´æŒ–æ˜ï¼‰.md)
â†— [Techniques - Vulnerability Disclosure & Discovery](../ğŸ’%20Software%20Vulnerability%20&%20Weakness/ğŸ´â€â˜ ï¸%20Techniques%20-%20Vulnerability%20Disclosure%20&%20Discovery/Techniques%20-%20Vulnerability%20Disclosure%20&%20Discovery.md)

â†— [Software Quality Assurance (SQA)](../../../../Software%20Engineering/ğŸ­%20Software%20Quality%20Assurance%20(SQA)/Software%20Quality%20Assurance%20(SQA).md)
- â†— [Software Testing](../../../../Software%20Engineering/ğŸ­%20Software%20Quality%20Assurance%20(SQA)/ğŸ§ª%20Software%20Testing/Software%20Testing.md)
- â†— [Security Audit & Security Audit Trail](../../../â›ˆï¸%20Risk%20Management/ğŸº%20Risk%20Countermeasures%20&%20Security%20Control/Security%20Audit%20&%20Security%20Audit%20Trail/Security%20Audit%20&%20Security%20Audit%20Trail.md)
	- â†— [Code Review](../../../â›ˆï¸%20Risk%20Management/ğŸº%20Risk%20Countermeasures%20&%20Security%20Control/Security%20Audit%20&%20Security%20Audit%20Trail/Code%20Review.md)
- â†— [Formal Methods & Formal Verification (FV)](ğŸ“Œ%20Software%20Analysis%20Basics/ğŸ™‡â€â™‚ï¸%20Formal%20Methods%20&%20Formal%20Verification%20(FV)/Formal%20Methods%20&%20Formal%20Verification%20(FV).md)

â†— [Operating System Security](../../../System%20Security/ğŸ§¸%20Operating%20System%20Security/Operating%20System%20Security.md)
â†— [Operating System Kernel (Kernel Mode)](../../../../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/ğŸ˜´%20Operating%20System%20Components%20&%20Runtime%20Libraries/Operating%20System%20Kernel%20(Kernel%20Mode).md)
â†— [Operating Systems & Kernels (Engineering Part)](../../../../ğŸ”‘%20CS%20Core/ğŸ¥·ğŸ¼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Operating%20Systems%20&%20Kernels%20(Engineering%20Part).md)
â†— [Operating System & OS Kernel (Theory Part)](../../../../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part).md)

â†— [Software Runtime Security](../../../System%20Security/ğŸƒ%20Software%20Runtime%20Security/Software%20Runtime%20Security.md)
 - â†— [Memory Security](../../../System%20Security/ğŸƒ%20Software%20Runtime%20Security/ğŸ“%20Memory%20Security/Memory%20Security.md)

â†— [Software Analysis Tools](../../../â˜ ï¸%20Kill%20Chain%20&%20Security%20Tool%20Box/ğŸ”%20Software%20Analysis%20Tools/Software%20Analysis%20Tools.md)
â†— [Static Code Analysis Tools (SCAT)](../../../â˜ ï¸%20Kill%20Chain%20&%20Security%20Tool%20Box/ğŸ”%20Software%20Analysis%20Tools/â›°ï¸%20Static%20Code%20Analysis%20Tools%20(SCAT)/Static%20Code%20Analysis%20Tools%20(SCAT).md)
â†— [ğŸ“Œ Computer Profiling & System Visibility](../../../../ğŸ”‘%20CS%20Core/ğŸ¥·ğŸ¼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Linux%20(Derived%20From%20UNIX%20Family)/Linux%20Free%20Software%20&%20OSS%20(Open%20Source%20Software)/Host%20Management/ğŸ“Œ%20Computer%20Profiling%20&%20System%20Visibility.md)

â†— [Program Debugging & Defensive Programming](../../../../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/Program%20Debugging%20&%20Defensive%20Programming.md)

â†— [Reverse & Pwn](../../CTF%20&%20AWD/Reverse%20&%20Pwn/Reverse%20&%20Pwn.md)

â†— [LLM & Software Security and Analysis](../../../../Academics%20ğŸ“%20(In%20CS)/ğŸ—’ï¸%20My%20Academic%20Projects%20Workspace/LLM%20&%20Software%20Security%20and%20Analysis/LLM%20&%20Software%20Security%20and%20Analysis.md)


### Learning Resources
ğŸ“‚ https://www.scuctf.com/ctfwiki/pwn/
CTF PWN å…¥é—¨ | SCU CTF WiKi

ğŸ« [Malicious Code Analysis](../../../../ğŸ—º%20CS%20Overview/ğŸ’‹%20Intro%20to%20Computer%20Science/ğŸ‘©ğŸ¼â€ğŸ«%20Courses%20of%20Universities/CMU/Malicious%20Code%20Analysis/Malicious%20Code%20Analysis.md)
ğŸ« [è½¯ä»¶åˆ†æ](../../../../ğŸ—º%20CS%20Overview/ğŸ’‹%20Intro%20to%20Computer%20Science/ğŸ‘©ğŸ¼â€ğŸ«%20Courses%20of%20Universities/NJU%20å—äº¬å¤§å­¦/è½¯ä»¶åˆ†æ/è½¯ä»¶åˆ†æ.md)


ğŸ“š https://firmianay.gitbook.io/ctf-all-in-one/ (CTFç«èµ›æƒå¨æŒ‡å—(Pwnç¯‡))
ğŸš§ https://github.com/firmianay/CTF-All-In-One/tree/master
 
ğŸ“š [äºŒè¿›åˆ¶å®‰å…¨å­¦ä¹ ç¬”è®°](https://binhack.readthedocs.io/zh/latest/index.html)

ğŸ“š c++åæ±‡ç¼–ä¸é€†å‘åˆ†ææŠ€æœ¯æ­ç§˜ç¬¬äºŒç‰ˆ é’±æ—æ¾ å¼ å»¶æ¸…

ğŸ‘¨â€ğŸ’» http://ifsec.blogspot.com/2018/02/so-you-want-to-work-in-security-and-for.html 
So you want to work in security? (and for some reason ended up here rather than reading other peopleâ€™s posts on the topic).

[ctf-wiki](https://ctf-wiki.org/)ï¼šæ¶µç›–äº†å¤§éƒ¨åˆ† ctf pwn é¢˜çš„æ¼æ´åˆ©ç”¨æ–¹æ³•ï¼Œè€Œä¸”é…æœ‰é¢˜ç›®è®²è§£ã€‚å¼ºçƒˆæ¨èã€‚

[how2heap](https://github.com/shellphish/how2heap)ï¼šæ•™ä½ å„ä¸ªç‰ˆæœ¬ä¸‹çš„ glibc ptmalloc2 å †åˆ©ç”¨æ–¹æ³•ã€‚

https://scubsrgroup.github.io/BinaryDatabase/
Binary related materials


### Sites & Blogs
ğŸ«‚ https://iosre.com iç¿è®ºå›

ğŸ«‚ https://down.52pojie.cn çˆ±ç›˜ - åœ¨çº¿ç ´è§£å·¥å…·åŒ…

ğŸ«‚ https://www.52pojie.cn å¾çˆ±ç ´è§£

ğŸ«‚ https://bbs.kanxue.com çœ‹é›ªå­¦è‹‘

http://uuzdaisuki.com/categories/
ä¸€äº› ç½‘å®‰ & CTF åˆé›†


### Research Papers
#### Surveys 
Y. Shoshitaishvili et al., "SOK: (State of) The Art of War: Offensive Techniques in Binary Analysis," 2016 IEEE Symposium on Security and Privacy (SP), San Jose, CA, USA, 2016, pp. 138-157, doi: 10.1109/SP.2016.17. https://ieeexplore.ieee.org/document/7546500?denied=

In short, we make the following contributions:
1. We reproduce many existing approaches in offensive binary analysis, in a single, coherent framework, to provide an understanding of the relative effectiveness of current offensive binary analysis techniques.
2. We show the difficulties (and solutions to those difficulties) of combining diverse binary analysis techniques and applying them on a large scale.
3. We open source our framework,Â `angr`, for the use of future generations of research into the analysis of binary code.
#### Trendings


### Others
ğŸš§ https://github.com/0th3rs-Security-Team/Binary-Security-Advanced-References
æœ¬ä»“åº“å†…å®¹æ—¨åœ¨æ”¶é›†äºŒè¿›åˆ¶å®‰å…¨ç›¸å…³çš„ç²¾å“é˜…è¯»ææ–™ï¼Œä¾›å­¦ä¹ è€…æ·±å…¥å‚è€ƒå­¦ä¹ æ‰€ç”¨

ğŸ“” https://github.com/gh0stkey/Binary-Learning
äºŒè¿›åˆ¶å®‰å…¨ç›¸å…³çš„å­¦ä¹ ç¬”è®°

ğŸ“” https://n0a110w.github.io
Just a collection of notes, snippets and other goodies..



## Intro to Software Analysis: Program & Binary Analysis
> â†— [Software Analysis Basics](ğŸ“Œ%20Software%20Analysis%20Basics/Software%20Analysis%20Basics.md)

![](../../../../../../Assets/Pics/Screenshot%202025-09-06%20at%2000.52.22.png)
<small>ã€å—äº¬å¤§å­¦ã€Šè½¯ä»¶åˆ†æã€‹è¯¾ç¨‹01ï¼ˆIntroductionï¼‰ã€‘ <a>https://www.bilibili.com/video/BV1b7411K7P4</a></small>

> ğŸ¬ [Math's Fundamental Flaw - Veritasium](https://www.youtube.com/watch?v=HeQX2HjkcNo)


### Program Analysis (and Its Automation)
> ğŸ”— https://en.wikipedia.org/wiki/Program_analysis

In computer science, program analysis is the process of analyzing the behavior of computer programs regarding a property such as correctness, robustness, safety and liveness. Program analysis focuses on two major areas: **program optimization** and **program correctness**. The first focuses on improving the programâ€™s performance while reducing the resource usage while the latter focuses on ensuring that the program does what it is supposed to do.

Program analysis can be performed without executing the program (static program analysis), during runtime (dynamic program analysis) or in a combination of both.

![](../../../../../Assets/Pics/Screenshot%202025-04-14%20at%2020.08.51.png)


### Binary Analysis and Its Automation
> ğŸ”— https://wpcdn.web.wsu.edu/wp-vcea/uploads/sites/3267/2022/06/BinaryAnalysis101.pdf

Binary analysis is the act of evaluating an executable program (or set of related programs and libraries) to determine characteristics of that program, usually cybersecurity related. 
What are three broad categories of sources of binaries we may want to evaluate?
1. The binary is untrusted and may contain malware.
2. The binary is developed in-house and needs to be evaluated for security vulnerabilities.
3. The binary is obtained from third-party and does not contain malware, but will be incororpated into one of our systems and needs to be evaluated for security vulnerabilities.
#### Trade-offs and Challenges
> Y. Shoshitaishvili et al., "SOK: (State of) The Art of War: Offensive Techniques in Binary Analysis," 2016 IEEE Symposium on Security and Privacy (SP), San Jose, CA, USA, 2016, pp. 138-157, doi: 10.1109/SP.2016.17. https://ieeexplore.ieee.org/document/7546500?denied=

It is not hard to see why binary analysis is challenging: in a sense, asking â€œwill it crash?â€ is analogous to asking â€œwill it stop?â€, and any such analysis quickly runs afoul of the halting problemÂ [32]. Program analyses, and especially offensive binary analyses, tend to be guided by carefully balanced theoretical trade-offs to maintain feasibility. There are two main areas where such trade-offs must be made:
##### Replayability
Bugs are not all created equal. Depending on the trade-offs made by the system, bugs discovered by a given analysis might not beÂ _replayable_. This boils down to theÂ _scope_Â that an analysis operates on. Some analyses execute the whole application, from the beginning, so they can reason about whatÂ _exactly_Â needs to be done to trigger a vulnerability. Other systems analyze individual pieces of an application: they might find a bug in a specific module, but cannot reason about how toÂ _trigger_Â the execution of that module, and therefore, cannot automaticallyÂ _replay_Â the crash.
##### Semantic Insight
Some analyses lack the ability to reason about the program in semantically meaningful ways. For example, a dynamic analysis might be able to trace the code executed by an application but not understandÂ _why_Â it was executed orÂ _what parts_Â of the input caused the application to act in that specific way. On the other hand, a symbolic analysis that can determine the specific bytes of input responsible for certain program behaviors would have a higher semantic understanding.

In order to offer replayability of input or semantic insight, analysis techniques must make certain trade-offs. For example, high replayability is associated with low coverage. This is intuitive: since an analysis technique that produces replayable input must understand how to reach any code that it wants to analyze, it will be unable to analyze as much code as an analysis that does not. On the other hand, without being able to replay triggering inputs to validate bugs, analyses that do not prioritize bug replayability suffer from a high level ofÂ _false positives_Â (that is, flaw detections that do not represent actual vulnerabilities). In the absence of a replayable input, these false positives must be filtered by heuristics which can, in turn, introduce false negatives.

Likewise, in order to achieve semantic insight into the program being analyzed, an analysis must store and process a large amount of data. A semantically-insightful dynamic analysis, for example, might store the conditions that must hold in order for specific branches of a program to be taken. On the other hand, a static analysis tunes semantic insight through the chosen data domain â€“ simpler data domains (i.e., by trackingÂ _ranges_Â instead of actual values) represent less semantic insight.

Analyses that attempt both reproducibility and a high semantic understanding encounter issues with scalability. Retaining semantic information for the entire application, from the entry point through all of the actions it might take, requires a processing capacity conceptually identical to the resources required to execute the program under all possible conditions. Such analyses do not scale, and, in order to be applicable, must discard information and sacrificeÂ _soundness_Â (that is, the guarantee that all potential vulnerabilities will be discovered).

Aside from these fundamental challenges, there are also implementation challenges. The biggest one of these is theÂ _environment model_. Any analysis with a high semantic understanding must model the application's interaction with its environment. In modern operating systems, such interactions are incredibly complex. For example, modern versions of Linux include over three hundred system calls, and for an analysis system to be complete, it must model the effects of all of them.
##### Example
To demonstrate the various challenges of binary analysis, we provide a concrete example of a program with multiple vulnerabilities in Listing 1. For clarity and space reasons, this example is simplified, and it is meant only to expose the reader to ideas that will be discussed later in the paper.

Observe the three calls toÂ memcpy: the ones on lines 10 and 30 will result in buffer overflows, while the one on line 16 will not. However, depending on the amount of information tracked, a static analysis technique might report all three calls toÂ memcpyÂ as potential bugs, including the one on line 16, because it would not have the information to determine that no buffer overflow is possible. Additionally, while the report from a static analysis would include the locations of these bugs, it will not provide inputs to trigger them.

A dynamic technique, such as fuzzing, has the benefit of creating actionable inputs that will trigger any bugs found. On the other hand, simple fuzzing techniques typically only find shallow bugs and fail to pass through code requiring precisely crafted input. In Listing 1, dynamic techniques will have difficulty finding the bug at line 10, because it requires a specific input for the condition to be satisfied. However, because the overflow on line 30 can be triggered through random testing, fuzzing techniques should be able to find an input which triggers the bug.

To find the bug on line 10, one could introduce an abstract data model to reason about many possible inputs at once. One such approach is Dynamic Symbolic Execution (DSE). However, dynamic symbolic techniques, while powerful, suffer from the â€œpath explosion problemâ€, where the number of paths grows exponentially with each branch and quickly becomes intractable. A symbolic execution will detect the bug on line 10 and generate an input for it using a constraint solver. Additionally, it should be able to prove that theÂ memcpyÂ on line 16 cannot overflow. However, the execution will likely not be able to find the bug at line 30, as there are too many potential paths which do not trigger the bug.



## Ref
[ctf re/pwnå…¥é—¨ä¹¦å•]: https://eternalsakura13.com/2018/05/31/shudan/
é€†å‘
- c++åæ±‡ç¼–æŠ€æœ¯è§£å¯†
	- ä»‹ç»ï¼šè¿™æœ¬æ˜¯å®Œæ•´çœ‹å®Œäº†çš„ï¼Œåé¢å…³äºå¯¹è±¡å’Œç±»å†™çš„ä¸é”™ã€‚
- ä½¿ç”¨OllyDbgä»é›¶å¼€å§‹Cracking(å·²å®Œç»“ï¼‰
	- ä»‹ç»ï¼šå­¦ä¹ odä½¿ç”¨çš„æ•™ç¨‹ï¼ŒåŠ¨æ‰‹å®è·µä¸Šä¸é”™ï¼Œç¿»è¯‘å’Œé…å¥—èµ„æ–™åœ¨çœ‹é›ªå¯ä»¥æœåˆ°ã€‚
- é€†å‘å·¥ç¨‹æƒå¨æŒ‡å—

pwnï¼ˆæµè§ˆå™¨ã€å†…æ ¸ä»€ä¹ˆçš„ä¹¦å°±ä¸å®‰åˆ©äº†â€¦â€¦å¤ªå¤šäº†ï¼Œåªå†™ä¸€ä¸‹å­¦ctf pwnçœ‹è¿‡çš„ä¹¦ï¼‰
- 0dayå®‰å…¨2
	- ä»‹ç»ï¼šæˆ‘åªçœ‹äº†å‰åŠæœ¬çš„å†…å®¹ï¼Œä¹¦æœ‰ç‚¹è€äº†ï¼Œæ„Ÿè§‰çœ‹ä¸çœ‹æ²¡å½±å“ã€‚
- æ·±å…¥ç†è§£è®¡ç®—æœºç³»ç»Ÿ
	- ä»‹ç»ï¼šå¿…è¯»ä¹¦ï¼Œè¯»äº†å¤§æ¦‚ä¸€ä¸ªå‘¨ï¼Œä¸æ±‚å…¨æ‡‚ï¼Œå¤§æ¦‚ç”¨åˆ°çš„åœ°æ–¹éƒ½çœ‹è¿‡äº†ï¼Œå…¶ä»–çš„ç”¨åˆ°å†æŸ¥äº†ï¼Œå…¶å®å†…å®¹ä¹Ÿä¸æ˜¯å¾ˆæ·±ã€‚
- ç¨‹åºå‘˜çš„è‡ªæˆ‘ä¿®å…»
	- ä»‹ç»: å¿…è¯»çš„åŸºç¡€ä¹¦ï¼Œè®²Linuxä¸Šçš„ç¨‹åºè£…è½½é“¾æ¥ä»€ä¹ˆçš„ï¼Œå¾ˆæœ‰æ„ä¹‰ã€‚
- glibcå†…å­˜ç®¡ç†ptmallocæºä»£ç åˆ†æ
	- ä»‹ç»ï¼šç†è§£Linuxå †ç®¡ç†çš„å¿…è¯»ä¹¦
- æ¼æ´æˆ˜äº‰
	- ä»‹ç»ï¼šå¾ˆå¥½çš„ä¹¦ï¼Œé‡Œé¢çš„æ¡ˆä¾‹èƒ½è°ƒçš„éƒ½å€¼å¾—è°ƒä¸€ä¸‹ã€‚

[äºŒè¿›åˆ¶å®‰å…¨å­¦ä¹ ä¹‹è·¯]: https://xz.aliyun.com/t/12402

[ğŸ‘ è„±å£³æŠ€æœ¯ ï½œ çœ‹é›ªå­¦è‹‘]: https://bbs.kanxue.com/thread-58798.htm

CTFé«˜è´¨é‡PWNé¢˜ä¹‹äºŒå‰æ ‘çš„æ¼æ´åˆ©ç”¨ - yjlabsçš„æ–‡ç«  - çŸ¥ä¹
https://zhuanlan.zhihu.com/p/434745218

[hahbiubiubiub]: https://hahbiubiubiu.github.io/MyBook/#/

[Instrumentation ä¸ Profiling | CSDN]: https://blog.csdn.net/fenng/article/details/81362183?fromshare=blogdetail&sharetype=blogdetail&sharerId=81362183&sharerefer=PC&sharesource=weixin_43336330&sharefrom=from_link

çœ‹åˆ°æœ‰åé¦ˆè¯´åˆ°ã€ŠOracleæ€§èƒ½è¯Šæ–­è‰ºæœ¯ã€‹ä¸­å¯¹äº Instrumentation è¿™ä¸ªè¯çš„ç¿»è¯‘é—®é¢˜ã€‚è¯´å®è¯ï¼Œå¯¹è¿™ä¸ªè¯çš„å¤„ç†å½“åˆæŒºè®©æˆ‘å¤´ç–¼ï¼Œè¿™æ˜¯ä¸ªå¯ä»¥æ„ä¼šä½†å¾ˆéš¾ç”¨ä¸€ä¸ªä¸­æ–‡è¯æ±‡å¯¹åº”çš„æœ¯è¯­ï¼Œä¸€äº›ç¿»è¯‘è¯å…¸æˆ–æ˜¯å·²æœ‰çš„ç¿»è¯‘ä½œå“å¯¹è¿™ä¸ªè¯çš„å¤„ç†ä¹Ÿæ˜¯äº”èŠ±å…«é—¨ã€‚åœ¨å›¾çµè‘—è¯‘ä¿±ä¹éƒ¨é‡Œé¢æé—®å¾—åˆ°å¾ˆå¤šå›ç­”ï¼ˆè¿™é‡Œè¦è‡´è°¢ï¼ï¼‰ã€‚æƒè¡¡å†ä¸‰ï¼Œæœ€åæ ¹æ®æ•´ä¸ªç« èŠ‚çš„é‡ç‚¹ä»¥åŠä¸Šä¸‹æ–‡é€‰æ‹©ç”¨ â€œæ€§èƒ½æµ‹é‡â€ã€‚

æˆ‘ä¸å–œæ¬¢ç”¨æœ‰äº›äººè¯´çš„æµ‹è¯•é¢†åŸŸå†…æ‰€ç”¨çš„æœ¯è¯­â€æ’æ¡©â€ï¼Œå®åœ¨æ˜¯æœ‰ç‚¹è¯¡å¼‚ã€‚å½“ç„¶ï¼Œå¦‚æœè¿™ä¸ªè¯ä¸ç¿»è¯‘çš„è¯ï¼Œæˆ–è®¸æ›´å¥½ã€‚

å¦ä¸€ä¸ªæ¯”è¾ƒéš¾ä»¥å¤„ç†çš„å°±æ˜¯ â€œProfilingâ€ ï¼Œæ ¹æ®ç»´åŸºç™¾ç§‘çš„è§£é‡Š ï¼Œè¿™ä¸ªè¯æŒ‡â€åŠ¨æ€ç¨‹åºåˆ†æçš„ä¸€ç§å½¢å¼â€¦æ ¹æ®ç¨‹åºæ‰§è¡Œæ”¶é›†åˆ°çš„ä¿¡æ¯è°ƒæŸ¥ç¨‹åºçš„è¿è¡Œè¡Œä¸ºï¼Œé€šå¸¸ç”¨æ¥æŸ¥æ‰¾ç¨‹åºä¸­çš„ç“¶é¢ˆâ€ã€‚æœ€åæˆ‘ç”¨äº†â€å‰–æâ€ã€‚(Updated: ä¸­æ–‡æ˜¯ â€œæ€§èƒ½åˆ†æâ€œã€‚ä¸è¿‡æˆ‘è§‰å¾—ä¼¼ä¹æœ‰ç‚¹å®¹æ˜“æ··æ·†ã€‚)

è¿™ä¸¤ä¸ªè¯å¾ˆæœ‰è¶£ï¼Œä»»ä½•ä¸€ä¸ªç¨‹åºæˆ–è€…è½¯ä»¶é¡¹ç›®æ„å»ºçš„åˆæœŸï¼Œå¦‚æœæ²¡æœ‰è€ƒè™‘ Instrumentation ï¼Œåœ¨ç¨‹åºæˆ–é¡¹ç›®äº¤ä»˜åï¼Œåˆä¸èƒ½åš Profiling ï¼Œé‚£ä¹ˆè¿™ä¸ªç¨‹åºæˆ–è€…é¡¹ç›®è‚¯å®šä¼šæ˜¯ç¾éš¾ã€‚æ‰€ä»¥ï¼Œèƒ½å¯¹ DBA ç€é‡å¼ºè°ƒä¸€ä¸‹è¿™ä¸€ç‚¹æˆ–è®¸è¦æ¯”çœ‹æ›´å¤šçš„åŒè´¨åŒ–å†…å®¹æ›´æœ‰ä»·å€¼ã€‚

[é€šè¿‡å¤§è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰è¯†åˆ«ä¸ä¿®å¤é£é™©ä»£ç  | å­—èŠ‚è·³åŠ¨æ— æ’å®éªŒå®¤]: https://www.anquanke.com/post/id/289615

![](../../../../../../../Assets/Pics/Pasted%20image%2020240324141945.png)

[å¤§æ¨¡å‹é‡ä¸Šæ¶æ„è½¯ä»¶ï¼šå¼€å¯è‡ªä¸»å¨èƒæ—¶ä»£ | CSDN]: http://t.csdnimg.cn/oI0OY

[ğŸ‘ å¤§æ¨¡å‹ä¸æ¨¡ç³Šæµ‹è¯•è¿›è¡Œç»“åˆçš„ç ”ç©¶è®ºæ–‡æ±‡æ€»ï½œæŠ€æœ¯è¿›å±•]: https://mp.weixin.qq.com/s/DL4pGH-7nPi3eSRD-rlD-w

åœ¨è½¯ä»¶èµ·åˆ°é‡è¦ä½œç”¨çš„ç°ä»£ï¼Œè½¯ä»¶å®‰å…¨å’Œæ¼æ´åˆ†æå·²ç»æˆä¸ºè½¯ä»¶å¼€å‘çš„å…³é”®ã€‚æ¨¡ç³Šæµ‹è¯•ä½œä¸ºä¸€ç§é«˜æ•ˆçš„è½¯ä»¶æµ‹è¯•æ–¹æ³•ï¼Œè¢«å¹¿æ³›åº”ç”¨äºå„ä¸ªé¢†åŸŸã€‚æ­¤å¤–ï¼Œå¤§è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰çš„å¿«é€Ÿå‘å±•ä¹Ÿä¿ƒè¿›äº†å…¶åœ¨è½¯ä»¶æµ‹è¯•é¢†åŸŸçš„åº”ç”¨ï¼Œå¹¶å±•ç¤ºå‡ºå…¶å“è¶Šçš„æ€§èƒ½ã€‚è€ƒè™‘åˆ°ç°æœ‰çš„æ¨¡ç³Šæµ‹è¯•æŠ€æœ¯å¹¶éå®Œå…¨è‡ªåŠ¨åŒ–ï¼Œè€Œä¸”è½¯ä»¶æ¼æ´ä»åœ¨ä¸æ–­æ¼”å˜ï¼Œé‡‡ç”¨åŸºäºå¤§è¯­è¨€æ¨¡å‹ç”Ÿæˆçš„æ¨¡ç³Šæµ‹è¯•å·²æˆä¸ºä¸€ç§è¶‹åŠ¿ã€‚æœ¬è°ƒæŸ¥æŠ¥å‘Šç³»ç»Ÿåœ°æ¦‚è¿°äº†å°†LLMå’Œæ¨¡ç³Šæµ‹è¯•ç»“åˆåˆ°è½¯ä»¶æµ‹è¯•ä¸­çš„æ–¹æ³•ã€‚æœ¬æ–‡ä»ä¸‰ä¸ªæ–¹é¢å¯¹æ–‡çŒ®è¿›è¡Œäº†ç»Ÿè®¡åˆ†æå’Œè®¨è®ºï¼ŒåŒ…æ‹¬LLMsã€æ¨¡ç³Šæµ‹è¯•å’ŒåŸºäºLLMsç”Ÿæˆçš„æ¨¡ç³Šæµ‹è¯•ï¼Œæ€»ç»“äº†æˆªè‡³Â 2024Â å¹´çš„æœ€æ–°æ–¹æ³•ã€‚æˆ‘ä»¬çš„è°ƒæŸ¥è¿˜ç ”ç©¶äº†åŸºäºLLMÂ ç”Ÿæˆçš„æ¨¡ç³Šæµ‹è¯•æŠ€æœ¯åœ¨æœªæ¥å¹¿æ³›éƒ¨ç½²å’Œåº”ç”¨çš„æ½œåŠ›ã€‚

[ğŸ¤” How Effective Are They? Exploring Large Language Model Based Fuzz Driver Generation]: https://ui.adsabs.harvard.edu/abs/2023arXiv230712469Z/abstract

[ğŸ¤” AutoDroid | Github]: https://github.com/MobileLLM/AutoDroid

Source code for the paper "Empowering LLM to use Smartphone for Intelligent Task Automation"
[arxiv.org/abs/2308.15272](https://arxiv.org/abs/2308.15272 "https://arxiv.org/abs/2308.15272")

[ğŸ‘ ç™½æ³½SASTå›¢é˜Ÿï¼šå°†LLMç»‡å…¥SASTç¨‹åºåˆ†ææµç¨‹çš„å®è·µ]: https://mp.weixin.qq.com/s/xUpFyx8pfY8SezE8JGLFmQ

[LLM-Enhanced Static Anlysis for Pracise Identification of Vulnerable OSS Version]: https://arxiv.org/pdf/2408.07321
[AutoSafeCoder: A Multi-Agent Framework for Securing LLM Code Generation through Static Analysis and Fuzz Testing]: https://arxiv.org/abs/2409.10737
