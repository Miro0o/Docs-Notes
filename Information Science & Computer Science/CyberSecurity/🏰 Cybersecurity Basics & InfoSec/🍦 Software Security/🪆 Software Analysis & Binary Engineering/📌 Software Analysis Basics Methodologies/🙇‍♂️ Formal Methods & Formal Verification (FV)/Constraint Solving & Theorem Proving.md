# Constraint Solving & Theorem Proving

[TOC]



## Res
### Related Topics
‚Üó [Mathematical Optimization](../../../../../../üßÆ%20Mathematics/üßë‚Äçü¶Ø‚Äç‚û°Ô∏è%20Operations%20Research%20(OR)/Mathematical%20Optimization/Mathematical%20Optimization.md)

‚Üó [SAT (Boolean Satisfiability Problem) Solvers](../../../../../‚ò†Ô∏è%20Kill%20Chain%20&%20Security%20Tool%20Box/üîû%20Software%20Analysis%20Tools/‚õ∞Ô∏è%20Static%20Code%20Analysis%20Tools%20(SCAT)/Symbolic%20Execution%20&%20Constrain%20Solvers/SAT%20(Boolean%20Satisfiability%20Problem)%20Solvers/SAT%20(Boolean%20Satisfiability%20Problem)%20Solvers.md)
‚Üó [SMT (Satisfiability Modulo Theory) Solvers](../../../../../‚ò†Ô∏è%20Kill%20Chain%20&%20Security%20Tool%20Box/üîû%20Software%20Analysis%20Tools/‚õ∞Ô∏è%20Static%20Code%20Analysis%20Tools%20(SCAT)/Symbolic%20Execution%20&%20Constrain%20Solvers/SMT%20(Satisfiability%20Modulo%20Theory)%20Solvers/SMT%20(Satisfiability%20Modulo%20Theory)%20Solvers.md)



## Intro



## Ref
[Constraint satisfaction problem (CSP) vs. satisfiability modulo theory (SMT); with a coda on constraint programming | StackExchange]: https://cstheory.stackexchange.com/q/29406
SAT, CP, SMT, (much of) ASP all deal with the same set of combinatorial optimisation problems. However, they come at these problems from different angles and with different toolboxes. These differences are largely in how each approach structures information about the exploration of the search space. My working analogy is that SAT is machine code, while the others are higher level languages.
