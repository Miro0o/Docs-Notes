# Theory of Computation

[TOC]



## Res
### Related Topics
↗ [Set Theory](../Set%20Theory/Set%20Theory.md)
↗ [Graph Theory](../../Graph%20Theory/Graph%20Theory.md)

↗ [Mathematical Modeling & Real World Problem Solving](../../Mathematical%20Modeling%20&%20Real%20World%20Problem%20Solving.md)


### Learning Resources
🎬【【北京大学】理论计算机科学基础（全70讲）】 https://www.bilibili.com/video/BV1m4411p7nS/?share_source=copy_web&vd_source=7740584ebdab35221363fc24d1582d9d
https://mannuan.github.io/计算理论课件/
主讲老师：刘田

🎬【【MIT18.404】计算理论基础(完结)—理论研究或算法应用的基础课】 https://www.bilibili.com/video/BV1qL411s7mr/?share_source=copy_web&vd_source=7740584ebdab35221363fc24d1582d9d - Michael Sipser

📖 Introduction to the Theory of Computation, 3rd edition, by Michael Sipser
- [Sipers-computation-3rd-solutions](https://github.com/gaurangsaini/sipser-computation-3rd-solutions)
- This book focuses on three traditionally central areas of the theory of computation: automata, computability, and complexity. They are linked by the question: 
	- What are the fundamental capabilities and limitations of computers?

📂 https://hackmd.io/2AqODdrtTOuj6fb5uMDZYw?view
The goal is to build a collection of videos for an undergraduate Theory of Computation course. We hope that this collection of videos would be a useful community resource for flipped classes. The intent is that these videos can be used in a flipped class format. The flipped format has been quite successful for other topics and seems well suited to remote teaching that many of us are doing. The instructor can choose to use these videos in whatever fashion he/she thinks best. These videos will ideally be supplemented by classroom discussion, practice exercises and assignments as part of the course.

📖 [Computational Complexity: A Modern Approach](http://www.cs.princeton.edu/theory/complexity/) by Arora and Barak.
📖 Introduction to automata theory, languages, and computation / by John E. Hopcroft,. Rajeev Motwani, Jeffrey D. Ullman. -- _3rd ed_.

📖 [Computational Complexity](http://rads.stackoverflow.com/amzn/click/0201530821) by Papadimitriou
📖 [Computability and Logic](https://www.cambridge.org/core/books/computability-and-logic/440B4178B7CBF1C241694233716AB271) by George S. Boolos and John P. Burgess.
📖 [Oded Goldreich's textbook](http://rads.stackoverflow.com/amzn/click/052188473X)

👨‍💻 https://www.mropengate.com/2015/06/formal-language.html
計算理論是計算機科學的靈魂 - 國立陽明交通大學
一、正則語言 Regular Languages  
- [Ch1 決定性有限自動機 Deterministic Finite automata, DFA](http://mropengate.blogspot.tw/2015/03/formal-language-ch11-finite-automata.html)
- [Ch2 非決定性有限自動機 Nondeterminism Finite automata, NFA](http://mropengate.blogspot.tw/2015/04/formal-language-ch2-nondeterminism.html)
- [Ch3 正則表達式 Regular Expression, RE](http://mropengate.blogspot.tw/2015/04/formal-language-ch3-regular-expression.html)
- [Ch3.5 常用的正則表示式 Regular Expression in Application](http://mropengate.blogspot.tw/2015/02/regular-expression.html)
- [Ch4 泵引理 Pumping Lemma](http://mropengate.blogspot.tw/2015/04/formal-language-ch4-pumping-lemma.html)
- [Ch5 邁希爾－尼羅德定理 Myhill-Nerode Theorem](http://mropengate.blogspot.tw/2015/04/formal-language-ch5-myhill-nerode.html)
二、上下文無關語言 Context-Free Languages  
- [Ch6 上下文無關語言 Context-free language, CFLs](http://mropengate.blogspot.tw/2015/04/formal-language-ch6-context-free.html)
- [Ch7 下推自動機 Pushdown automaton, PDAs](http://mropengate.blogspot.tw/2015/04/formal-language-ch7-pushdown-automaton.html)
- [Ch8 上下文無關語言泵引理 Pumping lemma for context free languages](http://mropengate.blogspot.tw/2015/04/formal-language-ch7-pumping-lemma-for.html)
三、邱奇－圖靈論題 Church–Turing Thesis  
- [Ch9 圖靈機 Turing Machines](http://mropengate.blogspot.tw/2015/05/formal-language-ch9-turing-machines.html)
- [Ch10 變種圖靈機 Variants of Turing Machines](http://mropengate.blogspot.tw/2015/05/formal-language-ch10-variants-of-turing.html)
四、決定性問題 Decidability  
- [Ch11 決定性問題 Decidability](http://mropengate.blogspot.tw/2015/05/formal-language-ch11-decidability.html)
- [Ch12 不可決定問題與圖靈可識別語言 Undecidable Problem and Turing-recognizable language](http://mropengate.blogspot.tw/2015/05/formal-language-undecidable-problem.html)
- [Ch12.5 決定與不可決定問題相關習題](http://mropengate.blogspot.tw/2015/05/formal-language-ch125.html)
五、歸約 Reducibility  
- [Ch13 可歸約性 Reducibility](http://mropengate.blogspot.tw/2015/05/formal-language-ch13-reducibility.html)
- [Ch14 多一歸約 Mapping Reducibility](http://mropengate.blogspot.tw/2015/05/formal-language-ch14-mapping.html)
- [Ch14.5 歸約相關習題 Exercises for Reducibility](http://mropengate.blogspot.tw/2015/05/formal-language-ch145-exercises-mapping.html)
六、時間複雜度 Time Complexity  
- [Ch15 複雜度P和NP Time Complexity, P and NP](http://mropengate.blogspot.tw/2015/06/formal-language-ch15-pnp-time.html)
- [Ch16 NP完全 NP-Complete, NPC](http://mropengate.blogspot.tw/2015/06/formal-language-ch16-np-np-complete-npc.html)
- [Ch16.5 Cook-Levin理論與卡普的二十一個NP-完全問題](http://mropengate.blogspot.tw/2015/06/algorithm-cook-levinnp.html)

https://zemdalk.github.io/archive.html?tag=理论计算机科学基础
- 06月02日[理论计算机科学基础（13）——NL完全、NL=coNL](https://zemdalk.github.io/2022/06/02/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80-13.html)
- 05月31日[理论计算机科学基础（12）——PSPACE完全](https://zemdalk.github.io/2022/05/31/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80-12.html)
- 05月30日[理论计算机科学基础（11）——空间复杂性类](https://zemdalk.github.io/2022/05/30/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80-11.html)
- 05月19日[理论计算机科学基础（10）——更多NP完全问题](https://zemdalk.github.io/2022/05/19/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80-10.html)
- 05月13日[理论计算机科学基础（9）——NP完全问题](https://zemdalk.github.io/2022/05/13/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80-9.html)
- 05月12日[理论计算机科学基础（8）——时间复杂性](https://zemdalk.github.io/2022/05/12/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80-8.html)
- 04月25日[理论计算机科学基础（7）——图灵归约](https://zemdalk.github.io/2022/04/25/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80-7.html)
- 04月15日[理论计算机科学基础（6）——递归定理](https://zemdalk.github.io/2022/04/15/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80-6.html)
- 04月07日[理论计算机科学基础（5）——可归约性](https://zemdalk.github.io/2022/04/07/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80-5.html)
- 03月31日[理论计算机科学基础（4）——可计算性](https://zemdalk.github.io/2022/03/31/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80-4.html)
- 03月28日[理论计算机科学基础（3）——图灵机](https://zemdalk.github.io/2022/03/28/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-3.html)
- 03月14日[理论计算机科学基础（2）——上下文无关文法](https://zemdalk.github.io/2022/03/14/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-2.html)
- 02月22日[理论计算机科学基础（1）——绪论、正则语言](https://zemdalk.github.io/2022/02/22/%E7%90%86%E8%AE%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80-1.html)



## Intro
![](../../../../../Assets/Pics/Screenshot%202023-05-08%20at%204.26.42%20PM.png)
<small>What can computers do?</small>

> 🔗 https://en.wikipedia.org/wiki/Theory_of_computation

In [theoretical computer science](https://en.wikipedia.org/wiki/Theoretical_computer_science "Theoretical computer science") and [mathematics](https://en.wikipedia.org/wiki/Mathematics "Mathematics"), the **theory of computation** is the branch that deals with what problems can be solved on a model of computation, using an algorithm, how efficiently they can be solved or to what degree (e.g., [approximate solutions](https://en.wikipedia.org/wiki/Approximation_algorithms "Approximation algorithms")versus precise ones). The field is divided into three major branches:
1. [automata theory](https://en.wikipedia.org/wiki/Automata_theory "Automata theory") and [formal languages](https://en.wikipedia.org/wiki/Formal_language "Formal language")
	1. 有哪些计算装置？能力如何
	2. 有穷（无穷）自动机 /下推自动机 /图灵机
	3. 正则语言 /上下文无关语言 /可计算语言 /半可计算语言
2. [computability theory](https://en.wikipedia.org/wiki/Computability_theory "Computability theory")
	1. 什么是计算？哪些问题可以计算/不可以计算？
	2. 丘奇-图灵论题 /通用机 /停机问题 /规约 /递归定理
3. [computational complexity theory](https://en.wikipedia.org/wiki/Computational_complexity_theory "Computational complexity theory"), which are linked by the question: _"What are the fundamental capabilities and limitations of computers?"._
	1. 什么是有效计算？哪些问题可以/不可以有效计算？
	2. 时间复杂性 /空间复杂性 /多项式时间归约 /完全问题

> 🔗 https://www.mropengate.com/2015/06/formal-language.html

透過計算模型，我們可以對計算定下明確的數學定義。而一旦有了明確的定義，便可以研究什麼是可計算的、什麼是不可計算的，而對於可計算的問題，必須花費多少時間和空間才可能計算。  
  
Church–Turing thesis 指出，所有演算法可解的問題，都可透過 Turing machines 求解，也因此，藉由研究 Turing machines 我們得以探討電腦的極限，以及對各種問題的難度訂出明確的界線。  
  
這是一門非常理論與數學的課，需要非常清晰的邏輯思考。老師曾說，資訊界日新月異，許多課程可能幾年後就不見了，或者教的東西大幅改變。但你幾乎可以確定，正規語言這門課還是會一直存在。從哲學的角度來說，計算理論在電腦科學裡佔了十分核心的地位。  
  
正規語言課程所學的東西其實也有很多延伸的應用，以至於很多讀者很可能早已接觸過某些部份，但直到這門課，才真正以嚴謹的方式學習背後的來歷。像是如果有接觸像 Python 等語言或者用過 Vim 等編輯器的搜尋功能的讀者，很有可能有接觸過正規表示式。而 CFG 和程式語言的設計以及編譯器等課程有密切相關，你或許會曾在程式語言的文件上看過他。如果在演算法等課程聽過 NP、P 等名詞，在這堂課裡，你可以學到這些名詞到底有什麼含意。而對什麼是演算法，時間複雜度、問題的可計算性等等，都會在這堂課得到更深的理解。

> 📖  Introduction to the Theory of Computation, 3rd edition, by Michael Sipser, CH0, Introduction

This book focuses on three traditionally central areas of the theory of computation: automata, computability, and complexity. They are linked by the question:

> **What are the fundamental capabilities and limitations of computers?**

This question goes back to the 1930s when mathematical logicians first began to explore the meaning of computation. Technological advances since that time have greatly increased our ability to compute and have brought this question out of the realm of theory into the world of practical concern.

In each of the three areas—automata, computability, and complexity -- this question is interpreted differently, and the answers vary according to the interpretation. Following this introductory chapter, we explore each area in a separate part of this book. Here, we introduce these parts in reverse order because by starting from the end you can better understand the reason for the beginning.

**COMPLEXITY THEORY**
Computer problems come in different varieties; some are easy, and some are hard. For example, the sorting problem is an easy one. Say that you need to arrange a list of numbers in ascending order. Even a small computer can sort a million numbers rather quickly. Compare that to a scheduling problem. Say that you must find a schedule of classes for the entire university to satisfy some reasonable constraints, such as that no two classes take place in the same room at the same time. The scheduling problem seems to be much harder than the sorting problem. If you have just a thousand classes, finding the best schedule may require centuries, even with a supercomputer.

> **What makes some problems computationally hard and others easy?**

This is the central question of complexity theory. Remarkably, we don’t know the answer to it, though it has been intensively researched for over 40 years. Later, we explore this fascinating question and some of its ramifications. 

In one important achievement of complexity theory thus far, researchers have discovered an elegant scheme for classifying problems according to their computational difficulty. It is analogous to the periodic table for classifying elements according to their chemical properties. Using this scheme, we can demonstrate a method for giving evidence that certain problems are computationally hard, even if we are unable to prove that they are.

You have several options when you confront a problem that appears to be computationally hard. First, by understanding which aspect of the problem is at the root of the difficulty, you may be able to alter it so that the problem is more easily solvable. Second, you may be able to settle for less than a perfect solution to the problem. In certain cases, finding solutions that only approximate the perfect one is relatively easy. Third, some problems are hard only in the worst case situation, but easy most of the time. Depending on the application, you may be satisfied with a procedure that occasionally is slow but usually runs quickly. Finally, you may consider alternative types of computation, such as randomized computation, that can speed up certain tasks.

One applied area that has been affected directly by complexity theory is the ancient field of cryptography. In most fields, an easy computational problem is preferable to a hard one because easy ones are cheaper to solve. Cryptography is unusual because it specifically requires computational problems that are hard, rather than easy. Secret codes should be hard to break without the secret key or password. Complexity theory has pointed cryptographers in the direction of computationally hard problems around which they have designed revolutionary new codes.

**COMPUTABILITY THEORY**
During the first half of the twentieth century, mathematicians such as Kurt Godel, Alan Turing, and Alonzo Church discovered that certain basic problems cannot be solved by computers. One example of this phenomenon is the problem of determining whether a mathematical statement is true or false. This task is the bread and butter of mathematicians. It seems like a natural for solution by computer because it lies strictly within the realm of mathematics. But no computer algorithm can perform this task.

Among the consequences of this profound result was the development of ideas concerning theoretical models of computers that eventually would help lead to the construction of actual computers.

The theories of computability and complexity are closely related. In complexity theory, the objective is to classify problems as easy ones and hard ones; whereas in computability theory, the classification of problems is by those that are solvable and those that are not. Computability theory introduces several of the concepts used in complexity theory.

**AUTOMATA THEORY**
Automata theory deals with the definitions and properties of mathematical models of computation. These models play a role in several applied areas of computer science. One model, called the finite automaton, is used in text processing, compilers, and hardware design. Another model, called the context-free grammar, is used in programming languages and artificial intelligence.

Automata theory is an excellent place to begin the study of the theory of computation. The theories of computability and complexity require a precise definition of a computer. Automata theory allows practice with formal definitions of computation as it introduces concepts relevant to other non-theoretical areas of computer science.



## Models Of Computation
> 🔗 https://en.wikipedia.org/wiki/Model_of_computation

In computer science, and more specifically in computability theory and computational complexity theory, a model of computation is a model which describes how an output of a mathematical function is computed given an input. A model describes how units of computations, memories, and communications are organized. The computational complexity of an algorithm can be measured given a model of computation. Using a model allows studying the performance of algorithms independently of the variations that are specific to particular implementations and specific technology.


### Sequential Models
Sequential models include:
- [Finite-state machines](https://en.wikipedia.org/wiki/Finite-state_machine "Finite-state machine")
- Post machines ([Post–Turing machines](https://en.wikipedia.org/wiki/Post%E2%80%93Turing_machine "Post–Turing machine") and [tag machines](https://en.wikipedia.org/wiki/Tag_system "Tag system")).
- [Pushdown automata](https://en.wikipedia.org/wiki/Pushdown_automata "Pushdown automata")
- [Register machines](https://en.wikipedia.org/wiki/Register_machine "Register machine")
    - [Random-access machines](https://en.wikipedia.org/wiki/Random-access_machine "Random-access machine")
- [Turing machines](https://en.wikipedia.org/wiki/Turing_machine "Turing machine")
- [Decision tree model](https://en.wikipedia.org/wiki/Decision_tree_model "Decision tree model")
- [External memory model](https://en.wikipedia.org/wiki/External_memory_model "External memory model")


### Functional Models
Functional models include:
- [Abstract rewriting systems](https://en.wikipedia.org/wiki/Abstract_rewriting_system "Abstract rewriting system")
- [Combinatory logic](https://en.wikipedia.org/wiki/Combinatory_logic "Combinatory logic")
- [General recursive functions](https://en.wikipedia.org/wiki/General_recursive_function "General recursive function")
- [Lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus "Lambda calculus")


### Concurrent Models
Concurrent models include:
- [Actor model](https://en.wikipedia.org/wiki/Actor_model "Actor model")
- [Cellular automaton](https://en.wikipedia.org/wiki/Cellular_automaton "Cellular automaton")
- [Interaction nets](https://en.wikipedia.org/wiki/Interaction_nets "Interaction nets")
- [Kahn process networks](https://en.wikipedia.org/wiki/Kahn_process_networks "Kahn process networks")
- [Logic gates](https://en.wikipedia.org/wiki/Logic_gate "Logic gate") and [digital circuits](https://en.wikipedia.org/wiki/Circuit_\(computer_science\) "Circuit (computer science)")
- [Petri nets](https://en.wikipedia.org/wiki/Petri_nets "Petri nets")
- [Process calculus](https://en.wikipedia.org/wiki/Process_calculus "Process calculus")
- [Synchronous Data Flow](https://en.wikipedia.org/wiki/Synchronous_Data_Flow "Synchronous Data Flow")

Some of these models have both [deterministic](https://en.wikipedia.org/wiki/Deterministic_model#In_computer_science "Deterministic model") and [nondeterministic](https://en.wikipedia.org/wiki/Nondeterministic_model_of_computation "Nondeterministic model of computation") variants. Nondeterministic models correspond to limits of certain sequences of finite computers, but do not correspond to any subset of finite computers;[_[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed "Wikipedia:Citation needed")_] they are used in the study of [computational complexity](https://en.wikipedia.org/wiki/Computational_complexity "Computational complexity") of algorithms.

Models differ in their expressive power; for example, each function that can be computed by a _finite-state machine_ can also be computed by a _Turing machine_, but not vice versa.



## Ref
[计算机专业学计算理论基础的意义？ - 知乎]: https://www.zhihu.com/question/27306122
[计算理论重点——Theory of Computation]: https://blog.csdn.net/abcjennifer/article/details/8494019
[什么是可计算理论]: https://www.cnblogs.com/hjlweilong/p/13908517.html
[理论计算机科学浅涉：可计算性理论（一）]: http://niwatori.io/2018/01/13/computability-theory/

[Waht is the best text of computation theory /theory of computation | Stack Exchange]: https://cstheory.stackexchange.com/a/3527

[如何通俗地解释停机问题（Halting Problem）？ - 张皓的回答 - 知乎]: https://www.zhihu.com/question/20081359/answer/162329455
作者：张皓  
链接：https://www.zhihu.com/question/20081359/answer/162329455  
来源：知乎  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  

**预备知识: [理发师悖论](https://zhida.zhihu.com/search?content_id=59575968&content_type=Answer&match_order=1&q=%E7%90%86%E5%8F%91%E5%B8%88%E6%82%96%E8%AE%BA&zhida_source=entity)**
克里克岛的一座小城里有位理发师, 有一天他做出一项规定: **他给并且只给那些不给自己理发的人理发.** 理发师的这个规定似乎很有道理, 既然有人自己给自己理发了, 那么我就不用"多此一举", 我再给这个人理发.

最初, 这个规定并没什么问题, 后来, 随着这个理发师自己的头发越来越长, 他发现他陷入了一个两难的境地: 他该不该给自己理发?
- 如果他为自己理发. 那么他就成为了他规定中那个"自己给自己理发的人", 那么他就不应该为自己理发;
- 如果他不为自己理发, 那么他不是他规定中那个"自己给自己理发的人", 那么他就应该为自己理发.

综合以上两种情况, "他为自己理发"当且仅当"他不为自己理发", 这成为了一个悖论.

理发师悖论在很多领域有重要的应用, 比如罗素利用理发师悖论发现了集合论的缺陷, 在当时学术界引起了极大震动. 在这里, 我们要用理发师悖论分析[停机问题](https://zhida.zhihu.com/search?content_id=59575968&content_type=Answer&match_order=1&q=%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98&zhida_source=entity).


**停机问题**
当我们写代码调试的时候, 有时会遇到这样一种情况: 等了很久, 程序还一直在运行. 我们不知道是代码在正常运行只是运行时间比较久, 还是代码写的有问题(比如写了死循环)导致程序根本不会停止. 这时候我们想, 如果能有个工具能为我们判断我们写的代码的运行时间就好了. 这就是停机问题.

不失一般性, 假设我们想要测试的代码是一个函数

```cpp
void f(char *t);
```

其中t是一个字符串, 我们可以用一个字符串表示任意输入, 包括`int`, `double`, 及复合数据类型; 当f不需要输入时, `t`是一个空字符串. 停机问题是指对给定任意的一个函数`f`和输入`t`, 判断`f`对`t`是否会永远运行下去; 如果程序的运行时间是有限长的, 我们称`f`对`t`**停机**.

遗憾的是, **不存在**这样的一个工具使得其能判断任意f的停机问题, 即**停机问题不可判定**.

以下我们用反证法证明这个断言. 假设存在这样的一个函数可用于判断停机问题

```cpp
bool halts(char *f_code, char *t);
```

其中`f_code`是我们要进行测试的函数f的ASCII源代码, 我们可以认为对`f_code`进行编译得到了函数`f`. 当`f`对`t`停机时, `halts(f_code, t)`返回`true`; 当`f`对`t`不停机, `halts(f_code, t)`返回`false`.

我们构造这样一个函数

```cpp
void modified_halts(char *f_code) {
  if (halts(f_code, f_code)) {  // 当halts(f_code, f_code)返回true
    while (true) { /*empty*/ }  // 死循环
  }
  else {                        // 当halts(f_code, f_code)返回false
    return;                     // 立即停止运行
  }
}
```

即当`f`对`f_code`停机时, 我们让`modified_halts`不停机; 当`f`对`f_code`不停机时,`modified_halts`停机.

假设`modified_halts`这个函数的ASCII源代码是`modified_halts_code`, 如果我们把`modified_halts_code`作为`modified_halts`的输入会是什么情况?

- 如果`modified_halts`对`modified_halts_code`停机, 说明`halts(modified_halts_code, modified_halts_code)`返回`false`, 说明`modified_halts`对`modified_halts_code`不停机;
- 如果`modified_halts`对`modified_halts_code`不停机, 说明`halts(modified_halts_code, modified_halts_code)`返回`true`, 说明`modified_halts`对`modified_halts_code`停机.

综合以上两种情况, "`modified_halts`对`modified_halts_code`停机"当且仅当"`modified_halts`对`modified_halts_code`不停机", 这是一个矛盾, 说明不存在这样一个`halts`函数可用于判断任意函数的可停机性.

**以上这个证明利用的就是理发师悖论, `modified_halts`函数就像是那位克里克岛小城里的理发师, 他对并且只对那些不停机的函数停机. 当`modified_halts`函数面对他自己的函数代码时, 就像理发师该不该给他自己刮胡子一样, 将陷入两难境地.**


**停机问题的意义**
停机问题的意义包括以下三点:
1. **计算机的计算能力**. 随着电子技术和计算机技术的发展, 计算机的存储和计算能力与日俱进, 有些以前看起来不可行的问题现在已经可以轻松地解决. 但是不是当存储和计算能力大到无限的时候, 我们可以解决任何问题? 停机问题给出了否定的答案, 即不管计算机的存储和计算能力有多强, 停机问题都无法解决.
2. **不同语言, 不同计算设备的计算能力.** 1936年Alan Turing设计出一种假想的计算设备称为 **[通用图灵机](https://zhida.zhihu.com/search?content_id=59575968&content_type=Answer&match_order=1&q=%E9%80%9A%E7%94%A8%E5%9B%BE%E7%81%B5%E6%9C%BA&zhida_source=entity)**,  **[Church-Turing论题](https://zhida.zhihu.com/search?content_id=59575968&content_type=Answer&match_order=1&q=Church-Turing%E8%AE%BA%E9%A2%98&zhida_source=entity)** 指出如果一个函数是可计算的, 那么这个函数可以用图灵机编程去计算它. 而停机问题就是不可计算的. 虽然现在市面上有很多语言, 看上去C能直接操作底层, C的计算能力要比Java, Python这样的语言更强, 但是现在所有的语言都是**Turing完备**的, 意思是指这个语言可以被用来模拟一台通用图灵机. 因此, 任何可以用C编程出来的同样也可以用Java, Python这样的语言编程出来, 所有语言在计算能力上等价.
3. **不存在一个完美的工具可以检测代码的运行时性质**. 比如说, 许多编译器都可以在编译过程中对代码进行静态类型检查, 以确保代码不会出现运行时的类型错误. 我们同样可以用理发师悖论证明, 不存在完美的类型检查工具, 即一定会存在一些代码, 类型检查工具会认为它有问题, 而实际这个代码不会出现运行时的类型错误. 对停机问题的研究可以作为我们做实际问题的指导.

**参考文献**
[1]. Alan Turing. On computable numbers, with an application to the Entscheidungsproblem. Proceedings of the London Mathematical Society, Series 2, Volume 42 (1937), pp 230–265.
[2]. Robert Soare. Turing oracle machines, online computing, and three displacements in computability theory. Annals of Pure and Applied Logic 160.3 (2009): 368-399.
[3]. Eric Lehman, Thomson Leighton, and Albert Meyer. Mathematics for Computer Science (2017 version). MIT. 2017.
[4]. Udi Aharoni. Zuto: The Adventures of a Computer Virus. CreateSpace Independent Publishing Platform. 2012.
[5]. 宋方敏. 计算模型导引. 高等教育出版社. 20121
