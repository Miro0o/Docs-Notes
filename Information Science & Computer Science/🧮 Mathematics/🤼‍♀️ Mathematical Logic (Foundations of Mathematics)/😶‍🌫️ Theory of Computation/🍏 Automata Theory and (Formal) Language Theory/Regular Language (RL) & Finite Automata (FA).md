# Regular Language (RL) & Finite Automata (FA)

[TOC]



## Res
### Related Topics
↗ [regex (Regular Expression)](../../../../🔑%20CS%20Core/👩‍💻%20Computer%20Languages%20&%20Programming%20Methodology/Other%20Languages%20for%20Specific%20Areas/🪁%20DSL(Domain%20Specific%20Languages)%20&%20GPL(General%20Purpose%20Languages)/📌%20regex%20(Regular%20Expression)/regex%20(Regular%20Expression).md)



## Intro
> 🔗 https://en.wikipedia.org/wiki/Regular_language

In [theoretical computer science](https://en.wikipedia.org/wiki/Theoretical_computer_science "Theoretical computer science") and [formal language theory](https://en.wikipedia.org/wiki/Formal_language_theory "Formal language theory"), a **regular language**(also called a **rational language**) is a [formal language](https://en.wikipedia.org/wiki/Formal_language "Formal language") that can be defined by a [regular expression](https://en.wikipedia.org/wiki/Regular_expression "Regular expression"), in the strict sense in theoretical computer science (==as opposed to many modern regular expression engines, which are augmented with features that allow the recognition of non-regular languages==).

Alternatively, a regular language can be defined as a language recognized by a [finite automaton](https://en.wikipedia.org/wiki/Finite_automaton "Finite automaton"). The equivalence of regular expressions and finite automata is known as **Kleene's theorem** (after American mathematician [Stephen Cole Kleene](https://en.wikipedia.org/wiki/Stephen_Cole_Kleene "Stephen Cole Kleene")). In the [Chomsky hierarchy](https://en.wikipedia.org/wiki/Chomsky_hierarchy "Chomsky hierarchy"), regular languages are the languages generated by [Type-3 grammars](https://en.wikipedia.org/wiki/Regular_grammar "Regular grammar").


### Formal Definition of Finite Automata
> ↗ [(Formal) Model Checking](../../../../CyberSecurity/🏰%20Cybersecurity%20Basics%20&%20InfoSec/🍦%20Software%20Security/🪆%20Software%20Analysis%20&%20Binary%20Engineering/📌%20Software%20Analysis%20Basics/🙇‍♂️%20Formal%20Methods%20&%20Formal%20Verification%20(FV)/(Formal)%20Model%20Checking/(Formal)%20Model%20Checking.md) "Transition System"

> 📖  Introduction to the Theory of Computation | Sipser

In beginning to describe the mathematical theory of finite automata, we do so in the abstract, without reference to any particular application. The following figure depicts a finite automaton called $M_{1}$.
```tikz
\usepackage{tikz}
\usetikzlibrary{automata, positioning}

\begin{document}

\begin{tikzpicture}[shorten >=1pt, node distance=3cm, on grid, auto] 
   % States
   \node[state, initial] (q1) {$q_1$}; 
   \node[state, accepting, right=of q1] (q2) {$q_2$}; 
   \node[state, right=of q2] (q3) {$q_3$}; 

   % Transitions
   \path[->] 
    (q1) edge[loop above] node {0} ()
         edge node {1} (q2)
    (q2) edge[loop above] node {1} ()
         edge[bend left, above] node {0} (q3)
    (q3) edge[bend left, below] node {0,1} (q2);
\end{tikzpicture}

% \textbf{Figure:} Finite State Automaton recognizing ... (your description here)

\end{document}
```
<div style="text-align: center;">
  <small>FIGURE 1.4. A finite automaton called M1 that has three states</small>
</div>

Figure 1.4 is called the **state diagram** of $M_{1}$. It has three states, labeled $q_{1}$, $q_{2}$, and $q_{3}$. The **start state**, $q_{1}$, is indicated by the arrow pointing at it from nowhere. The **accept state**, $q_{2}$, is the one with a double circle. The arrows going from one state to another are called **transitions**. 

When this automaton receives an input string such as $1101$, it processes that string and produces an output. The output is either **accept** or **reject**. We will consider only this yes/no type of output for now to keep things simple. The processing begins in $M_{1}$’s start state. The automaton receives the symbols from the input string one by one from left to right. After reading each symbol, $M_{1}$ moves from one state to another along the transition that has that symbol as its label. When it reads the last symbol, $M_{1}$ produces its output. The output is accept if $M_{1}$ is now in an accept state and reject if it is not.

A finite automaton is a 5-tuple $(Q, \Sigma, \delta ,q_{0}, F)$, where
1. $Q$ is a finite set called the states,
2. $\Sigma$ is a finite set called the alphabet,
3. $\delta: Q \times \Sigma \to Q$ is the transition function,
4. $q_{0} \in Q$ is the start state, and
5. $F \subseteq Q$ is the set of accept states /final states.



## Ref

