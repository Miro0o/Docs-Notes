# The Essence of Computing - Programs & The Semantics of Programs

[TOC]



## Res
### Related Topics
â†— [Theory of Computation](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/Theory%20of%20Computation.md)
- â†— [Automata Theory and (Formal) Language Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)
â†— [Formal Semantics and Programming Language](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Formal%20Semantics%20and%20Programming%20Language.md)
- â†— [Operational Semantics](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Operational%20Semantics.md)

â†— [Mathematical Modeling & Real World Problem Solving](../ğŸ§®%20Mathematics/Mathematical%20Modeling%20&%20Real%20World%20Problem%20Solving.md)
â†— [(Formal) Model Checking /1ï¸âƒ£ System Modeling](../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ™‡â€â™‚ï¸%20Formal%20Methods%20&%20Formal%20Verification%20(FV)/(Formal)%20Model%20Checking/(Formal)%20Model%20Checking.md#1ï¸âƒ£%20System%20Modeling)

â†— [Computer Languages & Programming Methodology](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/Computer%20Languages%20&%20Programming%20Methodology.md)
â†— [Programming Language Processing & Program Execution](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/Programming%20Language%20Processing%20&%20Program%20Execution.md)
- â†— [Program Language Processing & Compilation Theory (Compile-time)](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸš®%20Program%20Language%20Processing%20&%20Compilation%20Theory%20(Compile-time)/Program%20Language%20Processing%20&%20Compilation%20Theory%20(Compile-time).md)
	- â†— [Semantic Analysis](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸš®%20Program%20Language%20Processing%20&%20Compilation%20Theory%20(Compile-time)/Compilation%20Phase/1ï¸âƒ£%20Frontend%20-%20Programming%20Language%20Analysis/Semantic%20Analysis/Semantic%20Analysis.md)
- â†— [Program Execution (Runtime)](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸ¤¡%20Program%20Execution%20(Runtime)/Program%20Execution%20(Runtime).md)
	- â†— [Procedure (Function) Call & Runtime Memory Layout](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸ¤¡%20Program%20Execution%20(Runtime)/Procedure%20(Function)%20Call%20&%20Runtime%20Memory%20Layout.md)

â†— [Software Engineering](../Software%20Engineering/Software%20Engineering.md)

â†— [OS Memory Management (Main Memory + Secondary Memory Resource)](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/OS%20Memory%20Management%20(Main%20Memory%20+%20Secondary%20Memory%20Resource)/OS%20Memory%20Management%20(Main%20Memory%20+%20Secondary%20Memory%20Resource).md)
â†— [Computer Memory & Storage](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Computer%20Architecture/Computer%20Microarchitectures%20(Computer%20Organization)%20&%20von%20Neumann%20Model/Computer%20Memory%20&%20Storage/Computer%20Memory%20&%20Storage.md)
â†— [Address Space & Memory Layout](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/OS%20Memory%20Management%20(Main%20Memory%20+%20Secondary%20Memory%20Resource)/Address%20Space%20&%20Memory%20Layout.md)

â†— [Operating System & OS Kernel (Theory Part)](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part).md)
â†— [Operating Systems & Kernels (Engineering Part)](../ğŸ”‘%20CS%20Core/ğŸ¥·ğŸ¼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Operating%20Systems%20&%20Kernels%20(Engineering%20Part).md)


### Other Resources
ğŸ”¥ ğŸ¬ã€æ“ä½œç³»ç»Ÿä¸Šçš„ç¨‹åº (ä»€ä¹ˆæ˜¯ç¨‹åºå’Œç¼–è¯‘å™¨) [å—äº¬å¤§å­¦2022æ“ä½œç³»ç»Ÿ-P2]ã€‘ https://www.bilibili.com/video/BV12L4y1379V/?share_source=copy_web&vd_source=7740584ebdab35221363fc24d1582d9d



## Intro
### Related Concepts Review
#### Information, Language, and Computation
![ | 800](../../../Assets/Illustrations/Computer%20Science%20Philosophy/Human_and_knowledge.excalidraw.md)
<small>The relationship of language, information/data, computation, and automation.</small>
â†— [Universe, Self-Awareness, and Intelligence](../../Universe,%20Self-Awareness,%20and%20Intelligence.md)

![Automata_Formal_Lan.excalidraw | 800](../../../Assets/Illustrations/Math/Automata_Formal_Lan.excalidraw.md)
<small>Automata and Formal Language</small>
â†— [Automata Theory and (Formal) Language Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)

![computer_architecture.excalidraw | 800](../../../Assets/Illustrations/Computer%20System/computer_architecture_and_computer_science.excalidraw.md)
<small>Computer System & Computer Science Overview</small>
â†— [Computer Architecture](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Computer%20Architecture/Computer%20Architecture.md)

![application_execution_and_computer_data_flow.excalidraw | 800](../../Assets/Illustrations/Computer%20System/application_execution_and_computer_data_flow.excalidraw.md)
<small>Computer Program Execution Procedure: Top-down Review</small>
â†— [Programming Language Processing & Program Execution](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/Programming%20Language%20Processing%20&%20Program%20Execution.md)

- ä¸»ä½“è§†è§’ä¸‹çš„å®‡å®™ä¸‰å¤§æ„æˆå…ƒç´ ï¼šä¿¡æ¯ã€ç‰©è´¨ã€èƒ½é‡
	- è¯­è¨€ä¸ºä¿¡æ¯ä¸€åˆ‡æ´»åŠ¨æä¾›è½½ä½“ã€‚
		- ä¿¡æ¯å¯ä»¥è„±ç¦»è¯­è¨€å­˜åœ¨ï¼Œä½†æ˜¯è¯­è¨€æ˜¯å¤æ‚ä¿¡æ¯è¿åŠ¨çš„ä¼˜è´¨è½½ä½“ã€‚è„±ç¦»äº†è¯­è¨€ï¼Œä¿¡æ¯å¾ˆéš¾åœ¨ä¸»ä½“æ„è¯†ä¸‹åšå¤æ‚è¿åŠ¨ã€‚
		- è‡ªç„¶è¯­è¨€ï¼Œå½¢å¼è¯­è¨€
	- çŸ¥è¯†æ˜¯æœ‰ç»„ç»‡çš„ä¿¡æ¯
- è®¡ç®—æœºç§‘å­¦çš„ç ”ç©¶èŒƒç•´ï¼šä¿¡æ¯è¿åŠ¨çš„è‡ªåŠ¨åŒ–ï¼ˆè‡ªåŠ¨åŒ–è®¡ç®—ï¼‰
	- è®¡ç®—æœºçš„æ„æˆï¼šè®¡ç®—æ¨¡å‹ï¼ˆæ•°å­¦ï¼‰+ ç¡¬ä»¶å®ç° + è½¯ä»¶å®ç°
	- è®¡ç®—æœºçš„åº”ç”¨ï¼šæ•°å­¦å»ºæ¨¡ï¼ˆç®—æ³•ï¼‰+ è½¯ä»¶å®ç°ï¼ˆç¼–ç¨‹ï¼‰
- è½¯ä»¶ï¼šè½¯ä»¶ = ç¨‹åº + æ–‡æ¡£
	- ç¨‹åº = æŒ‡ä»¤ï¼ˆç¼–ç¨‹è¯­è¨€ï¼‰+ æ•°æ®
	- ç¨‹åºé€šè¿‡è¯­è¨€çš„å½¢å¼å¯¹è®¡ç®—æœºç¡¬ä»¶çš„è¿è¡Œè¿›è¡ŒæŒ‡ä»¤ï¼Œä»¥è¾¾åˆ°è®¡ç®—çš„ç›®çš„ã€‚
- ç»“è®º
	- ç¼–ç¨‹è¯­è¨€å’Œç¨‹åºæ„æˆäº†è®¡ç®—æœºç§‘å­¦åŠè®¡ç®—çš„æ ¸å¿ƒ/çµé­‚ï¼›
	- ç¼–ç¨‹è¯­è¨€ä¸»è¦çš„ç ”ç©¶èŒƒå›´åœ¨äºå½¢å¼è¯­è¨€çš„è®¾è®¡åŠå®ç°ï¼Œå‰è€…ä¸»è¦æ¶‰åŠå¯¹åº”çš„æ•°å­¦çŸ¥è¯†ï¼Œåè€…è¿˜æ¶‰åŠè½¯ä»¶å·¥ç¨‹ï¼›
	- ç¨‹åºçš„ä¸»è¦ç ”ç©¶èŒƒå›´åœ¨äºç¨‹åºçš„è®¾è®¡åŠè¿è¡Œï¼Œå‰è€…æ¶‰åŠå…·ä½“çš„ç¼–ç¨‹è¯­è¨€å’Œç®—æ³•ï¼Œåè€…æ¶‰åŠè®¡ç®—æœºç¡¬ä»¶å’Œè½¯ä»¶çš„å·¥ä½œåŸç†ã€‚
#### Formal System & Language, Computer Language, and Programming Language
â†— [Language & Literature](../../Other%20Networks%20of%20Knowledge/Arts%20&%20Cultures/ğŸ“ƒ%20Language%20&%20Literature/Language%20&%20Literature.md) (the basic of information science)
â†— [Logic (and Critical Thinking)](../../Other%20Networks%20of%20Knowledge/â™‚%20Philosophy%20&%20Its%20History/Classical%20Philosophy/Western%20Philosophy%20&%20Its%20History/ğŸ¼%20Logic%20(and%20Critical%20Thinking)/Logic%20(and%20Critical%20Thinking).md) "reasoning (an informal approach)"

â†— [Mathematics](../ğŸ§®%20Mathematics/Mathematics.md) "axiomatization"
- â†— [Proof Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/Proof%20Theory/Proof%20Theory.md) "reasoning in formal way"
	- â†— [Gentzen-Style Proofs (Natural Deduction)](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/Proof%20Theory/Proof%20Calculus/Gentzen-Style%20Proofs%20(Natural%20Deduction).md)
â†— [Mathematical Logic Basics (Formal Logic)](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Mathematical%20Logic%20Basics%20(Formal%20Logic).md) "formalization"
- â†— [Classical Logic (Standard Logic)](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Classical%20Logic%20(Standard%20Logic)/Classical%20Logic%20(Standard%20Logic).md)
â†— [Automata Theory and (Formal) Language Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md) "construction of formal language"
â†— [Computability (Recursion) Theory - Turing Machine and R.E. Language](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/Computability%20(Recursion)%20Theory%20-%20Turing%20Machine%20and%20R.E.%20Language/Computability%20(Recursion)%20Theory%20-%20Turing%20Machine%20and%20R.E.%20Language.md) "computation as a formal language"

â†— [Computer Languages & Programming Methodology](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/Computer%20Languages%20&%20Programming%20Methodology.md)
- â†— [Programming Language Theory (PLT)](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Programming%20Language%20Theory%20(PLT).md)
â†— [Formal Syntax & Metasyntax (and Metalanguage)](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/ğŸ“Œ%20Formal%20Syntax%20&%20Metasyntax%20(and%20Metalanguage)/Formal%20Syntax%20&%20Metasyntax%20(and%20Metalanguage).md)
â†— [Formal Semantics and Programming Language](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Formal%20Semantics%20and%20Programming%20Language.md)

> The distinction between formal language theory and logic
> #formal_logic #formal_language
> 
> (Generated by Google AI mode)
> 
> It is critical to distinguish between classifying the grammar of a logical language and classifying the logic itself.Â 
> -  **Formal language theory**, which includes the Chomsky hierarchy, is concerned withÂ **syntax**. It asks whether a string of symbols is a valid formula.
> - **Logic**Â is concerned withÂ **semantics**Â and the rules of reasoning. It asks whether a valid formula is true or provable.Â 
> 
> For example, the syntax of a programming language like Python can be described by a context-free grammar. However, the program's actual logic, meaning, and behavior are not described by the Chomsky hierarchy. Similarly, a formal language used for logic (e.g., predicate calculus) can be classified on the hierarchy, but the classification says nothing about the logic's ability to express concepts like truth or validity.
#### Algorithm, Program, and Software
â†— [Algorithm & Data Structure](../ğŸ”‘%20CS%20Core/ğŸ§™â€â™‚ï¸%20Algorithm%20&%20Data%20Structure/Algorithm%20&%20Data%20Structure.md) (what is algorithm?)
â†— [Software (Program) Analysis Basics](../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/Software%20(Program)%20Analysis%20Basics.md) (what is program?)
â†— [Programming Language Processing & Program Execution](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/Programming%20Language%20Processing%20&%20Program%20Execution.md)
- â†— [Program Execution (Runtime)](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸ¤¡%20Program%20Execution%20(Runtime)/Program%20Execution%20(Runtime).md)
- â†— [Procedure (Function) Call & Runtime Memory Layout](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸ¤¡%20Program%20Execution%20(Runtime)/Procedure%20(Function)%20Call%20&%20Runtime%20Memory%20Layout.md)
â†— [Software Engineering](../Software%20Engineering/Software%20Engineering.md)


### Program Semantics, Abstraction, and Interpretation
â†— [Formal Semantics and Programming Language](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Formal%20Semantics%20and%20Programming%20Language.md)
â†— [Software (Program) Analysis Basics](../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/Software%20(Program)%20Analysis%20Basics.md)
- â†— [Program Abstraction & Abstract Interpretation /Intro](../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ‘š%20SCA%20(Static%20Code%20Analysis)%20&%20SAST/ğŸ›—%20Program%20Abstraction%20&%20Abstract%20Interpretation/Program%20Abstraction%20&%20Abstract%20Interpretation.md#Intro)

â†— [Theory of Computation /Models of Computation](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/Theory%20of%20Computation.md#Models%20of%20Computation)
â†— [(Formal) Model Checking](../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ™‡â€â™‚ï¸%20Formal%20Methods%20&%20Formal%20Verification%20(FV)/(Formal)%20Model%20Checking/(Formal)%20Model%20Checking.md)
- transition systems
- semantics of transition systems:
	- execution and traces
	- computational tree

 When we  assign meaning to other, we are giving "semantics". In programing language, programming language itself is a system of meaning. Likewise, we can invent many other systems with meaning, and map the meaning of programming language to this other system, i.e. giving semantics to programming language. This mapping is bilateral, meaning we can also say that the semantics of another system, say operational semantics, is its corresponding programming language.

Above mapping, or the action of assigning semantics, is interpretation. We can "interpret" a java program by its operational semantics, or "interpret" small step semantics from operational semantics as a transition system, or the reverse of these process. By default, we assume that during program interpretation we don't change the semantics, meaning we don't lose or add any information.

Program abstraction, is also a mapping between semantics. However, this time there is no guarantee that after mapping the original meaning (semantics) would not be altered. In fact,  the abstraction ($\to$) lose some information, and the concretion ($\leftarrow$, the reverse of abstraction) add some information. That being said, abstraction is still a very useful method to think about (interpret) the program, depending on your intention (what you want to interpret). Check out â†— [Program Abstraction & Abstract Interpretation /Intro](../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ‘š%20SCA%20(Static%20Code%20Analysis)%20&%20SAST/ğŸ›—%20Program%20Abstraction%20&%20Abstract%20Interpretation/Program%20Abstraction%20&%20Abstract%20Interpretation.md#Intro).



## ğŸ˜† Semantics of Program In General
ğŸ”¥ ğŸ¬ã€æ“ä½œç³»ç»Ÿä¸Šçš„ç¨‹åº (ä»€ä¹ˆæ˜¯ç¨‹åºå’Œç¼–è¯‘å™¨) [å—äº¬å¤§å­¦2022æ“ä½œç³»ç»Ÿ-P2]ã€‘ https://www.bilibili.com/video/BV12L4y1379V/?share_source=copy_web&vd_source=7740584ebdab35221363fc24d1582d9d

![Drawing 2025-09-09 22.37.45.excalidraw | 800](../../Assets/Illustrations/Computer%20Language/Language_and_Programming_Language_Processing.md)
<small>For different levels in code analysis, we use different computational models. </small>


### ğŸ“Œ Operational Semantics, Transition System, and Computation Trace
â†— [Mathematical Logic (Foundations of Mathematics)](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/Mathematical%20Logic%20(Foundations%20of%20Mathematics).md)
â†— [Mathematical Logic Basics (Formal Logic)](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Mathematical%20Logic%20Basics%20(Formal%20Logic).md)
- â†— [Set Theory & Axiomatic Set Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ›’%20Set%20Theory%20&%20Axiomatic%20Set%20Theory/Set%20Theory%20&%20Axiomatic%20Set%20Theory.md)
- â†— [Automata Theory and (Formal) Language Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)

> ğŸ”— https://courses.compute.dtu.dk/02242/topics/semantics.html##sec:2.1

**1. Program Semantics**
Program semantics is about assigning meaning to programs. When we can talk about what a piece of syntax mean, it is easier to explain what a program does.

We are going to discuss some different approaches to writing down the semantics of a program.  ==They all essentially turn programs syntax into mathematical logic.==

â†— [Mathematical Logic Basics (Formal Logic) /Semantic & The Semantics of Mathematical Logics](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Mathematical%20Logic%20Basics%20(Formal%20Logic).md#Semantic%20&%20The%20Semantics%20of%20Mathematical%20Logics)


**2. Prerequisite: Mathematical Logic Languages & Natural Deduction**
â†— [Mathematical Logic Basics (Formal Logic)](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Mathematical%20Logic%20Basics%20(Formal%20Logic).md)
â†— [Gentzen-Style Proofs (Natural Deduction)](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/Proof%20Theory/Proof%20Calculus/Gentzen-Style%20Proofs%20(Natural%20Deduction).md)

> ğŸ”— https://courses.compute.dtu.dk/02242/topics/semantics.html##sec:2.1

If you are unfamiliar with Natural Deduction and Gentzen-style proofs, please refer toÂ [the Wikipedia page](https://en.wikipedia.org/wiki/Natural_deduction)Â on the topic. The sort story is that we refer to logical rules like this: $$\frac{Premise_1, ... Premise_n}{Conclusion}(name)$$

Which means thatÂ $(Premise_1 \land ... \land Premise_n)$Â impliesÂ $Conclusion$.

If we want multiple ways of reaching the conclusion, we can make more rules. For example, conjunctionÂ $A\land B$Â only requires one rule, bothÂ AÂ andÂ BÂ has to be true, while disjunctionÂ $A\lor B$Â has two rules: eitherÂ AÂ has to be true orÂ BÂ has to be true. $$\frac{AB}{Aâˆ§B}(âˆ§)\frac{A}{Aâˆ¨B}(âˆ¨L)\frac{B}{Aâˆ¨B}(âˆ¨R)$$
In natural deduction, we build up syntactic objects which represents the truth of some event. We call themÂ _judgements_. Many times you will see them written likeÂ $x\vdash y$, which is basically $\frac{x}{y}$ in its original Gentzen-style proofs. This is read: in the context ofÂ x, (we can infer)Â yÂ is true. 


**3. Formal Semantics of Program Language**
â†— [Formal Semantics and Programming Language](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Formal%20Semantics%20and%20Programming%20Language.md)
- â†— [Axiomatic Semantics (Hoare-Style Logic)](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Axiomatic%20Semantics%20(Hoare-Style%20Logic).md)
- â†— [Denotational Semantics](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Denotational%20Semantics.md)
- â†— [Operational Semantics](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Operational%20Semantics.md)


**Operational Semantics**
> â†— [Operational Semantics](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Operational%20Semantics.md)

> ğŸ”— [Operational semantics - Wikipedia](https://en.wikipedia.org/wiki/Operational_semantics)
> ğŸ”— [Plotkin (2004)](https://courses.compute.dtu.dk/02242/topics/semantics.html#ref:plotkin2004origins)
> ğŸ”— [A structural approach to operational semantics - Plotkin](https://www.cs.cmu.edu/~crary/819-f09/Plotkin81.pdf)

==Operational semantics describes the semantic of a program as changes to a state.== This makes it ideal for describing **imperative languages** like the JVM bytecode.

**Structural Operational Semantics/Â Small Step Semantics**
TheÂ _Structural Operational Semantics_Â orÂ _Small Step Semantics_Â are written as judgments of the typeÂ ($\psi\vdash (\sigmaâ†’\overset{-}{\sigma})$)Â which means given the environmentÂ $\psi$, the state of the programÂ $\sigma$Â can be turned intoÂ $\overset{-}{\sigma}$.

The reason we call this approach the small step semantics is that we only execute a single operation at a time.

**Natural Operational Semantics orÂ Big Step Semantics**
TheÂ _Natural Operational Semantics_Â orÂ _Big Step Semantics_, are describing running the program until it halts.Â $(\psi\vdash(\sigma\downarrow v)$Â whereÂ $v$Â is the final value of the program. Big step semantics often looks nicer than small step semantics, because it does not have to care about execution order.

Big Step semantics have the benefit of being easier to read, however, it has some big disadvantages, namely: we cannot reason about programs that run forever, and we cannot turn big step semantics into a working implementation. In contrast, small step semantics are easy to convert into an interpreter, and we can always recover the big step semantics from the operational semantics by simply applying the single step semantics until the program terminates with a value: $$\frac{\psi\vdash (\sigma\to\overset{-}{\sigma}), \ \  \psi\vdash(\overset{-}{\sigma}\downarrow v)}{\psi\vdash(\sigma\downarrow v)}(step) \ \ \ \frac{\psi\vdash (\sigma\to v)}{\psi\vdash(\sigma\downarrow v)}(done)$$

Â 
**4. Transition System** (in Kripe Structure)
Using operational semantics, we can define the meaning of a programÂ $P$Â as aÂ Transition System:

(â†— [(Formal) Model Checking /1ï¸âƒ£ System Modeling](../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ™‡â€â™‚ï¸%20Formal%20Methods%20&%20Formal%20Verification%20(FV)/(Formal)%20Model%20Checking/(Formal)%20Model%20Checking.md#1ï¸âƒ£%20System%20Modeling))
A transition system $TS$ is a tuple $(S,Act,\to,I,AP,L)$ where
- $S$ is a set of states,
- $Act$ is a set of actions,
- $\to \subseteq S \times Act \times S$ is a transition relation,
	-  or use $\delta$ to express $\to$
- $I \subseteq S$ is a set of initial states,
	- $\sigma\in I$
	- or, when using $\tau$ or $\pi$ to symbol a trace on $TS$, $\tau_0 = \sigma \in I$ or $\pi_0=\sigma\in I$
- $AP$ is a set of atomic propositions, 
- $L$: $Sâ†’AP^2$ is a labeling function.

$TS$ is called **finite** if $S$, $Act$, and $AP$ are **finite**.

It is important to realize that in case a state has more than one outgoing transition, the
â€œnextâ€ transition is chosen in a purely **nondeterministic** fashion. That is, the outcome of
this selection process is not known a priori, and, hence, no statement can be made about the likelihood with which a certain transition is selected. Similarly, when the set of initial states consists of more than one state, the start state is selected nondeterministically.

For convenience, we write $s \xrightarrow[]{\alpha}s'$ instead of $(s,Î±,s') \in \to$.

The labeling function $L$ relates a set $L(s) \in AP^2$ of atomic propositions to any state $s$. $L(s)$ intuitively stands for exactly those atomic propositions $a \in AP$ which are satisfied by state $s$. Given that $Î¦$ is a propositional logic formula, then $s$ satisfies the formula $Î¦$ if the evaluation induced by $L(s)$ makes the formula Î¦ true; that is: $s \models \Phi \iff L(s) \models \Phi$.


**5. Traces and Maximal Trace Semantics**
AÂ $Trace_P$Â is the possible infinite sequence of states and operations of the program. $Trace_P=(States_P)^{*}$

The meaning of a program is now the set of traces that it exhibit:
 - $Semantics: Program \to 2^{Trace}$, or
 - $Sem(P)= \{\tau \in (State_P)^n ~Â | ~Â n \in [1,âˆ], ~ \tau_0 \in I_P, ~ \forall i \in [1, nâˆ’1], ~ \theta_P(\tau_{iâˆ’1},\tau_i) \}$

This is also called theÂ **Maximal Trace Semantics**. We can now define properties, like does a program halt, using relatively well defined math: $\mathcal{L}_{halt}= \{P ~ |Â ~ â¡P \in \mathcal{L}, ~ \forall \tau \in Sem(P), ~ |\tau|\neq \infty \}$, where $\mathcal{L}$ stands for Language. (â†— [Automata Theory and (Formal) Language Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md))
#### Mathematical Model of Computer: Turing Machine
â†— [Computability (Recursion) Theory - Turing Machine and R.E. Language](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/Computability%20(Recursion)%20Theory%20-%20Turing%20Machine%20and%20R.E.%20Language/Computability%20(Recursion)%20Theory%20-%20Turing%20Machine%20and%20R.E.%20Language.md)


### Digital Circuits Semantics as State Machine (Transition System)
çŠ¶æ€ = å¯„å­˜å™¨ä¿å­˜çš„å€¼ (flip-flop)
åˆå§‹çŠ¶æ€ = RESET (implementation dependent)
è¿ç§» = ç»„åˆé€»è¾‘ç”µè·¯è®¡ç®—å¯„å­˜å™¨ä¸‹ä¸€å‘¨æœŸçš„å€¼


### Programming Languages Semantics as State Machine (Transition System) -- C Language and OS for example
> â†— [Automata Theory and (Formal) Language Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)
> - Push-Down Automaton (PDA)
> 
> â†— [Formal Semantics and Programming Language](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Formal%20Semantics%20and%20Programming%20Language.md)
#### 1ï¸âƒ£ Program's State Machine: Application Perspective
C ç¨‹åºçš„çŠ¶æ€æœºæ¨¡å‹1 (è¯­ä¹‰ï¼Œsemantics)
- çŠ¶æ€ = å † + æ ˆ
- åˆå§‹çŠ¶æ€ =Â `main`Â çš„ç¬¬ä¸€æ¡è¯­å¥
- è¿ç§» = æ‰§è¡Œä¸€æ¡ç®€å•Cè¯­å¥
    - ä»»ä½• C ç¨‹åºéƒ½å¯ä»¥æ”¹å†™æˆ â€œéå¤åˆè¯­å¥â€ çš„ C ä»£ç  (æ²¡æœ‰å‡½æ•°è°ƒç”¨)
    - [çœŸçš„æœ‰è¿™ç§å·¥å…·](https://cil-project.github.io/cil/)Â (C Intermediate Language) å’Œ[è§£é‡Šå™¨](https://gitlab.com/zsaleeba/picoc)

C ç¨‹åºçš„çŠ¶æ€æœºæ¨¡å‹2 (è¯­ä¹‰ï¼Œsemantics)
- çŠ¶æ€ = stack frame çš„åˆ—è¡¨ (æ¯ä¸ª frame æœ‰ PC) + å…¨å±€å˜é‡(å †)
- åˆå§‹çŠ¶æ€ = main(argc, argv), å…¨å±€å˜é‡åˆå§‹åŒ–
- è¿ç§» = æ‰§è¡Œ top stack frame PC çš„è¯­å¥; PC++
    - å‡½æ•°è°ƒç”¨ = push frame (frame.PC = å…¥å£)
    - å‡½æ•°è¿”å› = pop frame

åº”ç”¨ï¼šå°†ä»»ä½•é€’å½’ç¨‹åºå°±åœ°è½¬ä¸ºéé€’å½’
#### 2ï¸âƒ£ Program's State Machine: CPU(Computer) Perspective
C ç¨‹åºçš„çŠ¶æ€æœºæ¨¡å‹3 (è¯­ä¹‰ï¼Œsemantics)
- çŠ¶æ€ = å†…å­˜Â MMÂ + å¯„å­˜å™¨Â RR
- åˆå§‹çŠ¶æ€ = (ç¨åå›ç­”)
- è¿ç§» = æ‰§è¡Œä¸€æ¡æŒ‡ä»¤
#### Application Program and OS Program
> â†— [Operating System & OS Kernel (Theory Part)](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part).md)
> â†— [Operating Systems & Kernels (Engineering Part)](../ğŸ”‘%20CS%20Core/ğŸ¥·ğŸ¼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Operating%20Systems%20&%20Kernels%20(Engineering%20Part).md)
> â†— [Operating System Kernel (Kernel Mode)](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/ğŸ˜´%20Operating%20System%20Components%20&%20Runtime%20Libraries/Operating%20System%20Kernel%20(Kernel%20Mode).md)
> â†— [System Calls](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/OS%20Processes%20&%20Automata%20Management%20(CPU%20+%20Main%20Memory%20Resource)/ğŸ“Œ%20Processes%20Description%20&%20Control/System%20Calls/System%20Calls.md)
> â†— [Interrupts (Software & Hardware)](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸ¤¡%20Program%20Execution%20(Runtime)/Instruction%20Execution/Interrupts%20(Software%20&%20Hardware).md)

æ“ä½œç³»ç»Ÿä¸Šçš„ç¨‹åº:
- æ‰€æœ‰çš„æŒ‡ä»¤éƒ½åªèƒ½è®¡ç®—
	- deterministic: `mov`, `add`, `sub`, `call`, ...
	- non-deterministic: `rdrand`, ...
	- ä½†è¿™äº›æŒ‡ä»¤ç”šè‡³éƒ½æ— æ³•ä½¿ç¨‹åºåœä¸‹æ¥ (NEMU: åŠ æ¡Â `trap`Â æŒ‡ä»¤)
- è°ƒç”¨æ“ä½œç³»ç»ŸÂ `syscall`
	- æŠŠÂ `(M,R)`å®Œå…¨äº¤ç»™æ“ä½œç³»ç»Ÿï¼Œä»»å…¶ä¿®æ”¹
	    - ä¸€ä¸ªæœ‰è¶£çš„é—®é¢˜ï¼šå¦‚æœç¨‹åºä¸æ‰“ç®—å®Œå…¨ä¿¡ä»»æ“ä½œç³»ç»Ÿï¼Ÿ
	- å®ç°ä¸æ“ä½œç³»ç»Ÿä¸­çš„å…¶ä»–å¯¹è±¡äº¤äº’
	    - è¯»å†™æ–‡ä»¶/æ“ä½œç³»ç»ŸçŠ¶æ€ (ä¾‹å¦‚æŠŠæ–‡ä»¶å†…å®¹å†™å…¥Â MM)
	    - æ”¹å˜è¿›ç¨‹ (è¿è¡Œä¸­çŠ¶æ€æœº) çš„çŠ¶æ€ï¼Œä¾‹å¦‚åˆ›å»ºè¿›ç¨‹/é”€æ¯è‡ªå·±

==æ“ä½œç³»ç»Ÿä¸Šçš„åº”ç”¨ç¨‹åº = è®¡ç®— + `syscall`==
- ç¨‹åº = è®¡ç®— â†’ `syscall` â†’ è®¡ç®— â†’ ...
	- è¢«æ“ä½œç³»ç»ŸåŠ è½½
		- é€šè¿‡å¦ä¸€ä¸ªè¿›ç¨‹æ‰§è¡Œ `execve` è®¾ç½®ä¸ºåˆå§‹çŠ¶æ€
	- çŠ¶æ€æœºæ‰§è¡Œ
		- è¿›ç¨‹ç®¡ç†ï¼š`fork`, `execve`, `exit`, ...
		- æ–‡ä»¶/è®¾å¤‡ç®¡ç†ï¼š`open`, `close`, `read`, `write`, ...
		- å­˜å‚¨ç®¡ç†ï¼š`mmap`, `brk`, ...
	- ç›´åˆ° `_exit (exit_group)` é€€å‡º
- ğŸ’€ é—®é¢˜ï¼šæ€ä¹ˆæ„é€ ä¸€ä¸ªæœ€å°çš„ Hello, Worldï¼Ÿ
- ğŸ’€ é—®é¢˜ï¼šä¸€ä¸ªæ™®é€šçš„ã€äººç•œæ— å®³çš„ Hello World C ç¨‹åºæ‰§è¡Œçš„ç¬¬ä¸€æ¡æŒ‡ä»¤åœ¨å“ªé‡Œï¼Ÿ /â€œäºŒè¿›åˆ¶ç¨‹åºçŠ¶æ€æœºçš„åˆå§‹çŠ¶æ€æ˜¯ä»€ä¹ˆï¼Ÿâ€ (â†— [Intro to Computer Science /Questions Leading my CS Study](ğŸ’‹%20Intro%20to%20Computer%20Science/Intro%20to%20Computer%20Science.md#Questions%20Leading%20my%20CS%20Study))
	- `ld-linux-x86-64.so`Â åŠ è½½äº† libc
		- ä¹‹å libc å®Œæˆäº†è‡ªå·±çš„åˆå§‹åŒ–
	    - RTFM:Â [libc startup](https://www.gnu.org/software/hurd/glibc/startup.html)Â on Hurd
	    - `main()`Â çš„å¼€å§‹/ç»“æŸå¹¶ä¸æ˜¯æ•´ä¸ªç¨‹åºçš„å¼€å§‹/ç»“æŸ
	    - ä¾‹å­ï¼š[hello-goodbye.c](https://jyywiki.cn/pages/OS/2022/demos/hello-goodbye.c)
	- è°è§„å®šæ˜¯Â `ld-linux-x86-64.so`ï¼Œè€Œä¸æ˜¯Â `xxxx.so`?
		- `readelf` å‘Šè¯‰ä½ ç­”æ¡ˆ

==æ“ä½œç³»ç»Ÿä¸Šçš„åº”ç”¨ç¨‹åºï¼šéƒ½åœ¨æ“ä½œç³»ç»Ÿ APIÂ (syscall) å’Œæ“ä½œç³»ç»Ÿä¸­çš„å¯¹è±¡ä¸Šæ„å»º==
- ç¼–è¯‘å™¨ (gcc)ï¼Œä»£è¡¨å…¶ä»–å·¥å…·ç¨‹åº
	- ä¸»è¦çš„ç³»ç»Ÿè°ƒç”¨ï¼šexecve, read, write
	- `strace -f gcc a.c`Â (gcc ä¼šå¯åŠ¨å…¶ä»–è¿›ç¨‹)
		- å¯ä»¥ç®¡é“ç»™ç¼–è¾‘å™¨Â `vim -`
		- ç¼–è¾‘å™¨é‡Œè¿˜å¯ä»¥Â `%!grep`Â (ç»†èŠ‚/æŠ€å·§)
- å›¾å½¢ç•Œé¢ç¨‹åº (xedit)ï¼Œä»£è¡¨å…¶ä»–å›¾å½¢ç•Œé¢ç¨‹åº (ä¾‹å¦‚ vscode)
	- ä¸»è¦çš„ç³»ç»Ÿè°ƒç”¨ï¼š`poll`, `recvmsg`, `writev`
	- `strace xedit`
	    - å›¾å½¢ç•Œé¢ç¨‹åºå’Œ X-Window æœåŠ¡å™¨æŒ‰ç…§ X11 åè®®é€šä¿¡
	    - è™šæ‹Ÿæœºä¸­çš„ `xedit` å°† X11 å‘½ä»¤é€šè¿‡ ssh (X11 forwarding) è½¬å‘åˆ° Host
- çª—å£ç®¡ç†å™¨
    - ç®¡ç†è®¾å¤‡å’Œå±å¹• (`read`/`write`/`mmap`)
    - è¿›ç¨‹é—´é€šä¿¡ (`send`, `recv`)
- ä»»åŠ¡ç®¡ç†å™¨
    - è®¿é—®æ“ä½œç³»ç»Ÿæä¾›çš„è¿›ç¨‹å¯¹è±¡ (`readdir`/`read`)
    - å‚è€ƒ gdb é‡Œçš„Â `info proc *`
- æ€æ¯’è½¯ä»¶
    - æ–‡ä»¶é™æ€æ‰«æ (`read`)
    - ä¸»åŠ¨é˜²å¾¡ (`ptrace`)
    - å…¶ä»–æ›´å¤æ‚çš„å®‰å…¨æœºåˆ¶â€¦â€¦


### Compilation: Switch /Transfer Between Program's State Machine
> â†— [Automata Theory and (Formal) Language Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)
> â†— [Programming Language Processing & Program Execution](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/Programming%20Language%20Processing%20&%20Program%20Execution.md)
> â†— [Compilation Phase](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸš®%20Program%20Language%20Processing%20&%20Compilation%20Theory%20(Compile-time)/Compilation%20Phase/Compilation%20Phase.md)
> â†— [Compilation & Program Loading Tools](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ› ï¸%20Programming%20Tool%20Chain/Compilation%20&%20Program%20Loading%20Tools/Compilation%20&%20Program%20Loading%20Tools.md)

![Language_and_Programming_Language_Processing | 800](../../Assets/Illustrations/Computer%20Language/Language_and_Programming_Language_Processing.md)

ç¼–è¯‘å™¨ï¼šæºä»£ç Â $S$Â (çŠ¶æ€æœº) â†’ äºŒè¿›åˆ¶ä»£ç Â $C$Â (çŠ¶æ€æœº) $$C=compile(S)$$
ç¼–è¯‘ (ä¼˜åŒ–) çš„æ­£ç¡®æ€§ (Soundness):Â 
- $S$Â ä¸Â $C$Â çš„å¯è§‚æµ‹è¡Œä¸ºä¸¥æ ¼ä¸€è‡´
    - system calls; volatile variable loads/stores; termination
- Trivially æ­£ç¡® (ä½†ä½æ•ˆ) çš„å®ç°
    - è§£é‡Šæ‰§è¡Œ/ç›´æ¥ç¿»è¯‘Â $S$Â çš„è¯­ä¹‰

ç°ä»£ (ä¸æœªæ¥çš„) ç¼–è¯‘ä¼˜åŒ–: 
- åœ¨ä¿è¯è§‚æµ‹ä¸€è‡´æ€§ (sound) çš„å‰æä¸‹æ”¹å†™ä»£ç  (rewriting)
	- Inline assembly ä¹Ÿå¯ä»¥å‚ä¸ä¼˜åŒ–
	    - å…¶ä»–ä¼˜åŒ–å¯èƒ½ä¼šè·¨è¿‡ä¸å¸¦ barrier çš„Â `asm volatile`
	- Eventual memory consistency
	- Call to external CU = write back visible memory
- è¿™ç»™äº†æˆ‘ä»¬å¾ˆå¤šæƒ³è±¡çš„ç©ºé—´
	- Semantic-based compilation (synthesis)
	- AI-based rewriting
	- Fine-grained semantics & system call fusion

> [An executable formal semantics of C with applications](https://dl.acm.org/doi/10.1145/2103621.2103719)Â (POPL'12)
> [CompCert C verified compiler](https://compcert.org/motivations.html)Â and aÂ [paper](https://xavierleroy.org/publi/compcert-backend.pdf)Â (POPL'06, Most Influential Paper Award ğŸ…)
> [Copy-and-patch compilation](https://dl.acm.org/doi/10.1145/3485513)Â (OOPSLA'21, Distinguished Paper ğŸ…)



## ğŸ¥¸ Semantics of Program - Programming Language Specific

â†— [Computer Languages & Programming Methodology](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/Computer%20Languages%20&%20Programming%20Methodology.md)

â†— [CPU (Central Processing Unit)](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Computer%20Architecture/Computer%20Microarchitectures%20(Computer%20Organization)%20&%20von%20Neumann%20Model/ğŸš¦%20Computer%20Processors%20&%20Logic%20Chips/ğŸ“Œ%20Microprocessor%20&%20Microprocessors%20Unit%20(MPU)/CPU%20(Central%20Processing%20Unit)/CPU%20(Central%20Processing%20Unit).md)
â†— [Address Space & Memory Layout](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/OS%20Memory%20Management%20(Main%20Memory%20+%20Secondary%20Memory%20Resource)/Address%20Space%20&%20Memory%20Layout.md)
â†— [Program Execution (Runtime)](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸ¤¡%20Program%20Execution%20(Runtime)/Program%20Execution%20(Runtime).md)
â†— [Procedure (Function) Call & Runtime Memory Layout](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸ¤¡%20Program%20Execution%20(Runtime)/Procedure%20(Function)%20Call%20&%20Runtime%20Memory%20Layout.md)

![](../../../../../../../../../Assets/Pics/Screenshot%202023-03-02%20at%204.11.10%20PM.png)
<small>Computer Components: Top-Level View</small>

![|450](../../../../Assets/Pics/Pasted%20image%2020250303220015.png)
![application_execution_and_computer_data_flow.excalidraw | 800](../../Assets/Illustrations/Computer%20System/application_execution_and_computer_data_flow.excalidraw.md)
<small>Dynamic code analysis</small>


### Declarative Programming Paradigm
#### Haskell
â†— [Haskell](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/Other%20Languages%20for%20Specific%20Areas/Functional%20Programming%20Languages/Haskell/Haskell.md)


### Imperative Programming Paradigm and Semantics as Transition Systems
#### Java and Java Bytecode
> â†— [Computer Languages & Programming Methodology](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/Computer%20Languages%20&%20Programming%20Methodology.md)
> â†— [Java](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/Compiled%20+%20Interpreted%20Languages/âš°ï¸%20JVM-Based%20Languages/â˜•ï¸%20Java/Java.md)
> â†— [Java Bytecode](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ASM%20(Assembly%20Languages)/ğŸŒ™%20Hardware-Independent%20ASM%20&%20Bytecode%20Sets/Java%20Bytecode/Java%20Bytecode.md)
> â†— [JVM Instrument Set & Java Bytecode](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Computer%20Architecture/Instruction%20Set%20Architecture%20(ISA)%20&%20Processor%20Architecture/RISC%20(Reduced%20Instruction%20Set%20Computer)/JVM%20Instrument%20Set%20&%20Java%20Bytecode/JVM%20Instrument%20Set%20&%20Java%20Bytecode.md)

> ğŸ”— https://courses.compute.dtu.dk/02242/topics/semantics.html#sec:jvm-semantics

In this section, we are going to introduce some of the semantics of a limited JVM. It is incomplete and you would have to complete it on your own.

The goal of this section is to define the **small step semantics** of the JVM, and encode it in both math and in Python. You can follow along with the code inÂ [`solutions/interpreter.py`](https://github.com/kalhauge/jpamb/blob/main/solutions/interpreter.py).

In math, we want to define judgments of $bc\vdash(s\to\overset{-}{s})$,Â $bc\vdash(s\to ok)$, orÂ $bc\vdash (s\to err(\text{â€˜ğš–ğšœğšâ€™}))$, whereÂ $bc$Â is the bytecode andÂ $s$Â is the state. And, in Python we want to define a functionÂ `step`, which given a stateÂ sÂ computes either a new stateÂ sÂ or aÂ doneÂ string.

```Python
def step(s : State) -> State | str:
    ...
```


**TL;DR - Java Bytecode Small Step Semantics as Transition System**
(Remember this statement? A program = data + instruction)

There are many formal semantics. Small step semantics is a kind of operational semantics. Transition system is a representation we use to express semantics. In a word, for a programming language, there are multiple (formal) semantics to interpret it, while there are also multiple representation systems to express such interpretation. They - programming language, semantics, and representation system - are not bounded to each other.

**State**: values $V$
- $V = âŸ¨\eta, \ \muâŸ©$, where $\eta$ is the heap (global values $V_\eta$ shared across frames), and $\mu$ is the stack of frames (call stack) $\mu = \epsilon \ âŸ¨\lambda_1, \sigma_1,\iota_1âŸ© \ âŸ¨\lambda_2, \sigma_2,\iota_2âŸ© \ \cdots \ âŸ¨\lambda_n, \sigma_n,\iota_nâŸ©$ whose values are all stack values $V_\sigma$.
	- $\epsilon$ is the symbol we put at the bottom of the stack to indicate an empty stack. Whenever a stack pops out all items it have, the $\epsilon$ appear to be the top element. Hence, by checking wether the top element equals to $\epsilon$, we know wether we hit the bottom of the stack or not.
	- In a frame stack $âŸ¨\lambda, \sigma,\iotaâŸ©$:
		- $\lambda$ is an array of local data ($\lambda = [v_1, v_2, ...], \ v_i\in V_\sigma$). Array means the values are fetched by index.
		- $\sigma$ is a stack, or more specifically an operand stack ($\sigma=\epsilon \ o_1 \ o_2 \ o_3 \ ..., \ o_i \in V_\sigma$). Stack means the values are fetched FCLS.
		- $\iota$ is a single stack value $\iota \in V_\sigma$ representing PC (the value of memory address of next instruction to be executed).
	- Frame stack $\mu$ consists of stacks of frames $\{âŸ¨\lambda_i, \sigma_i,\iota_iâŸ©\}$.
**Transition**: execution of one instruction of PC ($\iota$): $V \overset{bc[\iota]}{\to} V'$, or $âŸ¨\eta, \ \muâŸ© \overset{bc[\iota]}{\to} âŸ¨\eta, \ \muâŸ©'$
- Different instructions have different behaviors in changing $V$ to $V'$. See â†— [JVM Instrument Set & Java Bytecode](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Computer%20Architecture/Instruction%20Set%20Architecture%20(ISA)%20&%20Processor%20Architecture/RISC%20(Reduced%20Instruction%20Set%20Computer)/JVM%20Instrument%20Set%20&%20Java%20Bytecode/JVM%20Instrument%20Set%20&%20Java%20Bytecode.md) for the instruction set.

For example, we look at below decompiled `.class` file of java bytecde:
TBD.

Below â¬‡ï¸ are the explanation of above semantics, with more detailed examples


**The Context and the Program Counter**
As with all single step semantics rules, the JVM is run in a context. This context is the bytecode $bc$. For now we will define a simple operationÂ $bc[\iota]$Â which looks up the bytecode instruction atÂ $\iota$.Â $\iota$Â is program counter, i.e., the name of the **method** and the **offset** in that method.

We use the following short hands: $$\begin{aligned} & \iota =âŸ¨\iota_m,\iota_oâŸ© \\ 
& \iota+n=âŸ¨\iota_m,\iota_o+nâŸ© \\
& n/\iota=âŸ¨\iota_m,nâŸ©
\end{aligned}$$
To do this in Python you can should do something like this:

```python
@dataclass
class PC:
    method: jvm.AbsMethodID
    offset: int

    def __iadd__(self, delta):
        self.offset += delta
        return self

    def __add__(self, delta):
        return PC(self.method, self.offset + delta)

    def __str__(self):
        return f"{self.method}:{self.offset}"


@dataclass
class Bytecode:
    suite: jpamb.Suite
    methods: dict[jvm.AbsMethodID, list[jvm.Opcode]]

    def __getitem__(self, pc: PC) -> jvm.Opcode:
        try:
            opcodes = self.methods[pc.method]
        except KeyError:
            opcodes = list(self.suite.method_opcodes(pc.method))
            self.methods[pc.method] = opcodes

        return opcodes[pc.offset]
```



**The Values (Locals and Heap), Operand (Operator) Stack**
It's all about the values (data as in data vs instruction) in a code.

The JVM is a **stack based virtual machine**, which means that instead of using *named variables* (registers) to store **intermediate values**, it uses an **operand stack (or operator stack)**. Intermediate values are those that generated during an execution (expression evaluation) and weren't explicitly declared by code. Besides intermediate values, there are values explicitly declared by the code. For these values, those that stored local to the methods are called **locals**, which can be accessed using indices, while values that stored in global memory and shared across methods is referred to as the **heap**.

The values in (our interpretation of) JVM are dynamically typed, this means that every value caries around information about its type. There are two kinds of values, stack valuesÂ $V_\sigma$Â and heap valuesÂ $V_\eta$. $$\begin{aligned} & V_\sigma := (\mathcal{int} \ n) \ | \ (\mathcal{float} \ f) \ | \ (\mathcal{ref} \ r) \\
& V_\eta := V_\sigma \ | \ (\mathcal{byte} \ b) \ | \ (\mathcal{char} \ c) \ | \ (\mathcal{short} \ s) \ | \ (\mathcal{array} \ t \ a) \ | \ (\mathcal{object} \ cn \ fs)\end{aligned}$$
The stack contains ints are signed 32 bit integers, floats are 32 bit floating point values (IEEE 754 Standard), and references to the heap which are only 32 bits.

The heap can contain values from the stack, as well as bytes and chars that are 8 bits and 16 bits unsigned respectively, shorts are signed 16 bits, and arrays which a type and list of values, and objects which has a name and the values of the fields, which is a mapping from names to heap values.

> In this course we'll not coverÂ **long**Â andÂ **double**Â as they are a pain in the \*ss. Furthermore, we'll try to avoid inner classes and bootstrap methods as well.

Implementations of the values and types are stored in theÂ [jpamb.jvm.Value](https://courses.compute.dtu.dk/02242/topics/semantics.html#https://github.com/kalhauge/jpamb/blob/main/jpamb/jvm/base.py).

The stack is a list of values:Â $\sigma=(V_\sigma)^*$.Â $\epsilon$Â denote the empty stack and we add and remove elements from the end of the stack. A stack with the integers 1, 2, and 3, looks like this:Â $\sigma = \epsilon \ (\mathcal{int} \ 1)(\mathcal{int} \ 2)(\mathcal{int} \ 3)$. A simple implementation of this in python can be done like this:

```python
@dataclass
class Stack[T]:
    items: list[T]

    def __bool__(self) -> bool:
        return len(self.items) > 0

    @classmethod
    def empty(cls):
        return cls([])

    def peek(self) -> T:
        return self.items[-1]

    def pop(self) -> T:
        return self.items.pop(-1)

    def push(self, value):
        self.items.append(value)
        return self

    def __str__(self):
        if not self:
            return "Ïµ"
        return "".join(f"{v}" for v in self.items)
```


---
> ğŸ¤– ChatGPT 5 

The **operand stack (Ïƒ)** is where bytecode instructions temporarily **push and pop values** while evaluating expressions or performing computations. It is **not** the same as the call stack â€” instead, itâ€™s used _within_ a single method to hold intermediate results.

Consider this Java code: 
```
int x = 2;
int y = 3;
int z = x + y;
```

The compiled bytecode might look like:
```
iconst_2         // push int 2
istore_1         // store into local variable 1 (x)
iconst_3         // push int 3
istore_2         // store into local variable 2 (y)
iload_1          // push x (2) onto stack
iload_2          // push y (3) onto stack
iadd             // pop top two ints (2, 3), add them, push result (5)
istore_3         // pop 5 from stack, store into local variable 3 (z)

```

Now, step-by-step, hereâ€™s what happens to **Ïƒ**:

| Instruction | Operand Stack (Ïƒ) Before | Operand Stack (Ïƒ) After | Description                 |
| ----------- | ------------------------ | ----------------------- | --------------------------- |
| `iconst_2`  | `[]`                     | `[2]`                   | push 2                      |
| `istore_1`  | `[2]`                    | `[]`                    | pop 2 â†’ store into local[1] |
| `iconst_3`  | `[]`                     | `[3]`                   | push 3                      |
| `istore_2`  | `[3]`                    | `[]`                    | pop 3 â†’ store into local[2] |
| `iload_1`   | `[]`                     | `[2]`                   | push local[1]               |
| `iload_2`   | `[2]`                    | `[2, 3]`                | push local[2]               |
| `iadd`      | `[2, 3]`                 | `[5]`                   | pop 3 and 2, push 5         |
| `istore_3`  | `[5]`                    | `[]`                    | pop 5 â†’ store into local[3] |

So Ïƒ is simply the **temporary workspace** where bytecode instructions manipulate data.

Each bytecode instruction **operates on operands**, which it **pops** from Ïƒ, performs an operation, and possibly **pushes** a result back.  
For example:
- `iadd`: pops 2 ints, pushes their sum.
- `imul`: pops 2 ints, pushes their product.
- `if_icmpge`: pops 2 ints, compares them, possibly changes `Î¹` (the program counter).

Thatâ€™s why itâ€™s called an **operand stack** â€” it holds the **operands** (inputs) for the current operation.

---
JVM saves local variables of typeÂ $V_\sigma$Â to a local arrayÂ $\lambda$. This is were the inputs to the method goes and any data that should be saved on the method stack instead of in the heap. The local array is indexed normallyÂ $\lambda[0]$.

In its simplest form, the state of the JVM is a tripletÂ $âŸ¨\lambda,\sigma,\iotaâŸ©$Â which we will call a frame, whereÂ $\lambda$Â is an array that stores all the locals,Â $\sigma$Â is the operand stack andÂ $\iota$Â is the program counter.

In Python, we would write:
```Python
@dataclass
class Frame:
    locals: dict[int, jvm.Value]
    stack: Stack[jvm.Value]
    pc: PC

    def __str__(self):
        locals = ", ".join(f"{k}:{v}" for k, v in self.locals.items())
        return f"<{{{locals}}}, {self.stack}, {self.pc}>"
```



**The Simplified Stepping Function - On Current Frame (Current Method/Procedure Execution) Only**
Most of our operations only operate on one frame (no method/procedure calls, executing within single method/procedure), so we can already define our first simple SOS judgment on one frame: $$ğš‹ğšŒâŠ¢âŸ¨Î»,Ïƒ,Î¹âŸ©â†’âŸ¨\overset{-}{Î»},\overset{-}{Ïƒ},\overset{-}{Î¹}âŸ©$$
Anticipating the definition ofÂ `State`Â in the next section, we define the stepping function, like so:

```Python
def step(state: State) -> State | str:
    frame = state.frames.peek() # Get the current frame
    match bc[frame.pc]:
      case ...
```

We are now ready for some examples. First we have the push operationÂ (ğš™ğšğšœğš‘:ğ™¸ v): $$
\frac{ğš‹ğšŒ[Î¹]=(\text{ğš™ğšğšœğš‘:ğ™¸ v})}{ğš‹ğšŒâŠ¢âŸ¨Î»,Ïƒ,Î¹âŸ©â†’âŸ¨Î»,Ïƒ(ğš’ğš—ğšv),Î¹+1âŸ©}(\mathcal{push}_I) $$
Which we can encode in Python like this:

```Python
case jvm.Push(value=v):
    frame.stack.push(v)
    frame.pc += 1
    return state
```

We can also load values from the locals using theÂ (ğš•ğš˜ğšŠğš:ğ™¸n)Â operation: $$\frac{ğš‹ğšŒ[Î¹]=(\text{ğš•ğš˜ğšŠğš:ğ™¸ n}) \ \ (ğš’ğš—ğšv)=Î»[n]}{ğš‹ğšŒâŠ¢âŸ¨Î»,Ïƒ,Î¹âŸ©â†’âŸ¨Î»,Ïƒ(ğš’ğš—ğšv),Î¹+1âŸ©}(load_I)$$
Which we can encode in Python like this:

```Python
case jvm.Load(type=jvm.Int(), index=n):
    v = frame.locals[n]
    assert v.type is jvm.Int()
    frame.stack.push(v)
    frame.pc += 1
    return state
```



**The Call Stack and Heap -- Complete Stepping Function**
Besides execution within one method /procedure, methods /procedures are also capable of calling other methods. To support this we need a stack of frames, or a call stackÂ Î¼: $$\mu âˆ¼ \cdots âŸ¨Î»_2,Ïƒ_2,Î¹_2âŸ©âŸ¨Î»_1,Ïƒ_1,Î¹_1âŸ©$$
And now since we have multiple frames, we also need a way for the frames to share data. We call that the heapÂ Î·. And it is just mapping from memory locations toÂ $ğ•_Î·$. $$Î·âˆˆâ„•â†’ğ•_Î·$$
The state is now just a tuple of the heap and the call stack:Â $âŸ¨Î·,Î¼âŸ©$. Which we can represent in Python like this:

```Python
@dataclass
class State:
    heap: dict[int, jvm.Value]
    frames: Stack[Frame]
```

So now we have reached the correct definition of the stepping function, over the State. $$ğš‹ğšŒâŠ¢âŸ¨Î·,Î¼âŸ©â†’âŸ¨\overset{-}{Î·},\overset{-}{Î¼}âŸ©$$
We can use the operations we defined over frames, by lifting them into the state, by doing the frame operation **on the top frame**: $$\begin{aligned} & \frac{ğš‹ğšŒâŠ¢âŸ¨Î»,Ïƒ,Î¹âŸ©â†’âŸ¨\overset{-}{\lambda},\overset{-}{\sigma},\overset{-}{\iota}âŸ©}{ğš‹ğšŒâŠ¢Î¼âŸ¨Î»,Ïƒ,Î¹âŸ©â†’Î¼âŸ¨\overset{-}{Î»},\overset{-}{Ïƒ},\overset{-}{Î¹}âŸ©}(\mathcal{lift}_\mu) \\ \\
& \frac{ğš‹ğšŒâŠ¢Î¼â†’\overset{-}{Î¼}}{ğš‹ğšŒâŠ¢âŸ¨Î·,Î¼âŸ©â†’âŸ¨Î·,\overset{-}{Î¼}âŸ©}(\mathcal{lift}_\eta)
\end{aligned}$$


**Program Termination**
Our simplification of the JVM terminates when we exit from the last method, or we encounter an error. We do that with either anÂ `ok`Â or anÂ `err(â€˜ğš›ğšğšŠğšœğš˜ğš—â€™)`: $$\begin{aligned}

& \frac{ğš‹ğšŒ[Î¹]=(ğš›ğšğšğšğš›ğš—:ğ™¸)}{ğš‹ğšŒâŠ¢âŸ¨Î·,ÏµâŸ¨Î»,Ïƒ(ğš’ğš—ğšv),Î¹âŸ©âŸ©â†’ok}(return \ \epsilon) \\ \\

& \frac{ğš‹ğšŒ[Î¹]=(ğš›ğšğšğšğš›ğš—:ğ™¸) \ \ \begin{aligned} & Î¼_1=âŸ¨Î»_2,Ïƒ_2,Î¹_2âŸ© \\ & Î¼_2=âŸ¨Î»,Ïƒ(ğš’ğš—ğšv),Î¹âŸ©\end{aligned}}{ğš‹ğšŒâŠ¢âŸ¨Î·,Î¼Î¼_1Î¼_2âŸ©â†’âŸ¨Î·,Î¼âŸ¨Î»_2,Ïƒ_2(ğš’ğš—ğšv),Î¹_2+1âŸ©âŸ©}(return \ \mu) 
\end{aligned}$$
In Python, we can represent terminating with no error by simply returningÂ `ok`Â if the stack is empty:

```Python
case jvm.Return(type=jvm.Int()):
    v1 = frame.stack.pop()
    state.frames.pop()
    if state.frames:
        frame = state.frames.peek()
        frame.stack.push(v1)
        frame.pc += 1
        return state
    else:
        return "ok"
```

One example of throwing an error is the divide operation: $$\begin{aligned} 
& \frac{ğš‹ğšŒ[Î¹]=(\text{ğš‹ğš’ğš—ğšŠğš›ğš¢:ğ™¸ ğšğš’ğšŸ}) \ v_2=0}{ğš‹ğšŒâŠ¢âŸ¨Ïƒ(ğš’ğš—ğšv_1)(ğš’ğš—ğšv_2),Î¹âŸ©â†’err(\text{â€˜ğšğš’ğšŸğš’ğšğš ğš‹ğš¢ ğš£ğšğš›ğš˜â€™})}(\mathcal{bdiv}_{I0}) \\ \\
& \frac{ğš‹ğšŒ[Î¹]=(\text{ğš‹ğš’ğš—ğšŠğš›ğš¢:ğ™¸ ğšğš’ğšŸ}) \ \ \begin{aligned} & v_2â‰ 0 \\ & v_3=v_1 /_{ğš’ğŸ¹ğŸ¸} v_2\end{aligned}}{ğš‹ğšŒâŠ¢âŸ¨Ïƒ(ğš’ğš—ğšv_1)(ğš’ğš—ğšv_2),Î¹âŸ©â†’âŸ¨Ïƒ(ğš’ğš—ğšv_3),Î¹+1âŸ©}(\mathcal{bdiv}_{I1})
\end{aligned}$$
Which can be translated into a single case match in Python. In the case we terminate with an error, we just return the corresponding string:

```Python
case jvm.Binary(type=jvm.Int(), operant=jvm.BinaryOpr.Div):
    v2, v1 = frame.stack.pop(), frame.stack.pop()
    assert v1.type is jvm.Int(), f"expected int, but got {v1}"
    assert v2.type is jvm.Int(), f"expected int, but got {v2}"
    if v2 == 0:
        return "divide by zero"

    frame.stack.push(jvm.Value.int(v1.value // v2.value))
    frame.pc += 1
    return state
```
#### C and C++
â†— [C-Based Languages](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/Compiled%20Languages/ğŸ‘”%20C-Based%20Languages/C-Based%20Languages.md)
â†— [C & CPP](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/Compiled%20Languages/ğŸ‘”%20C-Based%20Languages/ğŸ¥%20C%20&%20CPP/C%20&%20CPP.md)

#### Go

#### Rust



## Ref
[ğŸ‘ How libc startup in a process works?]: https://www.gnu.org/software/hurd/glibc/startup.html
**Statically-linked program**
- The ELF headers points program start atÂ `_start`.
- `_start`Â (sysdeps/mach/hurd/i386/static-start.S) callsÂ `_hurd_stack_setup`
- `_hurd_stack_setup`Â (sysdeps/mach/hurd/i386/init-first.c) callsÂ `first_init`Â which callsÂ `__mach_init`Â to initialize enough to run RPCs, then runs theÂ `_hurd_preinit_hook`Â hooks, which initialize global variables of libc.
- `_hurd_stack_setup`Â (sysdeps/mach/hurd/i386/init-first.c) callsÂ `_hurd_startup`.
- `_hurd_startup`Â (hurd/hurdstartup.c) gets hurdish information from servers and calls itsÂ `main`Â parameter.
- theÂ `main`Â parameter was actuallyÂ `doinit`Â (in sysdeps/mach/hurd/i386/init-first.c), which mangles the stack and callsÂ `doinit1`Â which callsÂ `init`.
- `init`Â sets threadvars, tries to initialize threads (and perhaps switches to the new stack) and gets to callÂ `init1`.
- `init1`Â gets the Hurd block, callsÂ `_hurd_init`Â on it
- `_hurd_init`Â (hurd/hurdinit.c) initializes initial ports, starts the signal thread, runs theÂ `_hurd_subinit`Â hooks (`init_dtable`Â hurd/dtable.c notably initializes the FD table and theÂ `_hurd_fd_subinit`Â hooks, which notably checksÂ `std*`).
- We are back toÂ `_start`, which jumps toÂ `_start1`Â which is the normal libc startup which callsÂ `__libc_start_main`
- `__libc_start_main`Â (actually calledÂ `LIBC_START_MAIN`Â in csu/libc-start.c) initializes libc, tls, libpthread, atexit
- `__libc_start_main`Â calls initialization function given as parameterÂ `__libc_csu_init`,
- `__libc_csu_init`Â (csu/elf-init.c) callsÂ `preinit_array_start`Â functions
- `__libc_csu_init`Â callsÂ `_init`
- `_init`Â (sysdeps/i386/crti.S) callsÂ `PREINIT_FUNCTION`, (actually libpthread on Linux,Â `__gmon_start__`Â on hurd)
- back toÂ `__libc_csu_init`Â callsÂ `init_array_start`Â functions
- back toÂ `__libc_start_main`, it calls calls application'sÂ `main`, thenÂ `exit`.

**dynamically-linked program**
- dl.so ELF headers point its start atÂ `_start`.
- `_start`Â (sysdeps/i386/dl-machine.h) callsÂ `_dl_start`.
- `_dl_start`Â (elf/rtld.c) initializesÂ `bootstrap_map`, callsÂ `_dl_start_final`
- `_dl_start_final`Â callsÂ `_dl_sysdep_start`.
- `_dl_sysdep_start`Â (sysdeps/mach/hurd/dl-sysdep.c) callsÂ `__mach_init`Â to initialize enough to run RPCs, then callsÂ `_hurd_startup`.
- `_hurd_startup`Â (hurd/hurdstartup.c) gets hurdish information from servers and calls itsÂ `main`Â parameter.
- theÂ `main`Â parameter was actuallyÂ `go`Â insideÂ `_dl_sysdep_start`, which callsÂ `dl_main`.
- `dl_main`Â (elf/rtld.c) interprets ld.so parameters, loads the binary and libraries, callsÂ `_dl_allocate_tls_init`.
- we are back toÂ `go`, which branches toÂ `_dl_start_user`.
- `_dl_start_user`Â (./sysdeps/i386/dl-machine.h) runsÂ `RTLD_START_SPECIAL_INIT`Â (sysdeps/mach/hurd/i386/dl-machine.h) which callsÂ `_dl_init_first`.
- `_dl_init_first`Â (sysdeps/mach/hurd/i386/init-first.c) callsÂ `first_init`Â which callsÂ `__mach_init`Â to initialize enough to run RPCs, then runs theÂ `_hurd_preinit_hook`Â hooks, which initialize global variables of libc.
- `_dl_init_first`Â callsÂ `init`.
- `init`Â sets threadvars, tries to initialize threads (and perhaps switches to the new stack) and gets to callÂ `init1`.
- `init1`Â gets the Hurd block, callsÂ `_hurd_init`Â on it
- `_hurd_init`Â (hurd/hurdinit.c) initializes initial ports, starts the signal thread, runs theÂ `_hurd_subinit`Â hooks (`init_dtable`Â hurd/dtable.c notably initializes the FD table and theÂ `_hurd_fd_subinit`hooks, which notably checksÂ `std*`).
- we are back toÂ `_dl_start_user`, which callsÂ `_dl_init`Â (elf/dl-init.c) which calls application initializers.
- `_dl_start_user`Â jumps to the application's entry point,Â `_start`
- `_start`Â (sysdeps/i386/start.S) callsÂ `__libc_start_main`
- `__libc_start_main`Â (actually calledÂ `LIBC_START_MAIN`Â in csu/libc-start.c) initializes libc, atexit,
- `__libc_start_main`Â calls initialization function given as parameterÂ `__libc_csu_init`,
- `__libc_csu_init`Â (csu/elf-init.c) callsÂ `_init`
- `_init`Â (sysdeps/i386/crti.S) callsÂ `PREINIT_FUNCTION`, (actually libpthread on Linux,Â `__gmon_start__`Â on hurd)
- back toÂ `__libc_csu_init`Â callsÂ `init_array_start`Â functions
- back toÂ `__libc_start_main`, it calls application'sÂ `main`, thenÂ `exit`.

