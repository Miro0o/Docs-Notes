# The Essence of Computing - Programs & The Semantics of Programs

[TOC]



## Res
### Related Topics
â†— [Theory of Computation](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/Theory%20of%20Computation.md)
- â†— [Automata Theory and (Formal) Language Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)
â†— [Formal Semantics and Programming Language](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Formal%20Semantics%20and%20Programming%20Language.md)
- â†— [Operational Semantics](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Operational%20Semantics.md)

â†— [Mathematical Modeling & Real World Problem Solving](../ğŸ§®%20Mathematics/Mathematical%20Modeling%20&%20Real%20World%20Problem%20Solving.md)
â†— [(Formal) Model Checking /1ï¸âƒ£ System Modeling](../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ™‡â€â™‚ï¸%20Formal%20Methods%20&%20Formal%20Verification%20(FV)/(Formal)%20Model%20Checking/(Formal)%20Model%20Checking.md#1ï¸âƒ£%20System%20Modeling)

â†— [Computer Languages & Programming Methodology](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/Computer%20Languages%20&%20Programming%20Methodology.md)
â†— [Programming Language Processing & Program Execution](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/Programming%20Language%20Processing%20&%20Program%20Execution.md)
- â†— [Program Language Translation & Compilation Theory (Compile-time)](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸš®%20Program%20Language%20Translation%20&%20Compilation%20Theory%20(Compile-time)/Program%20Language%20Translation%20&%20Compilation%20Theory%20(Compile-time).md)
- â†— [Procedure (Function) Call & Runtime Memory Layout](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸ¤¡%20Program%20Execution%20(Runtime)/Procedure%20(Function)%20Call%20&%20Runtime%20Memory%20Layout.md)

â†— [Software Engineering](../Software%20Engineering/Software%20Engineering.md)

â†— [OS Memory Management (Main Memory + Secondary Memory Resource)](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/OS%20Memory%20Management%20(Main%20Memory%20+%20Secondary%20Memory%20Resource)/OS%20Memory%20Management%20(Main%20Memory%20+%20Secondary%20Memory%20Resource).md)
â†— [Computer Memory & Storage](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Computer%20Architecture/Computer%20Microarchitectures%20(Computer%20Organization)%20&%20von%20Neumann%20Model/Computer%20Memory%20&%20Storage/Computer%20Memory%20&%20Storage.md)
â†— [Address Space & Memory Layout](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/OS%20Memory%20Management%20(Main%20Memory%20+%20Secondary%20Memory%20Resource)/Address%20Space%20&%20Memory%20Layout.md)

â†— [Operating System & OS Kernel (Theory Part)](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part).md)
â†— [Operating Systems & Kernels (Engineering Part)](../ğŸ”‘%20CS%20Core/ğŸ¥·ğŸ¼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Operating%20Systems%20&%20Kernels%20(Engineering%20Part).md)


### Other Resources
ğŸ”¥ ğŸ¬ã€æ“ä½œç³»ç»Ÿä¸Šçš„ç¨‹åº (ä»€ä¹ˆæ˜¯ç¨‹åºå’Œç¼–è¯‘å™¨) [å—äº¬å¤§å­¦2022æ“ä½œç³»ç»Ÿ-P2]ã€‘ https://www.bilibili.com/video/BV12L4y1379V/?share_source=copy_web&vd_source=7740584ebdab35221363fc24d1582d9d



## Intro
### Related Concepts Review
#### Information, Language, and Computation
![ | 800](../../../Assets/Illustrations/Computer%20Science%20Philosophy/Human_and_knowledge.excalidraw.md)
<small>The relationship of language, information/data, computation, and automation.</small>
â†— [Universe, Self-Awareness, and Intelligence](../../Universe,%20Self-Awareness,%20and%20Intelligence.md)

![Automata_Formal_Lan.excalidraw | 800](../../../Assets/Illustrations/Math/Automata_Formal_Lan.excalidraw.md)
<small>Automata and Formal Language</small>
â†— [Automata Theory and (Formal) Language Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)

![computer_architecture.excalidraw | 800](../../../Assets/Illustrations/Computer%20System/computer_architecture_and_computer_science.excalidraw.md)
<small>Computer System & Computer Science Overview</small>
â†— [Computer Architecture](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Computer%20Architecture/Computer%20Architecture.md)

![application_execution_and_computer_data_flow.excalidraw | 800](../../Assets/Illustrations/Computer%20System/application_execution_and_computer_data_flow.excalidraw.md)
<small>Computer Program Execution Procedure: Top-down Review</small>
â†— [Programming Language Processing & Program Execution](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/Programming%20Language%20Processing%20&%20Program%20Execution.md)

- ä¸»ä½“è§†è§’ä¸‹çš„å®‡å®™ä¸‰å¤§æ„æˆå…ƒç´ ï¼šä¿¡æ¯ã€ç‰©è´¨ã€èƒ½é‡
	- è¯­è¨€ä¸ºä¿¡æ¯ä¸€åˆ‡æ´»åŠ¨æä¾›è½½ä½“ã€‚
		- ä¿¡æ¯å¯ä»¥è„±ç¦»è¯­è¨€å­˜åœ¨ï¼Œä½†æ˜¯è¯­è¨€æ˜¯å¤æ‚ä¿¡æ¯è¿åŠ¨çš„ä¼˜è´¨è½½ä½“ã€‚è„±ç¦»äº†è¯­è¨€ï¼Œä¿¡æ¯å¾ˆéš¾åœ¨ä¸»ä½“æ„è¯†ä¸‹åšå¤æ‚è¿åŠ¨ã€‚
		- è‡ªç„¶è¯­è¨€ï¼Œå½¢å¼è¯­è¨€
	- çŸ¥è¯†æ˜¯æœ‰ç»„ç»‡çš„ä¿¡æ¯
- è®¡ç®—æœºç§‘å­¦çš„ç ”ç©¶èŒƒç•´ï¼šä¿¡æ¯è¿åŠ¨çš„è‡ªåŠ¨åŒ–ï¼ˆè‡ªåŠ¨åŒ–è®¡ç®—ï¼‰
	- è®¡ç®—æœºçš„æ„æˆï¼šè®¡ç®—æ¨¡å‹ï¼ˆæ•°å­¦ï¼‰+ ç¡¬ä»¶å®ç° + è½¯ä»¶å®ç°
	- è®¡ç®—æœºçš„åº”ç”¨ï¼šæ•°å­¦å»ºæ¨¡ï¼ˆç®—æ³•ï¼‰+ è½¯ä»¶å®ç°ï¼ˆç¼–ç¨‹ï¼‰
- è½¯ä»¶ï¼šè½¯ä»¶ = ç¨‹åº + æ–‡æ¡£
	- ç¨‹åº = æŒ‡ä»¤ï¼ˆç¼–ç¨‹è¯­è¨€ï¼‰+ æ•°æ®
	- ç¨‹åºé€šè¿‡è¯­è¨€çš„å½¢å¼å¯¹è®¡ç®—æœºç¡¬ä»¶çš„è¿è¡Œè¿›è¡ŒæŒ‡ä»¤ï¼Œä»¥è¾¾åˆ°è®¡ç®—çš„ç›®çš„ã€‚
- ç»“è®º
	- ç¼–ç¨‹è¯­è¨€å’Œç¨‹åºæ„æˆäº†è®¡ç®—æœºç§‘å­¦åŠè®¡ç®—çš„æ ¸å¿ƒ/çµé­‚ï¼›
	- ç¼–ç¨‹è¯­è¨€ä¸»è¦çš„ç ”ç©¶èŒƒå›´åœ¨äºå½¢å¼è¯­è¨€çš„è®¾è®¡åŠå®ç°ï¼Œå‰è€…ä¸»è¦æ¶‰åŠå¯¹åº”çš„æ•°å­¦çŸ¥è¯†ï¼Œåè€…è¿˜æ¶‰åŠè½¯ä»¶å·¥ç¨‹ï¼›
	- ç¨‹åºçš„ä¸»è¦ç ”ç©¶èŒƒå›´åœ¨äºç¨‹åºçš„è®¾è®¡åŠè¿è¡Œï¼Œå‰è€…æ¶‰åŠå…·ä½“çš„ç¼–ç¨‹è¯­è¨€å’Œç®—æ³•ï¼Œåè€…æ¶‰åŠè®¡ç®—æœºç¡¬ä»¶å’Œè½¯ä»¶çš„å·¥ä½œåŸç†ã€‚
#### Formal System & Language, Computer Language, and Programming Language
â†— [Language & Literature](../../Other%20Networks%20of%20Knowledge/Arts%20&%20Cultures/ğŸ“ƒ%20Language%20&%20Literature/Language%20&%20Literature.md)
â†— [Logic (and Critical Thinking)](../../Other%20Networks%20of%20Knowledge/â™‚%20Philosophy/Philosophy%20by%20Disciplines%20&%20Topics/ğŸ¼%20Logic%20(and%20Critical%20Thinking)/Logic%20(and%20Critical%20Thinking).md)

â†— [Mathematics](../ğŸ§®%20Mathematics/Mathematics.md)
â†— [Automata Theory and (Formal) Language Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)
â†— [Mathematical Logic Basics (Formal Logic)](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Mathematical%20Logic%20Basics%20(Formal%20Logic).md)

> The distinction between formal language theory and logic
> #formal_logic #formal_language
> 
> (Generated by Google AI mode)
> 
> It is critical to distinguish between classifying the grammar of a logical language and classifying the logic itself.Â 
> -  **Formal language theory**, which includes the Chomsky hierarchy, is concerned withÂ **syntax**. It asks whether a string of symbols is a valid formula.
> - **Logic**Â is concerned withÂ **semantics**Â and the rules of reasoning. It asks whether a valid formula is true or provable.Â 
> 
> For example, the syntax of a programming language like Python can be described by a context-free grammar. However, the program's actual logic, meaning, and behavior are not described by the Chomsky hierarchy. Similarly, a formal language used for logic (e.g., predicate calculus) can be classified on the hierarchy, but the classification says nothing about the logic's ability to express concepts like truth or validity.

â†— [Computer Languages & Programming Methodology](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/Computer%20Languages%20&%20Programming%20Methodology.md)
- â†— [Programming Language Theory (PLT)](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Programming%20Language%20Theory%20(PLT).md)
â†— [Formal Syntax & Metasyntax (and Metalanguage)](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/ğŸ“Œ%20Formal%20Syntax%20&%20Metasyntax%20(and%20Metalanguage)/Formal%20Syntax%20&%20Metasyntax%20(and%20Metalanguage).md)
#### Algorithm, Program, and Software
â†— [Algorithm & Data Structure](../ğŸ”‘%20CS%20Core/ğŸ§™â€â™‚ï¸%20Algorithm%20&%20Data%20Structure/Algorithm%20&%20Data%20Structure.md)
â†— [Programming Language Processing & Program Execution](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/Programming%20Language%20Processing%20&%20Program%20Execution.md)
â†— [Software Engineering](../Software%20Engineering/Software%20Engineering.md)


### Program Semantics, Abstraction, and Interpretation
â†— [Formal Semantics and Programming Language](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Formal%20Semantics%20and%20Programming%20Language.md)
â†— [Program Abstraction & Abstract Interpretation /Intro](../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ‘š%20SCA%20(Static%20Code%20Analysis)%20&%20SAST/ğŸ›—%20Program%20Abstraction%20&%20Abstract%20Interpretation/Program%20Abstraction%20&%20Abstract%20Interpretation.md#Intro)

â†— [Theory of Computation /Models of Computation](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/Theory%20of%20Computation.md#Models%20of%20Computation)
â†— [(Formal) Model Checking](../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ™‡â€â™‚ï¸%20Formal%20Methods%20&%20Formal%20Verification%20(FV)/(Formal)%20Model%20Checking/(Formal)%20Model%20Checking.md)



## ğŸ˜† Semantics of Program
ğŸ”¥ ğŸ¬ã€æ“ä½œç³»ç»Ÿä¸Šçš„ç¨‹åº (ä»€ä¹ˆæ˜¯ç¨‹åºå’Œç¼–è¯‘å™¨) [å—äº¬å¤§å­¦2022æ“ä½œç³»ç»Ÿ-P2]ã€‘ https://www.bilibili.com/video/BV12L4y1379V/?share_source=copy_web&vd_source=7740584ebdab35221363fc24d1582d9d

![Drawing 2025-09-09 22.37.45.excalidraw | 800](../../Assets/Illustrations/Computer%20Language/Language_and_Programming_Language_Processing.md)
<small>For different levels in code analysis, we use different computational models. </small>


### Transition System, Computation Tree, and Operational Semantics
â†— [Mathematical Logic (Foundations of Mathematics)](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/Mathematical%20Logic%20(Foundations%20of%20Mathematics).md)
â†— [Mathematical Logic Basics (Formal Logic)](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Mathematical%20Logic%20Basics%20(Formal%20Logic).md)
- â†— [Set Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ›’%20Set%20Theory/Set%20Theory.md)
- â†— [Automata Theory and (Formal) Language Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)

â†— [Formal Semantics and Programming Language](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Formal%20Semantics%20and%20Programming%20Language.md)
- â†— [Operational Semantics](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Operational%20Semantics.md)

> ğŸ”— https://courses.compute.dtu.dk/02242/topics/semantics.html##sec:2.1

**(Program) Semantics**
Program semantics is about assigning meaning to programs. When we can talk about what a piece of syntax mean, it is easier to explain what a program does.

We are going to discuss some different approaches to writing down the semantics of a program.  ==They all essentially turn programs syntax into mathematical logic.==

â†— [Mathematical Logic Basics (Formal Logic) /Semantic & The Semantics of Mathematical Logics](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Mathematical%20Logic%20Basics%20(Formal%20Logic).md#Semantic%20&%20The%20Semantics%20of%20Mathematical%20Logics)


**Mathematical Logic Languages & Natural Deduction**
â†— [Mathematical Logic Basics (Formal Logic)](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ“%20Mathematical%20Logic%20Basics%20(Formal%20Logic)/Mathematical%20Logic%20Basics%20(Formal%20Logic).md)
â†— [Gentzen-Style Proofs (Natural Deduction)](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/Proof%20Theory/Proof%20Calculus/Gentzen-Style%20Proofs%20(Natural%20Deduction).md)


**Operational Semantics**
Operational semantics describes the semantic of a program as changes to a state. This makes it ideal for describing imperative languages like the JVM bytecode.

TheÂ _Structural Operational Semantics_Â orÂ _Small Step Semantics_Â are written as judgments of the typeÂ (ÏˆâŠ¢Ïƒâ†’Ïƒâ€¾)Â which means given the environmentÂ Ïˆ, the state of the programÂ ÏƒÂ can be turned intoÂ Ïƒâ€¾.

The reason we call this approach the small step semantics is that we only execute a single operation at a time.

TheÂ _Natural Operational Semantics_Â orÂ _Big Step Semantics_, are describing running the program until it halts.Â (ÏˆâŠ¢Ïƒâ†“v)Â whereÂ vÂ is the final value of the program. Big step semantics often looks nicer than small step semantics, because it does not have to care about execution order.

Big Step semantics have the benefit of being easier to read, however, it has some big disadvantages, namely: we cannot reason about programs that run forever, and we cannot turn big step semantics into a working implementation. In contrast, small step semantics are easy to convert into an interpreter, and we can always recover the big step semantics from the operational semantics by simply applying the single step semantics until the program terminates with a value:

Â 
**Transition System** (in Kripe Structure)
Using operational semantics, we can define the meaning of a programÂ PÂ as aÂ Transition System:

(â†— [(Formal) Model Checking /1ï¸âƒ£ System Modeling](../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ™‡â€â™‚ï¸%20Formal%20Methods%20&%20Formal%20Verification%20(FV)/(Formal)%20Model%20Checking/(Formal)%20Model%20Checking.md#1ï¸âƒ£%20System%20Modeling))
A transition system $TS$ is a tuple $(S,Act,\to,I,AP,L)$ where
- $S$ is a set of states,
- $Act$ is a set of actions,
- $\to \subseteq S \times Act \times S$ is a transition relation,
	-  or use $\delta$ to express $\to$
- $I \subseteq S$ is a set of initial states,
	- $\sigma\in I$
	- or, when using $\tau$ or $\pi$ to symbol a trace on $TS$, $\tau_0 = \sigma \in I$ or $\pi_0=\sigma\in I$
- $AP$ is a set of atomic propositions, 
- $L$: $Sâ†’AP^2$ is a labeling function.

$TS$ is called **finite** if $S$, $Act$, and $AP$ are **finite**.

It is important to realize that in case a state has more than one outgoing transition, the
â€œnextâ€ transition is chosen in a purely **nondeterministic** fashion. That is, the outcome of
this selection process is not known a priori, and, hence, no statement can be made about the likelihood with which a certain transition is selected. Similarly, when the set of initial states consists of more than one state, the start state is selected nondeterministically.

For convenience, we write $s \xrightarrow[]{\alpha}s'$ instead of $(s,Î±,s') \in \to$.

The labeling function $L$ relates a set $L(s) \in AP^2$ of atomic propositions to any state $s$. $L(s)$ intuitively stands for exactly those atomic propositions $a \in AP$ which are satisfied by state $s$. Given that $Î¦$ is a propositional logic formula, then $s$ satisfies the formula $Î¦$ if the evaluation induced by $L(s)$ makes the formula Î¦ true; that is: $s \models \Phi \iff L(s) \models \Phi$.


**Traces and Maximal Trace Semantics**
AÂ $Trace_P$Â is the possible infinite sequence of states and operations of the program. $Trace_P=States_P^{*}$

The meaning of a program is now the set of traces that it exhibit:
 - $Semantics: Program \to 2^{Trace}$, or
 - $Sem(P)= \{\tau \in State_P^n ~Â | ~Â n \in [1,âˆ], ~ \tau_0 \in I_P, ~ \forall i \in [1, nâˆ’1], ~ \theta_P(\tau_{iâˆ’1},\tau_i) \}$

This is also called theÂ **Maximal Trace Semantics**. We can now define properties, like does a program halt, using relatively well defined math:
$\mathcal{L}_{halt}= \{P ~ |Â ~ â¡P \in \mathcal{L}, ~ \forall \tau \in Sem(P), ~ |\tau|\neq \infty \}$


### Digital Circuits and State Machine (Transition System)
çŠ¶æ€ = å¯„å­˜å™¨ä¿å­˜çš„å€¼ (flip-flop)
åˆå§‹çŠ¶æ€ = RESET (implementation dependent)
è¿ç§» = ç»„åˆé€»è¾‘ç”µè·¯è®¡ç®—å¯„å­˜å™¨ä¸‹ä¸€å‘¨æœŸçš„å€¼


### Program's State Machine Model (Programming Languages Semantics)
> â†— [Automata Theory and (Formal) Language Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)
> - Push-Down Automaton (PDA)
> 
> â†— [Formal Semantics and Programming Language](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Formal%20Semantics%20and%20Programming%20Language.md)
#### 1ï¸âƒ£ Program's State Machine: Application Perspective
C ç¨‹åºçš„çŠ¶æ€æœºæ¨¡å‹1 (è¯­ä¹‰ï¼Œsemantics)
- çŠ¶æ€ = å † + æ ˆ
- åˆå§‹çŠ¶æ€ =Â `main`Â çš„ç¬¬ä¸€æ¡è¯­å¥
- è¿ç§» = æ‰§è¡Œä¸€æ¡ç®€å•Cè¯­å¥
    - ä»»ä½• C ç¨‹åºéƒ½å¯ä»¥æ”¹å†™æˆ â€œéå¤åˆè¯­å¥â€ çš„ C ä»£ç 
    - [çœŸçš„æœ‰è¿™ç§å·¥å…·](https://cil-project.github.io/cil/)Â (C Intermediate Language) å’Œ[è§£é‡Šå™¨](https://gitlab.com/zsaleeba/picoc)

C ç¨‹åºçš„çŠ¶æ€æœºæ¨¡å‹2 (è¯­ä¹‰ï¼Œsemantics)
- çŠ¶æ€ = stack frame çš„åˆ—è¡¨ (æ¯ä¸ª frame æœ‰ PC) + å…¨å±€å˜é‡
- åˆå§‹çŠ¶æ€ = main(argc, argv), å…¨å±€å˜é‡åˆå§‹åŒ–
- è¿ç§» = æ‰§è¡Œ top stack frame PC çš„è¯­å¥; PC++
    - å‡½æ•°è°ƒç”¨ = push frame (frame.PC = å…¥å£)
    - å‡½æ•°è¿”å› = pop frame

åº”ç”¨ï¼šå°†ä»»ä½•é€’å½’ç¨‹åºå°±åœ°è½¬ä¸ºéé€’å½’
#### 2ï¸âƒ£ Program's State Machine: CPU(Computer) Perspective
C ç¨‹åºçš„çŠ¶æ€æœºæ¨¡å‹3 (è¯­ä¹‰ï¼Œsemantics)
- çŠ¶æ€ = å†…å­˜Â MMÂ + å¯„å­˜å™¨Â RR
- åˆå§‹çŠ¶æ€ = (ç¨åå›ç­”)
- è¿ç§» = æ‰§è¡Œä¸€æ¡æŒ‡ä»¤
#### Application Program and OS Program
> â†— [Operating System & OS Kernel (Theory Part)](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part).md)
> â†— [Operating Systems & Kernels (Engineering Part)](../ğŸ”‘%20CS%20Core/ğŸ¥·ğŸ¼%20Operating%20Systems%20&%20Kernels%20(Engineering%20Part)/Operating%20Systems%20&%20Kernels%20(Engineering%20Part).md)
> â†— [Operating System Kernel (Kernel Mode)](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/ğŸ˜´%20Operating%20System%20Components%20&%20Runtime%20Libraries/Operating%20System%20Kernel%20(Kernel%20Mode).md)
> â†— [System Calls](../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Operating%20System%20&%20OS%20Kernel%20(Theory%20Part)/OS%20Processes%20&%20Automata%20Management%20(CPU%20+%20Main%20Memory%20Resource)/ğŸ“Œ%20Processes%20Description%20&%20Control/System%20Calls/System%20Calls.md)
> â†— [Interrupts (Software & Hardware)](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸ¤¡%20Program%20Execution%20(Runtime)/Instruction%20Execution/Interrupts%20(Software%20&%20Hardware).md)

æ“ä½œç³»ç»Ÿä¸Šçš„ç¨‹åº:
- æ‰€æœ‰çš„æŒ‡ä»¤éƒ½åªèƒ½è®¡ç®—
	- deterministic: `mov`, `add`, `sub`, `call`, ...
	- non-deterministic: `rdrand`, ...
	- ä½†è¿™äº›æŒ‡ä»¤ç”šè‡³éƒ½æ— æ³•ä½¿ç¨‹åºåœä¸‹æ¥ (NEMU: åŠ æ¡Â `trap`Â æŒ‡ä»¤)
- è°ƒç”¨æ“ä½œç³»ç»ŸÂ `syscall`
	- æŠŠÂ `(M,R)`å®Œå…¨äº¤ç»™æ“ä½œç³»ç»Ÿï¼Œä»»å…¶ä¿®æ”¹
	    - ä¸€ä¸ªæœ‰è¶£çš„é—®é¢˜ï¼šå¦‚æœç¨‹åºä¸æ‰“ç®—å®Œå…¨ä¿¡ä»»æ“ä½œç³»ç»Ÿï¼Ÿ
	- å®ç°ä¸æ“ä½œç³»ç»Ÿä¸­çš„å…¶ä»–å¯¹è±¡äº¤äº’
	    - è¯»å†™æ–‡ä»¶/æ“ä½œç³»ç»ŸçŠ¶æ€ (ä¾‹å¦‚æŠŠæ–‡ä»¶å†…å®¹å†™å…¥Â MM)
	    - æ”¹å˜è¿›ç¨‹ (è¿è¡Œä¸­çŠ¶æ€æœº) çš„çŠ¶æ€ï¼Œä¾‹å¦‚åˆ›å»ºè¿›ç¨‹/é”€æ¯è‡ªå·±

==æ“ä½œç³»ç»Ÿä¸Šçš„åº”ç”¨ç¨‹åº = è®¡ç®— + `syscall`==
- ç¨‹åº = è®¡ç®— â†’ `syscall` â†’ è®¡ç®— â†’ ...
	- è¢«æ“ä½œç³»ç»ŸåŠ è½½
		- é€šè¿‡å¦ä¸€ä¸ªè¿›ç¨‹æ‰§è¡Œ `execve` è®¾ç½®ä¸ºåˆå§‹çŠ¶æ€
	- çŠ¶æ€æœºæ‰§è¡Œ
		- è¿›ç¨‹ç®¡ç†ï¼š`fork`, `execve`, `exit`, ...
		- æ–‡ä»¶/è®¾å¤‡ç®¡ç†ï¼š`open`, `close`, `read`, `write`, ...
		- å­˜å‚¨ç®¡ç†ï¼š`mmap`, `brk`, ...
	- ç›´åˆ° `_exit (exit_group)` é€€å‡º
- ğŸ’€ é—®é¢˜ï¼šæ€ä¹ˆæ„é€ ä¸€ä¸ªæœ€å°çš„ Hello, Worldï¼Ÿ
- ğŸ’€ é—®é¢˜ï¼šä¸€ä¸ªæ™®é€šçš„ã€äººç•œæ— å®³çš„ Hello World C ç¨‹åºæ‰§è¡Œçš„ç¬¬ä¸€æ¡æŒ‡ä»¤åœ¨å“ªé‡Œï¼Ÿ /â€œäºŒè¿›åˆ¶ç¨‹åºçŠ¶æ€æœºçš„åˆå§‹çŠ¶æ€æ˜¯ä»€ä¹ˆï¼Ÿâ€ (â†— [Intro to Computer Science /Questions Leading my CS Study](ğŸ’‹%20Intro%20to%20Computer%20Science/Intro%20to%20Computer%20Science.md#Questions%20Leading%20my%20CS%20Study))
	- `ld-linux-x86-64.so`Â åŠ è½½äº† libc
		- ä¹‹å libc å®Œæˆäº†è‡ªå·±çš„åˆå§‹åŒ–
	    - RTFM:Â [libc startup](https://www.gnu.org/software/hurd/glibc/startup.html)Â on Hurd
	    - `main()`Â çš„å¼€å§‹/ç»“æŸå¹¶ä¸æ˜¯æ•´ä¸ªç¨‹åºçš„å¼€å§‹/ç»“æŸ
	    - ä¾‹å­ï¼š[hello-goodbye.c](https://jyywiki.cn/pages/OS/2022/demos/hello-goodbye.c)
	- è°è§„å®šæ˜¯Â `ld-linux-x86-64.so`ï¼Œè€Œä¸æ˜¯Â `xxxx.so`?
		- `readelf` å‘Šè¯‰ä½ ç­”æ¡ˆ

==æ“ä½œç³»ç»Ÿä¸Šçš„åº”ç”¨ç¨‹åºï¼šéƒ½åœ¨æ“ä½œç³»ç»Ÿ APIÂ (syscall) å’Œæ“ä½œç³»ç»Ÿä¸­çš„å¯¹è±¡ä¸Šæ„å»º==
- ç¼–è¯‘å™¨ (gcc)ï¼Œä»£è¡¨å…¶ä»–å·¥å…·ç¨‹åº
	- ä¸»è¦çš„ç³»ç»Ÿè°ƒç”¨ï¼šexecve, read, write
	- `strace -f gcc a.c`Â (gcc ä¼šå¯åŠ¨å…¶ä»–è¿›ç¨‹)
		- å¯ä»¥ç®¡é“ç»™ç¼–è¾‘å™¨Â `vim -`
		- ç¼–è¾‘å™¨é‡Œè¿˜å¯ä»¥Â `%!grep`Â (ç»†èŠ‚/æŠ€å·§)
- å›¾å½¢ç•Œé¢ç¨‹åº (xedit)ï¼Œä»£è¡¨å…¶ä»–å›¾å½¢ç•Œé¢ç¨‹åº (ä¾‹å¦‚ vscode)
	- ä¸»è¦çš„ç³»ç»Ÿè°ƒç”¨ï¼š`poll`, `recvmsg`, `writev`
	- `strace xedit`
	    - å›¾å½¢ç•Œé¢ç¨‹åºå’Œ X-Window æœåŠ¡å™¨æŒ‰ç…§ X11 åè®®é€šä¿¡
	    - è™šæ‹Ÿæœºä¸­çš„ `xedit` å°† X11 å‘½ä»¤é€šè¿‡ ssh (X11 forwarding) è½¬å‘åˆ° Host
- çª—å£ç®¡ç†å™¨
    - ç®¡ç†è®¾å¤‡å’Œå±å¹• (`read`/`write`/`mmap`)
    - è¿›ç¨‹é—´é€šä¿¡ (`send`, `recv`)
- ä»»åŠ¡ç®¡ç†å™¨
    - è®¿é—®æ“ä½œç³»ç»Ÿæä¾›çš„è¿›ç¨‹å¯¹è±¡ (`readdir`/`read`)
    - å‚è€ƒ gdb é‡Œçš„Â `info proc *`
- æ€æ¯’è½¯ä»¶
    - æ–‡ä»¶é™æ€æ‰«æ (`read`)
    - ä¸»åŠ¨é˜²å¾¡ (`ptrace`)
    - å…¶ä»–æ›´å¤æ‚çš„å®‰å…¨æœºåˆ¶â€¦â€¦


### Compilation: Switch /Transfer Between Program's State Machine
> â†— [Automata Theory and (Formal) Language Theory](../ğŸ§®%20Mathematics/ğŸ¤¼â€â™€ï¸%20Mathematical%20Logic%20(Foundations%20of%20Mathematics)/ğŸ˜¶â€ğŸŒ«ï¸%20Theory%20of%20Computation/ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)
> â†— [Programming Language Processing & Program Execution](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/Programming%20Language%20Processing%20&%20Program%20Execution.md)
> â†— [Compilation Phase](../ğŸ”‘%20CS%20Core/ğŸ›£ï¸%20Programming%20Language%20Processing%20&%20Program%20Execution/ğŸš®%20Program%20Language%20Translation%20&%20Compilation%20Theory%20(Compile-time)/Compilation%20Phase/Compilation%20Phase.md)
> â†— [Compilation & Program Loading Tools](../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ› ï¸%20Programming%20Tool%20Chain/Compilation%20&%20Program%20Loading%20Tools/Compilation%20&%20Program%20Loading%20Tools.md)

ç¼–è¯‘å™¨ï¼šæºä»£ç Â $S$Â (çŠ¶æ€æœº) â†’ äºŒè¿›åˆ¶ä»£ç Â $C$Â (çŠ¶æ€æœº) $$C=compile(S)$$
ç¼–è¯‘ (ä¼˜åŒ–) çš„æ­£ç¡®æ€§ (Soundness):Â 
- $S$Â ä¸Â $C$Â çš„å¯è§‚æµ‹è¡Œä¸ºä¸¥æ ¼ä¸€è‡´
    - system calls; volatile variable loads/stores; termination
- Trivially æ­£ç¡® (ä½†ä½æ•ˆ) çš„å®ç°
    - è§£é‡Šæ‰§è¡Œ/ç›´æ¥ç¿»è¯‘Â $S$Â çš„è¯­ä¹‰

ç°ä»£ (ä¸æœªæ¥çš„) ç¼–è¯‘ä¼˜åŒ–: 
- åœ¨ä¿è¯è§‚æµ‹ä¸€è‡´æ€§ (sound) çš„å‰æä¸‹æ”¹å†™ä»£ç  (rewriting)
	- Inline assembly ä¹Ÿå¯ä»¥å‚ä¸ä¼˜åŒ–
	    - å…¶ä»–ä¼˜åŒ–å¯èƒ½ä¼šè·¨è¿‡ä¸å¸¦ barrier çš„Â `asm volatile`
	- Eventual memory consistency
	- Call to external CU = write back visible memory
- è¿™ç»™äº†æˆ‘ä»¬å¾ˆå¤šæƒ³è±¡çš„ç©ºé—´
	- Semantic-based compilation (synthesis)
	- AI-based rewriting
	- Fine-grained semantics & system call fusion

> [An executable formal semantics of C with applications](https://dl.acm.org/doi/10.1145/2103621.2103719)Â (POPL'12)
> [CompCert C verified compiler](https://compcert.org/motivations.html)Â and aÂ [paper](https://xavierleroy.org/publi/compcert-backend.pdf)Â (POPL'06, Most Influential Paper Award ğŸ…)
> [Copy-and-patch compilation](https://dl.acm.org/doi/10.1145/3485513)Â (OOPSLA'21, Distinguished Paper ğŸ…)



## Ref
[ğŸ‘ How libc startup in a process works?]: https://www.gnu.org/software/hurd/glibc/startup.html
**Statically-linked program**
- The ELF headers points program start atÂ `_start`.
- `_start`Â (sysdeps/mach/hurd/i386/static-start.S) callsÂ `_hurd_stack_setup`
- `_hurd_stack_setup`Â (sysdeps/mach/hurd/i386/init-first.c) callsÂ `first_init`Â which callsÂ `__mach_init`Â to initialize enough to run RPCs, then runs theÂ `_hurd_preinit_hook`Â hooks, which initialize global variables of libc.
- `_hurd_stack_setup`Â (sysdeps/mach/hurd/i386/init-first.c) callsÂ `_hurd_startup`.
- `_hurd_startup`Â (hurd/hurdstartup.c) gets hurdish information from servers and calls itsÂ `main`Â parameter.
- theÂ `main`Â parameter was actuallyÂ `doinit`Â (in sysdeps/mach/hurd/i386/init-first.c), which mangles the stack and callsÂ `doinit1`Â which callsÂ `init`.
- `init`Â sets threadvars, tries to initialize threads (and perhaps switches to the new stack) and gets to callÂ `init1`.
- `init1`Â gets the Hurd block, callsÂ `_hurd_init`Â on it
- `_hurd_init`Â (hurd/hurdinit.c) initializes initial ports, starts the signal thread, runs theÂ `_hurd_subinit`Â hooks (`init_dtable`Â hurd/dtable.c notably initializes the FD table and theÂ `_hurd_fd_subinit`Â hooks, which notably checksÂ `std*`).
- We are back toÂ `_start`, which jumps toÂ `_start1`Â which is the normal libc startup which callsÂ `__libc_start_main`
- `__libc_start_main`Â (actually calledÂ `LIBC_START_MAIN`Â in csu/libc-start.c) initializes libc, tls, libpthread, atexit
- `__libc_start_main`Â calls initialization function given as parameterÂ `__libc_csu_init`,
- `__libc_csu_init`Â (csu/elf-init.c) callsÂ `preinit_array_start`Â functions
- `__libc_csu_init`Â callsÂ `_init`
- `_init`Â (sysdeps/i386/crti.S) callsÂ `PREINIT_FUNCTION`, (actually libpthread on Linux,Â `__gmon_start__`Â on hurd)
- back toÂ `__libc_csu_init`Â callsÂ `init_array_start`Â functions
- back toÂ `__libc_start_main`, it calls calls application'sÂ `main`, thenÂ `exit`.

**dynamically-linked program**
- dl.so ELF headers point its start atÂ `_start`.
- `_start`Â (sysdeps/i386/dl-machine.h) callsÂ `_dl_start`.
- `_dl_start`Â (elf/rtld.c) initializesÂ `bootstrap_map`, callsÂ `_dl_start_final`
- `_dl_start_final`Â callsÂ `_dl_sysdep_start`.
- `_dl_sysdep_start`Â (sysdeps/mach/hurd/dl-sysdep.c) callsÂ `__mach_init`Â to initialize enough to run RPCs, then callsÂ `_hurd_startup`.
- `_hurd_startup`Â (hurd/hurdstartup.c) gets hurdish information from servers and calls itsÂ `main`Â parameter.
- theÂ `main`Â parameter was actuallyÂ `go`Â insideÂ `_dl_sysdep_start`, which callsÂ `dl_main`.
- `dl_main`Â (elf/rtld.c) interprets ld.so parameters, loads the binary and libraries, callsÂ `_dl_allocate_tls_init`.
- we are back toÂ `go`, which branches toÂ `_dl_start_user`.
- `_dl_start_user`Â (./sysdeps/i386/dl-machine.h) runsÂ `RTLD_START_SPECIAL_INIT`Â (sysdeps/mach/hurd/i386/dl-machine.h) which callsÂ `_dl_init_first`.
- `_dl_init_first`Â (sysdeps/mach/hurd/i386/init-first.c) callsÂ `first_init`Â which callsÂ `__mach_init`Â to initialize enough to run RPCs, then runs theÂ `_hurd_preinit_hook`Â hooks, which initialize global variables of libc.
- `_dl_init_first`Â callsÂ `init`.
- `init`Â sets threadvars, tries to initialize threads (and perhaps switches to the new stack) and gets to callÂ `init1`.
- `init1`Â gets the Hurd block, callsÂ `_hurd_init`Â on it
- `_hurd_init`Â (hurd/hurdinit.c) initializes initial ports, starts the signal thread, runs theÂ `_hurd_subinit`Â hooks (`init_dtable`Â hurd/dtable.c notably initializes the FD table and theÂ `_hurd_fd_subinit`hooks, which notably checksÂ `std*`).
- we are back toÂ `_dl_start_user`, which callsÂ `_dl_init`Â (elf/dl-init.c) which calls application initializers.
- `_dl_start_user`Â jumps to the application's entry point,Â `_start`
- `_start`Â (sysdeps/i386/start.S) callsÂ `__libc_start_main`
- `__libc_start_main`Â (actually calledÂ `LIBC_START_MAIN`Â in csu/libc-start.c) initializes libc, atexit,
- `__libc_start_main`Â calls initialization function given as parameterÂ `__libc_csu_init`,
- `__libc_csu_init`Â (csu/elf-init.c) callsÂ `_init`
- `_init`Â (sysdeps/i386/crti.S) callsÂ `PREINIT_FUNCTION`, (actually libpthread on Linux,Â `__gmon_start__`Â on hurd)
- back toÂ `__libc_csu_init`Â callsÂ `init_array_start`Â functions
- back toÂ `__libc_start_main`, it calls application'sÂ `main`, thenÂ `exit`.

