# Virtual Memory Space (Address Space)

[TOC]



## Res
â†— [Stack](../../../ğŸ¦„%20Algorithm%20&%20Data%20Structure/Data%20Structures/Queue/ğŸ“Œ%20Queue%20Basics/Stack.md)
â†— [Stack Attack](../../../../CyberSecurity/System%20Security/Operating%20System%20Security/Memory%20Attack/Stack%20Attack/Stack%20Attack.md)

â†— [Heap](../../../ğŸ¦„%20Algorithm%20&%20Data%20Structure/Data%20Structures/Tree/ğŸ“Œ%20Tree%20Basics/Heap.md)
â†— [Heap Attack](../../../../CyberSecurity/System%20Security/Operating%20System%20Security/Memory%20Attack/Heap%20Attack/Heap%20Attack.md)



## Intro



## Address Space From Process Perspective
Linux processes is shown in Figure 1.13. (Other Unix systems use a similar layout.) In Linux, the topmost region of the address space is reserved for code and data in the operating system that is common to all processes. The lower region of the address space holds the code and data defined by the userâ€™s process. Note that addresses in the figure increase from the bottom to the top.

![](../../../../../Assets/Pics/Screenshot%202023-10-13%20at%209.00.24PM.png)

The virtual address space seen by each process consists of a number of well-defined areas, each with a specific purpose. You will learn more about these areas later in the book (CSAPP), but it will be helpful to look briefly at each, starting with the lowest addresses and working our way up:
- **Program code and data.** Code begins at the same fixed address for all processes, followed by data locations that correspond to global C variables. The code and data areas are initialized directly from the contents of an executable object fileâ€”in our case, the hello executable. You will learn more about this part of the address space when we study linking and loading in Chapter 7.

- **Heap.** The code and data areas are followed immediately by the run-time heap. Unlike the code and data areas, which are fixed in size once the process begins running, the heap expands and contracts dynamically at run time as a result of calls to C standard library routines such as malloc and free. We will study heaps in detail when we learn about managing virtual memory in Chapter 9.

- **Shared libraries.** Near the middle of the address space is an area that holds the code and data for shared libraries such as the C standard library and the math library. The notion of a shared library is a powerful but somewhat difficult concept. You will learn how they work when we study dynamic linking in Chapter 7.

- **Stack.** At the top of the userâ€™s virtual address space is the user stack that the compiler uses to implement function calls. Like the heap, the user stack expands and contracts dynamically during the execution of the program. In particular, each time we call a function, the stack grows. Each time we return from a function, it contracts. You will learn how the compiler uses the stack in Chapter 3.

- **Kernel virtual memory.** The top region of the address space is reserved for the kernel. Application programs are not allowed to read or write the contents of this area or to directly call functions defined in the kernel code. Instead, they must invoke the kernel to perform these operations.

For virtual memory to work, a sophisticated interaction is required between the hardware and the operating system software, including a hardware translation of every address generated by the processor. The basic idea is to store the contents of a processâ€™s virtual memory on disk and then use the main memory as a cache for the disk.



## Virtual Memory Space From System Perspective
ä¸€å°PCæœºä¸­ï¼Œè£…æœ‰å¤šä¸ªå­˜å‚¨å™¨èŠ¯ç‰‡ï¼Œè¿™äº›å­˜å‚¨å™¨èŠ¯ç‰‡ä»ç‰©ç†è¿æ¥ä¸Šçœ‹æ˜¯ç‹¬ç«‹çš„ã€ä¸åŒçš„å™¨ä»¶ã€‚ä»è¯»å†™å±æ€§ä¸Šçœ‹åˆ†ä¸ºä¸¤ç±»:éšæœºå­˜å‚¨å™¨(RAM)å’Œåªè¯»å­˜å‚¨å™¨(ROM)ã€‚éšæœºå­˜å‚¨å™¨å¯è¯»å¯å†™ï¼Œä½†å¿…é¡»å¸¦ç”µå­˜å‚¨ï¼Œå…³æœºåå­˜å‚¨çš„å†…å®¹ä¸¢å¤±; åªè¯»å­˜å‚¨å™¨åªèƒ½è¯»å–ä¸èƒ½å†™å…¥ï¼Œå…³æœºåå…¶ä¸­çš„å†…å®¹ä¸ä¸¢å¤±ã€‚è¿™äº›å­˜å‚¨å™¨ä»åŠŸèƒ½å’Œè¿æ¥ä¸Šåˆå¯åˆ†ä¸ºä»¥ä¸‹å‡ ç±»ã€‚
- **éšæœºå­˜å‚¨å™¨ã€‚** ç”¨äºå­˜æ”¾ä¾›CPU ä½¿ç”¨çš„ç»å¤§éƒ¨åˆ†ç¨‹åºå’Œæ•°æ®ï¼Œä¸»éšæœºå­˜å‚¨å™¨ä¸€èˆ¬ç”±ä¸¤ä¸ªä½ç½®ä¸Š çš„ R A M ç»„ æˆ ï¼Œ è£… åœ¨ ä¸»æ¿ ä¸Šçš„ R A M å’Œ æ’ åœ¨ æ‰© å±• æ’ æ§½ ä¸Šçš„ R A M ã€‚
- **è£…æœ‰BIOS(Basic Input /Output Systemï¼ŒåŸºæœ¬è¾“å…¥/è¾“å‡ºç³»ç»Ÿ)çš„ROMã€‚** BIOSæ˜¯ç”±ä¸»æ¿å’Œå„ç±»æ¥åˆå¡(å¦‚æ˜¾å¡ã€ç½‘å¡ç­‰)å‚å•†æä¾›çš„è½¯ä»¶ç³»ç»Ÿï¼Œå¯ä»¥é€šè¿‡ å®ƒåˆ©ç”¨è¯¥ç¡¬ä»¶è®¾å¤‡è¿›è¡Œæœ€åŸºæœ¬çš„è¾“å…¥è¾“å‡ºã€‚åœ¨ä¸»æ¿å’ŒæŸäº›æ¥åˆå¡ä¸Šæ’æœ‰å­˜å‚¨ç›¸åº” BIOSçš„ROMã€‚ä¾‹å¦‚ï¼Œä¸»æ¿ä¸Šçš„ROMä¸­å­˜å‚¨ç€ä¸»æ¿çš„BIOS(é€šå¸¸ç§°ä¸ºç³»ç»ŸBIOS);æ˜¾å¡ä¸Šçš„ROMä¸­å­˜å‚¨ç€æ˜¾å¡çš„BIOS;å¦‚æœç½‘å¡ä¸Šè£…æœ‰ROMï¼Œé‚£å…¶ä¸­å°±å¯ä»¥å­˜å‚¨ç½‘å¡çš„BIOSã€‚
- **æ¥å£å¡ä¸Šçš„RAMã€‚** æŸäº›æ¥åˆå¡éœ€è¦å¯¹å¤§æ‰¹é‡è¾“å…¥ã€è¾“å‡ºæ•°æ®è¿›è¡Œæš‚æ—¶å­˜å‚¨ï¼Œåœ¨å…¶ä¸Šè£…æœ‰ RAMã€‚æœ€ å…¸å‹çš„æ˜¯æ˜¾ç¤ºå¡ä¸Šçš„ RAMï¼Œ ä¸€èˆ¬ç§°ä¸ºæ˜¾å­˜ã€‚æ˜¾ç¤ºå¡éšæ—¶å°†æ˜¾å­˜ä¸­çš„æ•°æ®å‘æ˜¾ç¤º å™¨ä¸Šè¾“å‡ºã€‚æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬å°†éœ€è¦æ˜¾ç¤ºçš„å†…å®¹å†™å…¥æ˜¾å­˜ï¼Œå°±ä¼šå‡ºç°åœ¨æ˜¾ç¤ºå™¨ä¸Šã€‚

![](../../../../../Assets/Pics/Screenshot%202023-10-13%20at%209.08.17PM.png)

ä¸Šè¿°çš„é‚£äº›å­˜å‚¨å™¨ï¼Œåœ¨ç‰©ç†ä¸Šæ˜¯ç‹¬ç«‹çš„å™¨ä»¶ï¼Œä½†æ˜¯åœ¨ä»¥ä¸‹ä¸¤ç‚¹ä¸Šç›¸åŒï¼š
- éƒ½å’ŒCPUçš„æ€»çº¿ç›¸è¿
- CPU å¯¹å®ƒä»¬è¿›è¡Œè¯»æˆ–å†™çš„æ—¶å€™éƒ½é€šè¿‡æ§åˆ¶çº¿å‘å‡ºå†…å­˜è¯»å†™å‘½ä»¤
è¿™ä¹Ÿå°±æ˜¯è¯´ï¼ŒCPU åœ¨æ“æ§å®ƒä»¬çš„æ—¶å€™ï¼ŒæŠŠå®ƒä»¬éƒ½å½“ä½œå†…å­˜æ¥å¯¹å¾…ï¼ŒæŠŠå®ƒä»¬æ€»çš„çœ‹ä½œä¸€ä¸ªç”±è‹¥å¹²å­˜å‚¨å•å…ƒç»„æˆçš„é€»è¾‘å­˜å‚¨å™¨ï¼Œè¿™ä¸ªé€»è¾‘å­˜å‚¨å™¨å°±æ˜¯æˆ‘ä»¬æ‰€è¯´çš„å†…å­˜åœ°å€ç©ºé—´ã€‚

![](../../../../../Assets/Pics/Screenshot%202023-10-13%20at%209.08.32PM.png)


## Ref

