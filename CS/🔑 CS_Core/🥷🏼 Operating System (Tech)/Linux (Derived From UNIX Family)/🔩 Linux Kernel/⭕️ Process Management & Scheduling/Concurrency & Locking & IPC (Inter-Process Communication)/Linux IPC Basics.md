# Linux IPC Basics

[TOC]



## Res
ğŸ“‚ [Chapter 5 Interprocess Communication Mechanisms | TLDP](https://tldp.org/LDP/tlk/ipc/ipc.html)

### Related Topics
â†— [OS Level Programming /Process Management /IPC](../../../../ğŸ“Ÿ%20OS%20Level%20Programming/ğŸ§±%20OS%20Level%20Programming%20with%20C%20&%20CPP/Process%20Management/IPC%20(Internal)/IPC%20(Internal).md)
â†— [Operating System (Theory) / Process Management /IPC](../../../../../ğŸ§¬%20Computer%20System/Operating%20System%20(Theory)/Processes%20Management%20(CPU%20+%20Main%20Memory%20Resource)/IPC%20(Inter%20Process%20Communication)/IPC%20(Inter%20Process%20Communication).md)



## Intro
> ğŸ”— https://tldp.org/LDP/tlk/ipc/ipc.html

Processes communicate with each other and with the kernel to coordinate their activities. Linux supports a number of Inter-Process Communication (IPC) mechanisms. Signals and pipes are two of them but Linux also supports the System V IPC mechanisms named after the UnixÂ TMÂ release in which they first appeared.



## Basic IPC Mechanisms (?)
### 1ï¸âƒ£ Signals
Signals are one of the oldest inter-process communication methods used by UnixÂ TMÂ systems. They are used to signal asynchronous events to one or more processes. A signal could be generated by a keyboard interrupt or an error condition such as the process attempting to access a non-existent location in its virtual memory. Signals are also used by the shells to signal job control commands to their child processes.



### 2ï¸âƒ£ Pipes
#### Pipes, Anonymous Pipes
> å®ç°äº²ç¼˜è¿›ç¨‹é—´çš„è¿›ç¨‹é€šä¿¡
> 
> - åªæ”¯æŒå•å‘æ•°æ®æµ;
> - åªèƒ½ç”¨äºå…·æœ‰äº²ç¼˜å…³ç³»çš„è¿›ç¨‹ä¹‹é—´;
> - æ²¡æœ‰åå­—;
> - ç®¡é“çš„ç¼“å†²åŒºæ˜¯æœ‰é™çš„(ç®¡é“åˆ¶å­˜åœ¨äºå†…å­˜ä¸­ï¼Œåœ¨ç®¡é“åˆ›å»ºæ—¶ï¼Œä¸ºç¼“å†²åŒºåˆ†é…ä¸€ä¸ªé¡µé¢å¤§å°ï¼Œé»˜è®¤64KB);
> - ç®¡é“æ‰€ä¼ é€çš„æ˜¯æ— æ ¼å¼å­—èŠ‚æµ;

Pipes then are **unidirectional byte streams** which connect the standard output from one process into the standard input of another process. Neither process is aware of this redirection and behaves just as it would normally. It is the shell which sets up these temporary pipes between the processes.

**In Linux**, a pipe is implemented using twoÂ fileÂ data structures which both point at the same **temporary VFS inode** which itself points at a physical page within memory. FigureÂ below shows that eachÂ fileÂ data structure contains pointers to different file operation routine vectors; one for writing to the pipe, the other for reading from the pipe.

This hides the underlying differences from the generic system calls which read and write to ordinary files. As the writing process writes to the pipe, bytes are copied into the shared data page and when the reading process reads from the pipe, bytes are copied from the shared data page. Linux must synchronize access to the pipe. It must make sure that the reader and the writer of the pipe are in step and to do this it uses locks, wait queues and signals.


![Pipes](https://www.science.unitn.it/~fiorella/guidelinux/tlk/img38.gif)
<small>Linux Pipes</small>


#### Named Pipes, FIFO
> å®ç°ä»»æ„è¿›ç¨‹é—´çš„è¿›ç¨‹é€šä¿¡
> 
> ä¸åŒäºç®¡é“ä¹‹å¤„åœ¨äºå®ƒæä¾›ä¸€ä¸ªè·¯å¾„åä¸ä¹‹å…³è”ï¼Œä»¥FIFOçš„æ–‡ä»¶å½¢å¼å­˜åœ¨äºæ–‡ä»¶ç³»ç»Ÿä¸­ã€‚è¿™æ ·ï¼Œå³ä½¿ä¸FIFOçš„åˆ›å»ºè¿›ç¨‹ä¸å­˜åœ¨äº²ç¼˜å…³ç³»çš„ è¿›ç¨‹ï¼Œåªè¦å¯ä»¥è®¿é—®è¯¥è·¯å¾„ï¼Œå°±èƒ½å¤Ÿå½¼æ­¤é€šè¿‡FIFOç›¸äº’é€šä¿¡(èƒ½å¤Ÿè®¿é—®è¯¥è·¯å¾„çš„è¿›ç¨‹ä»¥åŠ FIFOçš„åˆ›å»ºè¿›ç¨‹ä¹‹é—´)ï¼Œå› æ­¤ï¼Œé€šè¿‡FIFOä¸ç›¸å…³çš„è¿›ç¨‹ä¹Ÿèƒ½äº¤æ¢æ•°æ®ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒFIFO ä¸¥æ ¼éµå¾ªå…ˆè¿›å…ˆå‡º(first in first out)ï¼Œå¯¹ç®¡é“åŠFIFOçš„è¯»æ€»æ˜¯ä»å¼€å§‹å¤„è¿”å›æ•°æ®ï¼Œå¯¹å®ƒä»¬çš„å†™åˆ™æŠŠæ•°æ®æ·»åŠ åˆ°æœ«å°¾ã€‚
> 
> æœ‰åç®¡é“æ¯”ç®¡é“å¤šäº†ä¸€ä¸ªæ‰“å¼€æ“ä½œ:openã€‚
> FIFOçš„æ‰“å¼€è§„åˆ™:
> - å¦‚æœå½“å‰æ‰“å¼€æ“ä½œæ˜¯ä¸ºè¯»è€Œæ‰“å¼€FIFOæ—¶ï¼Œè‹¥å·²ç»æœ‰ç›¸åº”è¿›ç¨‹ä¸ºå†™è€Œæ‰“å¼€è¯¥FIFOï¼Œåˆ™å½“å‰æ‰“å¼€æ“ä½œå°†æˆåŠŸè¿”å›; å¦åˆ™ï¼Œå¯èƒ½é˜»å¡ç›´åˆ°æœ‰ç›¸åº”è¿›ç¨‹ä¸ºå†™è€Œæ‰“å¼€è¯¥FIFO(å½“å‰æ‰“å¼€æ“ä½œè®¾ç½®äº†é˜»å¡æ ‡å¿—);æˆ–è€…ï¼ŒæˆåŠŸè¿”å› (å½“å‰æ‰“å¼€æ“ä½œæ²¡æœ‰è®¾ç½®é˜»å¡æ ‡å¿—)ã€‚
> - å¦‚æœå½“å‰æ‰“å¼€æ“ä½œæ˜¯ä¸ºå†™è€Œæ‰“å¼€FIFOæ—¶ï¼Œå¦‚æœå·²ç»æœ‰ç›¸åº”è¿›ç¨‹ä¸ºè¯»è€Œæ‰“å¼€è¯¥FIFOï¼Œåˆ™å½“å‰æ‰“å¼€æ“ä½œå°†æˆåŠŸè¿”å›; å¦åˆ™ï¼Œå¯èƒ½é˜»å¡ç›´åˆ°æœ‰ç›¸åº”è¿›ç¨‹ä¸ºè¯»è€Œæ‰“å¼€è¯¥FIFO(å½“å‰æ‰“å¼€æ“ä½œè®¾ç½®äº†é˜»å¡æ ‡å¿—);æˆ–è€…ï¼Œè¿”å› ENXIOé”™è¯¯(å½“å‰æ‰“å¼€æ“ä½œæ²¡æœ‰è®¾ç½®é˜»å¡æ ‡å¿—)ã€‚



## IPC Mechanism Inherited from System V
Linux supports three types of interprocess communication mechanisms that first appeared in UnixÂ TMÂ System V (1983). These are **message queues**, **semaphores** and **shared memory**. 

These System V IPC mechanisms all share common authentication methods. 
- Processes may access these resources only by passing a unique reference identifier to the kernel via system calls.
- Access to these System V IPC objects is checked using **access permissions**, much like accesses to files are checked. The access rights to the System V IPC object is set by the creator of the object via system calls.
- The object's reference identifier is used by each mechanism as an index into a table of resources. It is not a straight forward index but requires some manipulation to generate the index.
- All Linux data structures representing System V IPC objects in the system include anÂ `ipc_perm` structure which contains the owner and creator process's user and group identifiers, the access mode for this object (owner, group and other) and the IPC object's key. 
	- The key is used as a way of locating the System V IPC object's reference identifier. Two sets of keys are supported: public and private. 
		- If the key is public then any process in the system, subject to rights checking, can find the reference identifier for the System V IPC object. 
		- System V IPC objects can never be referenced with a key, only by their reference identifier.


### 3ï¸âƒ£ Message Queues
> æ¶ˆæ¯é˜Ÿåˆ—æ˜¯ä¸€ä¸ªå­˜æ”¾åœ¨å†…æ ¸ä¸­çš„æ¶ˆæ¯é“¾è¡¨ï¼Œæ¯ä¸ªæ¶ˆæ¯é˜Ÿåˆ—ç”±æ¶ˆæ¯é˜Ÿåˆ—æ ‡è¯†ç¬¦æ ‡è¯†ã€‚ä¸ç®¡é“ä¸åŒçš„æ˜¯æ¶ˆ æ¯é˜Ÿåˆ—å­˜æ”¾åœ¨å†…æ ¸ä¸­ï¼Œåªæœ‰åœ¨å†…æ ¸é‡å¯(å³æ“ä½œç³» ç»Ÿé‡å¯)æˆ–è€…æ˜¾ç¤ºåœ°åˆ é™¤ä¸€ä¸ªæ¶ˆæ¯é˜Ÿåˆ—æ—¶ï¼Œè¯¥æ¶ˆæ¯ é˜Ÿåˆ—æ‰ä¼šè¢«çœŸæ­£åˆ é™¤ã€‚
> 
> 1. é»˜è®¤æƒ…å†µä¸‹ï¼Œæ•´ä¸ªç³»ç»Ÿæœ€å¤šå…è®¸æœ‰32000ä¸ªæ¶ˆ æ¯é˜Ÿåˆ—ã€‚  
> 2. æ¯ä¸ªæ¶ˆæ¯é˜Ÿåˆ—æœ€å¤§ä¸º16384å­—èŠ‚ã€‚
> 3. æ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„æ¯ä¸ªæ¶ˆæ¯æœ€å¤§ä¸º8192å­—èŠ‚ã€‚ è¿™éƒ¨åˆ†ä¿¡æ¯å¯åœ¨`/usr/include/linux/msg.h` æŸ¥çœ‹ã€‚
> è‹¥è¦ä¿®æ”¹è¿™äº›å‚æ•°ï¼Œéœ€è¦
> 1. ä¿®æ”¹ç›¸åº”ç³»ç»Ÿåº“çš„å¤´æ–‡ä»¶
> 2. é‡æ–°ç¼–è¯‘å†…æ ¸

Message queues allow one or more processes to write messages, which will be read by one or more reading processes. 

Linux maintains a list of message queues, theÂ `msgque`Â vector; each element of which points to aÂ `msqid_ds`Â data structure that fully describes the message queue. When message queues are created a newÂ `msqid_ds`Â data structure is allocated from system memory and inserted into the vector.


![](../../../../../../../Assets/Pics/Pasted%20image%2020230416085017.png)
<small>System V IPC Message Queues</small>



![](../../../../../../../Assets/Pics/Pasted%20image%2020230416084913.png)
<small>Kernel Message Queue Resources</small>


### 4ï¸âƒ£ Semaphores
In its simplest form a semaphore is a location in memory whose value can be tested and set by more than one process. The test and set operation is, so far as each process is concerned, **uninterruptible or atomic**; once started nothing can stop it. The result of the test and set operation is the addition of the current value of the semaphore and the set value, which can be positive or negative. Depending on the result of the test and set operation one process may have to sleep until the semphore's value is changed by another process. Semaphores can be used to implementÂ _critical regions_, areas of critical code that only one process at a time should be executing.


### 5ï¸âƒ£ Shared Memory
Shared memory allows one or more processes to communicate via memory that appears in all of their virtual address spaces. The pages of the virtual memory is referenced by page table entries in each of the sharing processes' page tables. It does not have to be at the same address in all of the processes' virtual memory. 
As with all System V IPC objects, access to shared memory areas is controlled via keys and access rights checking. ==Once the memory is being shared, there are no checks on how the processes are using it. They must rely on other mechanisms, for example System V semaphores, to synchronize access to the memory.==



## IPC Mechanism Introduced by BSD
### 6ï¸âƒ£ Sockets
â†— [Socket Programming & RPC](../../../../../ğŸï¸%20Computer%20Networking%20and%20Communication/ğŸ…ğŸ¼%20Socket%20Programming%20&%20RPC/Socket%20Programming%20&%20RPC.md)



## Ref
[è¿›ç¨‹é—´é€šä¿¡ï¼ˆIPCï¼‰ä»‹ç»]: https://www.cnblogs.com/CheeseZH/p/5264465.html

[è¿›ç¨‹é—´é€šä¿¡å’Œçº¿ç¨‹é—´é€šä¿¡æ€»ç»“]: https://blog.csdn.net/J080624/article/details/87454764

[è¿›ç¨‹é—´é€šä¿¡å’Œå¤šçº¿ç¨‹é€šä¿¡çš„åŒºåˆ«æ•´ç†]: https://www.cnblogs.com/JCpeng/p/15037359.html

[Demangling message queues]: http://sunsite.uakom.sk/sunworldonline/swol-11-1997/swol-11-insidesolaris.html

