# 0x00 åŸºæœ¬ç®—æ³•

[TOC]



## 0x01 ä½è¿ç®—
### XOR å¼‚æˆ–
> ğŸ”— https://textbook.cs161.org/crypto/symmetric.html#62-xor-review

XOR Properties:
$$
\begin{aligned} 0 \oplus 0 &= 0 \\ 0 \oplus 1 &= 1 \\ 1 \oplus 0 &= 1 \\ 1 \oplus 1 &= 0 \end{aligned}
$$
Given this definition, we can derive some useful properties:
$$
\begin{aligned} x \oplus 0 &= x & &\text{0 is the identity} \\ x \oplus x &= 0 & &\text{$x$ is its own inverse} \\ x \oplus y &= y \oplus x & &\text{commutative property} \\ (x \oplus y) \oplus z &= x \oplus (y \oplus z) & &\text{associative property} \end{aligned}

$$

One handy identity that follows from these is:Â $x \oplus y \oplus x = y$. In other words, givenÂ $(x \oplus y)$, you can retrieveÂ yÂ by computingÂ $(x \oplus y)\oplus x$, effectively â€œcancelling outâ€ theÂ x.

We can also perform algebra with the XOR operation:
$$
\begin{aligned} y \oplus 1 &= 0 & &\text{goal: solve for y} \\ y \oplus 1 \oplus 1 &= 0 \oplus 1 & &\text{XOR both sides by 1} \\ y &= 1 & &\text{simplify left-hand side using the identity above} \end{aligned}

$$

A trick to swap value of A and B:
$$
\begin{aligned}
A = A \oplus B \\
B = A \oplus B \\
A = A \oplus B
\end{aligned}
$$


### åç  /è¡¥ç 
â†— [(Text) Data Representations & Storage in Computer](../../../ğŸ—º%20CS%20Overview/ğŸ’‹%20Intro%20to%20Computer%20Science/ğŸ˜¤%20Information,%20Data,%20Number%20and%20Math%20in%20Digital%20Systems/(Text)%20Data%20Representations%20&%20Storage%20in%20Computer.md)

![[../../../../Assets/Archive/Curriculums/Assets/Screen Shot 2021-11-10 at 11.25.02 AM.png]] ^f11c14


###  memset(a, val, sizeof(a))
+ assign _val_ to each BYTE of a; not assign _val_ to a;	
	+ memset(a, 0x7f, sizeof(a))
	+ memset(a, 0x3f, sizeof(a))
+ 0x7F FF FF FF  --> 0x7F
	+ 0 111111...1111 (32bit)
+ 0x3F FF FF FF --> 0x3F
	+ 00 1111...111 (32bit)


### ä½ç§»
+ å·¦ç§»
+ å³ç§»
	+ ç®—æœ¯ä½ç§» ï¼ˆå¤§å¤šæ•°é»˜è®¤å³ç§»æ³•ï¼‰
		+ é«˜ä½è¡¥ç¬¦å·ä½æ•°å­—
	+ é€»è¾‘ä½ç§»
		+ é«˜ä½è¡¥0
+ å¿«é€Ÿå¹‚
	```c++
	// calculate (a ^ b) mod MOD
	int power(int a, int b, int MOD){ 
		int ans=1 % MOD;
		for(;b;b>>=1){
			if(b&1) ans = (long long) ans*a % MOD; // long long è¿™é‡Œæ˜¯ä¸ºäº†é˜²æ­¢è¿ç®—è¿‡ç¨‹ä¸­æº¢å‡º
			a = (long long) a*a % MOD; 
		}
		return ans;
	}
	```
	+ c++ ä¸­ï¼Œä¸¤ä¸ªæ•°å€¼è¿›è¡Œç®—æœ¯è¿ç®—ä»¥**å‚ä¸è¿ç®—çš„æœ€é«˜æ•°å€¼**ç±»å‹ä¸ºåŸºå‡†ï¼Œä¸ä¿å­˜ç»“æœçš„å˜é‡ç±»å‹æ— å…³ã€‚æ‰€ä»¥è®¡ç®—æ—¶ä¸ºäº†é˜²æ­¢æ•°æ®è¶Šç•Œå¯¼è‡´è®¡ç®—é”™è¯¯ï¼Œåœ¨è®¡ç®—ä¸­ä½¿ç”¨`longlong` å¼ºåˆ¶è½¬åŒ–æ•°æ®ç±»å‹ã€‚æœ€ç»ˆå–æ¨¡åèµ‹å€¼æ“ä½œéšå¼è½¬æ¢`long long` ä¸º `int`ã€‚
+ 64 ä½æ•´æ•°ä¹˜æ³•
	```c++
	// calculate ï¼ˆ a * b ï¼‰ mod MOD
	typedef long long ll
	ll mul(ll a, ll b, ll MOD){
		ll ans = 0;
		for(; b; b>>=1){
			if(b&1) ans = (ans+a) % MOD;
			a = (a<<1) % MOD;
		}
		return ans;
	}
	```


### STL
+ bitset


### äºŒè¿›åˆ¶çŠ¶æ€å‹ç¼©
+ æœ€çŸ­hamilton è·¯å¾„
	+ æ€è·¯ï¼šçŠ¶å‹DPã€‚åŒä¸€çŠ¶æ€å±‚ä¸­æ¯ä¸€ä¸ªçŠ¶æ€æ¥è‡ªäºä¸Šä¸€å±‚çš„æ¯ä¸€ä¸ªçŠ¶æ€ã€‚çŠ¶æ€ä¸“è½¬ç§»æ–¹ç¨‹æ˜¯ 
		+ åˆ°è¾¾å½“å‰æ‰€åœ¨ç‚¹çš„è·¯å¾„é•¿ = æœªåˆ°è¾¾å½“å‰ç‚¹ä½†åˆ°è¾¾æ‰€æœ‰å…¶ä»–ç‚¹æ—¶çš„è·¯å¾„é•¿ + æ‰€æœ‰é€šè·¯ä¸­åˆ°å½“å‰ç‚¹çš„æœ€çŸ­è·¯


### æˆå¯¹å˜æ¢
```c++
if (n%2) n ^ 1 == n + 1; // n xor 1
else n ^ 1 == n - 1
```

è¿™ç§æ€§è´¨ç”¨äºé‚»æ¥è¡¨å‚¨å­˜æ— å‘è¾¹ã€‚


### lowbitï¼ˆï¼‰
```c++
const int MAX_N = 1<<20;
int H[MAX_N+1];
int n;

for(int i=0;i<=20;i++) H[1<<i]=i; // initialize H[]

while(cin>>n){
	while(n>0){
		cout<<H[n&-n]<<" ";
		n-=n&-n;
	}
}
```

`n&-n = n & (~n+1)`ç”¨äºå–å‡ºæ•°å­—äºŒè¿›åˆ¶ä¸‹ä»å³åˆ°å·¦ç¬¬ä¸€ä¸ª1å’Œå³è¾¹æ‰€æœ‰0 æ„æˆçš„æ•°ã€‚
lowbit() è¾“å‡ºæ•°çš„äºŒè¿›åˆ¶ä¸‹æ‰€æœ‰1 çš„ä½ã€‚ä¹Ÿæ˜¯æ ‘çŠ¶æ•°ç»„ä¸­åŸºæœ¬è¿ç®—ã€‚



## 0x02 æšä¸¾ï¼Œæ¨¡æ‹Ÿï¼Œé€’å½’
æŒ‰çŠ¶æ€ç©ºé—´è§„æ¨¡å¤§å°ï¼Œæœ‰å‡ ç§å¸¸è§çš„æšä¸¾æ–¹å¼ï¼š
å¤šé¡¹å¼ã€æŒ‡æ•°ã€æ’åˆ—ã€ç»„åˆ
+ **strange Towers of Hanoi**  æ±‚è§£nç›˜4åº§å¡”çš„hanoié—®é¢˜
	+ åœ¨äºå¯¹è¿‡ç¨‹çš„æŠ½è±¡ï¼Œå¹¶ç”¨æ•°å­¦è¯­è¨€æè¿°ã€‚
	+ å¯æ¨å¹¿åˆ°nç›˜må¡”


### å‰ç¼€å’Œ
å¯ä»¥æ¨å¹¿åˆ°äºŒç»´æˆ–å¤šç»´ã€‚

å°†å¯¹ä¸€ä¸ªåŒºé—´çš„æ“ä½œè½¬æ¢æˆå¯¹å·¦å³ä¸¤ä¸ªç«¯ç‚¹çš„æ“ä½œï¼Œç„¶åé€šè¿‡å‰ç¼€å’Œå¾—åˆ°è§£ã€‚



## 0x03 é€’å½’
é€’æ¨å’Œé€’å½’çš„å·®åˆ«

é€’å½’çš„æœºå™¨å®ç°



## 0x04  åˆ†æ²»ï¼ˆDivide and conquerï¼‰

æ•´æ•°åŸŸçš„äºŒåˆ†ï¼Œæ³¨æ„ç»ˆæ­¢è¾¹ç•Œã€å·¦å³åŒºé—´å–èˆæ—¶çš„å¼€é—­é—®é¢˜
``` c++
r=mid, l=mid+1, mid=(l+r)/2 ï¼›
r=mid-1, l=mid, mid=(l+r+1)/2 ï¼›
```
å®æ•°åŸŸçš„äºŒåˆ†ï¼Œæ³¨æ„ç²¾åº¦é—®é¢˜ã€‚
``` c++
r=mid, l=mid, mid=(l+r)/2;  while(l + 1e-5 < r)
```


### ä¸‰åˆ†æ±‚å•å³°å‡½æ•°æå€¼
l, lmid, rmid, r
lmid å’Œ rmid æ˜¯ä»»å–çš„


### äºŒåˆ†ç­”æ¡ˆè½¬åˆ¤å®š
å°†ä¸€ä¸ªå®è§‚çš„æœ€ä¼˜åŒ–é—®é¢˜æŠ½è±¡ä¸ºå‡½æ•°ã€‚è¿™ä¸ªé—®é¢˜ä¸‹çš„å¯è¡Œæ–¹æ¡ˆå°±æ˜¯å®šä¹‰åŸŸï¼Œå¯¹å¯è¡Œæ–¹æ¡ˆè¿›è¡Œè¯„ä¼°å¾—åˆ°çš„æ•°å€¼å°±æ„æˆå‡½æ•°çš„å€¼åŸŸï¼Œæ‰€æ±‚çš„æœ€ä¼˜è§£å°±æ˜¯è¯„ä¼°å€¼æœ€ä¼˜çš„æ–¹æ¡ˆ
ç±»ä¼¼äº"æœ€å¤§å€¼æœ€å°" çš„é—®é¢˜æ˜¯ä½¿ç”¨äºŒåˆ†åˆ¤å®šçš„ä¸€ä¸ªå…¸å‹ç‰¹å¾ã€‚



## 0x05 æ’åº ï¼ˆå†…éƒ¨æ’åºï¼‰

### æ’åºæ€»è§ˆ
https://www.runoob.com/w3cnote/ten-sorting-algorithm.html

> basic sorting algorithms on Github: https://github.com/hustcc/JS-Sorting-Algorithm
> more advanced sorting algorithms on [[0x40 æ•°æ®ç»“æ„è¿›é˜¶#0x46 äºŒå‰æŸ¥æ‰¾æ ‘ä¸å¹³è¡¡æ ‘åˆæ­¥]] and [[../../../../Assets/Archive/Curriculums/SCU/CS/æ•°æ®ç»“æ„ä¸ç®—æ³•åˆ†æ/æŸ¥æ‰¾]]
1. åŸºäºæ¯”è¾ƒï¼š
	1. é€‰æ‹©æ’åºï¼Œæ’å…¥æ’åºï¼Œå†’æ³¡æ’åº 
2. åŸºäºåˆ†æ²»ï¼š
	1. å †æ’åºï¼Œå½’å¹¶æ’åºï¼Œå¿«é€Ÿæ’åº
3. åŸºäºæ˜ å°„ï¼š
	1. è®¡æ•°æ’åºï¼ŒåŸºæ•°æ’åºï¼Œæ¡¶æ’åº
#### åŸºäºæ¯”è¾ƒçš„æ’åºï¼š
å†’æ³¡æ’åºï¼šä¸€ä¸€æ¯”è¾ƒï¼Œæ¯æ¬¡æŠŠæœªæ’åºåºåˆ—ä¸­çš„æœ€å¤§å€¼æ”¾åˆ°æœ€å³ã€‚
é€‰æ‹©æ’åºï¼šå†’æ³¡çš„ä¸¤ç§æ–¹å‘ã€‚æ¯æ¬¡æŠŠæœªæ’åºåºåˆ—ä¸­çš„æœ€å¤§å€¼æ”¾åˆ°æœ€å³ï¼ˆæˆ–ç›¸åï¼‰ã€‚
æ’å…¥æ’åºï¼šæ¯æ¬¡ä»æœªæ’åºåºåˆ—é€‰ä¸€ä¸ªæ’å…¥åˆ°å·²æ’åºåºåˆ—çš„æ­£ç¡®ä½ç½®ã€‚èµ·å§‹æ—¶ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å·²æ’åºåºåˆ—ï¼Œå…¶ä½™ä¸ºæœªæ’åºåºåˆ—ã€‚
#### åŸºäºåˆ†æ²»çš„æ’åºï¼š
> âš ï¸ æ³¨æ„äºŒåˆ†çš„ç²¾åº¦é—®é¢˜å’Œè¾¹ç•Œé—®é¢˜ [[0x00 åŸºæœ¬ç®—æ³•#0x04 äºŒåˆ†]]

å½’å¹¶ï¼ˆäºŒåˆ†ï¼‰æ’åºï¼šæ ‡å‡†åˆ†æ²»
å¸Œå°”æ’åºï¼šæ’å…¥ + åˆ†æ²»
[å¿«é€Ÿæ’åº](https://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html)ï¼šå†’æ³¡ + åˆ†æ²» ï¼ˆæˆ–ï¼Œé€‰æ‹© + åˆ†æ²»ï¼‰
å †æ’åºï¼šäºŒå‰æ ‘ + åˆ†æ²»
#### åŸºäºæ˜ å°„çš„æ’åºï¼š
è®¡æ•°æ’åºï¼šæ ‡å‡†æ˜ å°„
æ¡¶æ’åºï¼šè®¡æ•°æ’åº + æ¯”è¾ƒæ’åº ï¼ˆåˆ†æˆå—ï¼Œå—å†…æ¯”è¾ƒæ’åºç®—æ³•é€‰ä¸€ä¸ªï¼‰
åŸºæ•°æ’åºï¼šæ ¹æ®æ•´æ•°çš„æ¯ä¸€ä½ï¼Œä»é«˜ä½åˆ°ä½ä½è®¡æ•°æ’åºã€‚
+ åŸºæ•°æ’åºåˆ©ç”¨æ’åºä¼˜å…ˆçº§å®Œæˆæ’åºã€‚åœ¨å®æ•°ä¸­ï¼Œæ’åºå…ƒç´ ä¼˜å…ˆçº§ç”±æ•°çš„æ¬¡å¹‚å†³å®šã€‚ä»ä½ä½åˆ°é«˜ä½çš„æ’åºé¡ºåº å¯¹åº” ä½ä½æ¬¡å¹‚å…ƒç´ å—åç»­ é«˜ä½æ¬¡å¹‚å…ƒç´ çš„å½±å“ï¼Œç¬¦åˆä¼˜å…ˆçº§å…³ç³»ã€‚


### éƒ¨åˆ†ä»£ç å®ç°
#### äºŒåˆ†
```c++
// äºŒåˆ†æ’åº DC_sort()ï¼›å¯¹äºå…¶ä»–äºŒåˆ†æ€æƒ³çš„è§£å†³æ–¹æ¡ˆç±»ä¼¼

const int M_size = 1e5+10;

void DC_sort (int num[], int l, int r){

	if (l >= r) return ;

	int mid = (l + r) /2,i=l, j=mid + 1;
	DC_sort(num, i, mid); DC_sort(num, j, r);


	int temp[M_size],top=0;
	while(i <= mid && j <= r){
		if(num[i] <= num[j]) temp[++top] = num[i++];
		else temp[++top] = num[j++];
	}
	while(i <= mid) 
		temp[++top] = num[i++];
	while (j <= r)
		temp[++top] = num[j++];

 	top = 0;
 	for(int k=l;k<=r;k++) num[k] = temp[++top];
}
```
#### å¿«æ’
```c++
// å¿«é€Ÿæ’åº qs();å‡ æ¬¡äº¤æ¢çš„æ€æƒ³å¾ˆå·§å¦™
// æ¯æ¬¡æ‰¾å‡ºå½“å‰åˆ†åŒºå†…çš„ç‚¹pivitï¼Œæ¯”pivitå°çš„ç‚¹åœ¨å…¶å·¦ï¼Œæ¯”pivitå¤§çš„ç‚¹åœ¨å…¶å³
// åˆ†åŒºä»¥äºŒåˆ†é€’å½’æ±‚å‡º

int partition(int num[],int low, int high){ // åˆ†åŒºçµé­‚æ“ä½œ
	int p = num[low];
	while(low < high){
		while(num[high] >= p && low <= high){
			high--;
		}
		num[low] = num[high];
		while(num[low] <= p && low <= high){
			low++;
		}
		num[high] = num[low]; 
	}

	num[low] = p;
	return low;
}

void quick_sort(int num[],int low, int high){
	if (low > high ) return ;
	int mid = (low + high) /2;
	int p = partition(num,low,high);
	quick_sort(num,low,p-1);
	quick_sort(num,p+1,high);
}
```
#### åŸºæ•°æ’åº
```c++
// åŸºæ•°æ’åº base_sort()

int power(int base, int times){
	int ans=1;
	for(;times;times>>=1){
		if(times&1) ans *= base;
		base *= base;
	}

	return ans;
}


int get_digit(int num, int digit, int base){ // æœ€ä½ä½ä»1å¼€å§‹è®¡æ•°ï¼Œå³digitâ‰¥0
	return (num/power(base,digit-1)) % base;
}

int get_max(int num[], int n){
	int ret = num[0];
	for(int i=0;i<=n;i++) if(ret < num[i]) ret = num[i];
	return ret;
}

int get_max_digit(int MAX, int BASE){
	int ret=0;while(MAX) MAX/=BASE, ret++;
	return ret;
}

void base_sort(int num[], int n){  // å¾…æ’æ•°ç»„numä»0å¼€å§‹ç¼–å·ï¼Œnä¸ºå¾…æ’å…ƒç´ æ•°é‡
	const int BASE = 10;			// å¾…æ’å…ƒç´ çš„åŸºæ•°/è¿™é‡Œæ˜¯åè¿›åˆ¶ï¼Œæ‰€ä»¥ç”¨base=10 

	int MAX_digit = get_max_digit(get_max(num,n), BASE); //cout<<"MAX_digit = "<<MAX_digit<<endl;
	int docker[BASE+1][M_size]={0},cnt[BASE+1]={0};
	int ans[M_size];


	for(int i=1,top=0;i<=MAX_digit;i++,top=0){	// ä»ç¬¬ä¸€ä½å¼€å§‹åˆ°æœ€å¤§ä½ï¼Œè¿™é‡Œå› ä¸ºget_digitå‡½æ•°æ˜¯ä»1å¼€å§‹è®¡æ•°çš„

		for(int j=0;j<BASE;j++) cnt[j]=0;

		for(int j=0;j<n;j++){
			int tep = get_digit(num[j],i,BASE);
			docker[tep][++cnt[tep]]= j;
		}

		for(int j=0,temp=0;j<BASE;j++,temp=0){ 
			while(temp<cnt[j]){
				ans[top++] = num[docker[j][++temp]];
			}
		}

		for(int j=0;j<n;j++) num[j] = ans[j];  // è¿™é‡Œè¦æ³¨æ„ansæ•°ç»„å’Œnumæ•°ç»„çš„å‚¨å­˜èŒƒå›´ã€‚ä¹‹å‰å› ä¸ºè‡ªå·±ç–å¿½ï¼Œansæ•°ç»„ä»1ï½nå‚¨å­˜ï¼Œnumæ•°ç»„ä»0ï½n-1å‚¨å­˜ï¼Œå‡ºäº†é”™ã€‚
	}
}
```
#### å †æ’åº
```c++
// å †æ’åº

const int  Msize=1e4+10;

typedef struct {
	int key;
} node;
typedef node SeqList[Msize];

void heapify(SeqList R, int low, int high){ // å †æ’åºåŒºé—´ low ï½ high

	while(low < high){
		int lchild = low<<1, rchild=lchild+1;
		int next = R[lchild].key >= R[rchild].key?lchild:rchild;
		if(next<=high){
			if(R[low].key < R[next].key){
				swap(R[low].key, R[next].key);
			}
			else break;
		}
		low = next;
	}
}

void buildheap(SeqList R, int node_sum){
	for(int i=node_sum>>1;i;i--){
		heapify(R,i, node_sum);
	}
}

void heap_sort(SeqList R, int node_sum){

	buildheap(R,node_sum);
	for(int i=node_sum;i;i--){
		// R[1].key = ans[++top];
		swap(R[1].key, R[i].key);
		heapify(R, 1, i-1);
	}

	// cout<<"R sortting : "<<endl;
	// for(int i=1;i<=node_sum;i++) cout<<R[i].key<<" ";cout<<endl;
}
```


### ç¦»æ•£åŒ–
ä¸€ç§æ˜ å°„æ€æƒ³ã€‚æŠŠæ— ç©·èŒƒå›´å†…çš„å…ƒç´ æ˜ å°„åˆ°æœ‰é™èŒƒå›´å†…ã€‚å’Œæ’åºæ€æƒ³ç»“åˆå¯ä»¥è§£å†³è®¸å¤šé—®é¢˜ã€‚


### ä¸­ä½æ•°
+ è´§ä»“é€‰å€ çš„åŸºæœ¬æ€æƒ³ã€‚
+ å¯¹é¡¶å †ã€‚


### ç¬¬Kå¤§æ•°
+ å¿«æ’ã€‚ï¼ˆé€‰æ‹©ä¸€ä¸ªå€¼ï¼Œå°†å‰©ä¸‹åŒºé—´å†…æ•°å­—å°äºè¯¥å€¼çš„æ’å·¦ï¼Œå¤§çš„æ’å³ã€‚é€’å½’æ±‚è§£ï¼‰


### é€†åºå¯¹
+ åˆ©ç”¨å½’å¹¶æ’åºçš„è¿‡ç¨‹ç‰¹ç‚¹ï¼Œè®¡ç®—å‡ºé€†åºå¯¹ã€‚
+ æ­£ç¡®æ€§åœ¨äºï¼Œæ¯æ¬¡å½’å¹¶æ—¶çš„é€†åºå¯¹è®¡æ•°åŒºé—´è¢«é™å®šåœ¨äº†å½“å‰ l ï½ R å†…ï¼Œæ‰€ä»¥å›æº¯æ—¶ä¸ä¼šæ‹…å¿ƒå¤šè®¡æ•°ã€‚
	
	```c++
	void merge(int l, int mid, int r){
	// cnt is the value of reverse number
	// b[] is an temporary array
		int i = l, j = mid + 1;
		for(int k=l;k<=r;k++){
			if(j>r|| i<=mid && a[i]<a[j]) b[++tot]=a[i++];
			else b[++tot]=a[j++],cnt+=mid-i+1;
		}
		for (int k=l;k<=r;k++) a[k]=b[k];
	}
	```
	
+ å¥‡æ•°ç é—®é¢˜ã€‚ï¼ˆn*m æ•°ç é—®é¢˜ï¼‰ 



## 0x06 å€å¢
æœ¬èŠ‚ç ”ç©¶åºåˆ—ä¸Šçš„å€å¢é—®é¢˜ï¼ŒåŒ…æ‹¬RMQï¼ˆåŒºé—´æœ€å€¼ï¼‰çš„STç®—æ³•ã€‚æ ‘ä¸Šå€å¢è§0x63ã€‚


### å€å¢ + äºŒè¿›åˆ¶åˆ’åˆ†
æ¯æ¬¡å€å¢ p<<=1, æˆ– p>>=1; ä¸¤å€è·³è·ƒã€‚ 


### ST ç®—æ³•
æ±‚è§£ åŒºé—´ æœ€å€¼ã€‚ä»åŒºé—´ä¸­ä¸‹æ ‡ä¸ºiå…ƒç´ å¼€å§‹ï¼Œè®°å½•i å¾€å é•¿åº¦ ä¸º $2^{j}$ çš„åŒºé—´æœ€å€¼ã€‚
```c++
void ST_prework(){
	for(int i=1;i<=n;i++) f[i][0]=a[i];
	int t=log(n)/log(2)+1;
	for(int j=1;j<t;j++){
		for(int i=1;i<=n-(1<<j)+1;j++){
			f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
		}
	}
}

int ST_query(int l, int r){
	int k=log(r-l+1) / log(2);
	return max(f[l][k],f[r-(1<<k)][k]);
}
```



## 0x07 è´ªå¿ƒ
è´ªå¿ƒåœ¨æ¯æ¬¡å†³ç­–æ˜¯é‡‡å–å½“å‰æ„ä¹‰ä¸‹æœ€ä¼˜ç­–ç•¥ã€‚è´ªå¿ƒæ³•å¯è¡Œ ä»…å½“ é—®é¢˜çš„æ•´ä½“æœ€ä¼˜æ€§å¯ä»¥ç”±å±€éƒ¨æœ€ä¼˜æ€§å¯¼å‡ºã€‚

è´ªå¿ƒæ­£ç¡®æ€§è¯æ˜ï¼š
+ å¾®æ‰°ã€‚ï¼ˆé‚»é¡¹äº¤æ¢ï¼‰
+ èŒƒå›´ç¼©æ”¾
+ å†³ç­–åŒ…å®¹æ€§
+ åè¯
+ æ•°å­¦å½’çº³


ğŸ‘‰ Instance:
Sunscreen, poj 3614