# Malicious Code Detection - A survey



## 恶意软件检测
### Overview

![](../../../../../../Assets/Pics/Screenshot%202024-04-11%20at%209.52.18%20PM.png)
https://www.mdpi.com/2076-3417/12/17/8482

![](../../../../../../Assets/Pics/Screenshot%202024-04-13%20at%209.22.09%20PM.png)
<small>Shares of different operating systems in global market. https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub</small>


### 1.恶意软件分析方法与分析数据类型
https://link.springer.com/article/10.1007/s10207-022-00626-2
在一项调查研究中，Sharma 和 Rattan 对安卓恶意软件检测进行了综述[7]。他们将恶意软件分析技术分为三类，即静态分析、动态分析和混合分析。静态分析是指在不执行应用程序的情况下查看 apk 文件，主要关注清单和源代码文件。在某些情况下，恶意软件作者会混淆 apk 文件，通过增加分析时间来降低恶意软件的检测效率。尽管如此，静态分析仍是一种快速、流行的恶意软件检测技术。动态分析是静态恶意软件分析的替代方法。通过动态分析，可以执行应用程序并观察其行为。在动态分析中，需要一个独立、隔离的环境来运行应用程序。动态分析是一个更复杂的过程，可能会耗费资源和时间。不过，它是一种广泛使用的可靠技术。最后，混合策略结合使用静态分析和动态分析，通过同时使用两种分析方法来检查应用程序。静态分析的一大优势是其轻量级基础架构和低成本高效率。
#### 静态分析
https://www.mdpi.com/2076-3417/12/17/8482

静态分析方法通过探索源代码而不运行可执行文件来提取唯一的签名，用来表示被调查的文件，这种方法已被广泛使用。通过静态分析可收集多种类型的静态数据，包括 PE 头数据 [30,31,32,33]、衍生数据（如基于字符串的熵和压缩率）[34,35,36,37]。此外，静态分析工具（如 IDA pro 反汇编器和 Python 开发的模块）也用于收集静态操作码和 API 调用 [38,39,40,41,42]。尽管静态分析可以跟踪所有可能的执行路径，但它会受到打包和加密技术的影响。

![](../../../../../../Assets/Pics/Screenshot%202024-04-13%20at%209.23.50%20PM.png)
<samll>Process of static analysis in android malware https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub</small>
##### 安卓恶意软件静态分析中常用的特征
https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub

![](../../../../../../Assets/Pics/Screenshot%202024-04-13%20at%209.25.31%20PM.png)
<small>https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub</small>

1. 权限： 在权限中，安卓应用程序有一个权限术语，它要求任何安卓应用程序在执行代码部分，特别是运行其功能时，必须请求相应的特定权限。例如 访问外部存储空间的读取和写入权限、访问互联网的权限等。这些权限限制了任何应用程序在未经用户同意和许可的情况下执行任何后台活动，以及在未经许可的情况下运行[4,17]。例如，SEND_SMS，如果一个应用程序想要发送短信，那么机器人系统会检查该应用程序是否拥有该权限，只有获得该权限的应用程序才能发送短信，否则该应用程序将无法发送短信。其他任务也是如此。AndroidMani- fest.xml 是应用程序 .APK 文件夹中的一个文件，其中包含应用程序请求权限的所有信息。
2. 意图： 它是一个简单的消息对象，用于在安卓组件活动、内容提供者、广播接收者和服务之间进行通信。执行任何需要系统干预的操作，如拨打电话、摄像头捕捉图像或视频等，或执行任何其他适当的操作、使用意图，因此有助于分析和理解任何恶意软件应用程序的恶意行为。分析和理解任何恶意软件应用程序的恶意行为 [4,53]。
3. 硬件组件： 许多硬件组件被嵌入到设备的主板中，以提供有用的功能，如 GPS、麦克风、陀螺仪等。但同样，它们也可能被恶意软件应用所利用，从而泄露用户的个人信息。因此，研究和分析这些活动将有助于识别恶意软件应用程序 [4,10]。
4. 安卓应用程序元数据信息： 安卓应用程序商店中的应用程序信息可用于分析应用程序。可用于此目的的因素有很多，如应用程序包名称、开发者信息、星级、评星人数、评论、应用大小、截图数量、宣传视频等。这些因素都有助于对应用程序进行分类 [4,10]。
5. API 调用： Android .apk 文件包含多种文件，其中有一个名为 .dex 文件或 classes.dex 文件的文件，该文件包含类的源代码信息。但这个 .dex 文件不是人类可读的。因此，需要对它进行一些转换，使其成为人类可读的文件。可以将其转换为 java 文件，这样就可以很容易地从文件中分析 API 调用数据。这些 API 调用细节可用于安卓应用程序的静态分析 [4,10,18]。
6. 基于图形或结构： 由于可以从 classes.dex 文件中提取文件的源代码，因此可以利用这些源代码创建语句依赖图，从而帮助对安卓应用程序进行静态分析。假定语句为节点，控制流为节点路径，就可以将一种恶意代码模式转换为图形。因此，这些图形模式可用于检测其他应用程序中的同类恶意应用程序内容。在这种情况下，可以创建数据流图和与函数调用相关的图来设计恶意程序检测模式[54-56]。
7. 污点分析： 污点分析是用于检测的数据流分析的一种特殊情况。它是一种检测敏感数据从源到汇的流动的方法 [57, 58]。为此要对源数据和病态数据进行分析。源是指功能从系统中获取的数据，如获取设备 ID 的功能；汇是指用于从系统发送敏感信息的点，如向高级号码发送短信。
8. 字符串/Opcode/URL： 字符串可用作静态分析的参数。在这种情况下，研究人员可以使用多种方法搜索代码中的特定字符串。这种方法适用于 Java 代码。可以从良性和恶意应用程序的代码中搜索任何特定字符串，以便进行分类。它可以是任何关键字、操作码或用于特定目的的 URL。Wang 等人[59]对网络流量进行了测试分析，以对应用程序进行分类。Parker 等人[60]认为，使用 blacksamli 反汇编器反汇编应用程序并将其转换为dalvik 字节码，然后删除除操作码之外的其他组件，并将操作码用于分析目的。
9. Java 字节代码/APK-API 映像： Java 字节代码以图像的形式用于调查过程。根据研究，Java 源代码中的对象和类会根据清单文件中提到的权限进行分析[61,62]。Hang [63] 和 Kumar [64] 使用图像文件作为静态分析功能。应用程序文件（.APK）使用其字节码转换为图像，然后使用机器学习方法对图像进行分类分析[65]。
10. 系统事件/服务-广播-接收器： 系统服务是用于应用程序与系统交互的事件，可从应用程序接口获取[66]，这些事件可用作分析过程的特征。服务可分为定位、搜索、连接、电话等。[66]. Wei 等人[67]在研究中使用了系统功能组合作为参数。Android 应用程序可借助广播接收器与系统和其他应用程序进行交互 [68]。系统事件在这些消息中广播，相关应用程序监听特定消息并执行其操作，如（BOOT_COMPLETED、SMS_RECEIVED、CONNECTIVITY_CHANGE 等......）。
#### 动态分析
https://www.mdpi.com/2076-3417/12/17/8482

一些研究人员采用动态分析方法收集各种数据类型，通过在隔离环境、虚拟机（VM）或模拟器中运行可执行文件来监控可执行文件在运行期间的行为，然后收集所需的动态数据，从而区分恶意软件和良性文件[43]。利用动态分析方法收集了各种数据。恶意活动可通过可执行文件行为和运行时保留内存图像来动态表示。可执行文件行为可通过收集调用的 API 调用[44,45,46,47,48]、机器活动[47,49,50]、文件相关数据[51,52,53]以及注册表和网络数据[45,54]来识别。基于 Opcode 的内存图像可动态表示恶意活动 [15]。尽管经过混淆处理的恶意软件在动态分析时无法隐藏其行为方式，但动态分析无法满足所有恶意条件以探索所有执行路径。

![](../../../../../../Assets/Pics/Screenshot%202024-04-13%20at%209.26.28%20PM.png)
<samll>Process of dynamic analysis in android malware https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub</small>
##### 安卓恶意软件动态分析中常用的特征
https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub

![](../../../../../../Assets/Pics/Screenshot%202024-04-13%20at%209.25.57%20PM.png)
<small>https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub</small>

1. 系统调用： 根据安卓系统的架构，当用户试图执行任何活动时，安卓运行时系统会在内核中执行系统调用来执行该任务。因此，通过收集系统调用日志，使用系统调用分析可以检测到一些在静态分析中无法检测到的事件。当事件在模拟器中执行时，系统调用的日志记录就会被准备好，这些系统调用可用于分析活动并找出恶意活动。
2. 信息流（污点分析和网络流量）： 信息流是一种用于跟踪设备通过其网络的信息流的方法。在污点分析中，为了分析的目的，源和汇都会被观测到 [101,323]。另一方面，在网络流量分析中，可以对数据包的大小、类型、进出频率等不同参数进行分析。信息从源传播到目的地，信息流用于分析恶意活动。SCDFLOW [324]（选择关键数据流）系统通过检查数据流的频率来分析关键数据流。根据研究[325]，网络上共享的大部分网络流量都是良性的，只有一小部分是恶意的，这部分可以通过分析恶意和良性应用程序的数据流来检测出来。
3. 函数调用监控： 可以使用 API 框架动态监控函数调用，这种方法可用于跟踪函数调用和使用的参数，从而重建函数调用序列，这可能有助于分析过程[4]。
4. 依赖关系图： 为特定的敏感/可疑代码创建控制流图，然后使用该图模式对应用程序进行分类分析。这种方法主要用于已知恶意软件可疑代码的情况，我们希望对恶意软件家族进行分类 [19]。
5. 硬件组件分析： 在本系统中，运行中的硬件组件被用于分析目的。例如：使用电池数据 [3,4]：电池状态、温度、充电器状态、电池电量。系统参数也用于此目的，如 CPU 使用率、CPU 内存、应用程序内存等。其他硬件组件 GPS、Wi-Fi 硬件等。
6. 使用的 API 和权限： 在静态和动态分析过程中，可以对一些因素进行分析，如权限和 API。在执行应用程序时，使用的权限也是非常重要的因素[302,314]。与此相反，在动态分析中也可以对 API 进行分析，以获得更好的结果 [278,326]。
7. 与外部通信： 手机用于各种通信目的。有一些因素，如短信、电话、URL、WiFi、GPS 和蓝牙，可使系统与其他外部实体建立联系 [177,308]。因此，所有这些通信因素都可以作为单一因素或多个因素的组合来进行分类。
8. 代码注入： 在源代码中注入特殊代码以检测恶意行为。Fan 等人[310]开发了一种 DroidInject 方法，在源代码中注入代码，然后在运行时执行该代码，跟踪目标 API 的进程，并为分析过程创建日志。用注入的代码重新打包目标应用程序，然后监控应用程序用于高级短信的联系人[311]。
9. 9. 运行时用户界面： 图形用户界面可用于检测重新打包的应用程序 [315-317]。Yue 等人[315]开发的 RepDroid 方法使用布局结构来监控重新打包的应用程序。在不执行整个应用程序的情况下，利用用户界面信息检测应用程序的克隆。
10. 动态代码加载（DCL）： 应用程序在执行时也会加载代码，这些代码被称为动态加载代码。有时，应用程序会使用 DCL 加载恶意代码。这一特性可用于监控过程 [180,254,301]。目前已开发出多种方法来检测应用程序运行时的动态代码加载 [180,327,328]。
#### 混合分析
https://www.mdpi.com/2076-3417/12/17/8482

以往的一些研究将通过静态和动态分析提取的数据结合在一起，以减少两种分析方法的弊端，实现更高的检测率。这些研究采用 Cuckoo 沙盒、IDA pro 反汇编器和 OlleyDbg 等不同工具收集动态和静态数据，然后根据字符串、操作码、API 调用等几类数据创建混合特征集 [55,56,57,58,59]。尽管混合分析方法得益于静态分析和动态分析的优点，但也存在它们的缺点。

---
https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub

表 6 介绍了用于创建混合技术的各种静态和动态技术的映射。它显示了静态和动态技术的不同组合。从表中可以看出，H2 被大多数研究人员用于开发混合技术。静态部分包括许可证（S1）和应用程序接口（S6），动态部分使用系统调用（D2）。
用于动态部分。图 11 显示了混合技术中所有静态和动态特征的映射。其中，静态部分的 S1 和 S6 以及动态部分的 D1 和 D6（与外部通信）是组合或混合技术中使用最多的方法。

![](../../../../../../Assets/Pics/Screenshot%202024-04-13%20at%209.27.10%20PM.png)
<small>https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub</small>

![](../../../../../../Assets/Pics/Screenshot%202024-04-13%20at%209.51.04%20PM.png)
<small>https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub</small>

#### 恶意软件分析和数据类型
下图显示了每种分析方法中使用最多的数据类型。在 x 轴上，数据类型包括字符串 (St)、PE 头 (P-h)、操作码 (Op)、API 调用 (API)、动态链接库 (DLL)、机器活动 (MA)、进程数据 (PD)、文件数据 (FD)、注册表数据 (RD)、网络数据 (ND) 和派生数据 (DD)。同样，静态、动态和混合数据也作为分析方法映射在 y 轴上。横向和纵向虚线说明了每种数据类型与每种分析方法之间的关系，显示了文献综述中每种数据类型与每种特定分析方法的使用频率。

![](../../../../../../Assets/Pics/Screenshot%202024-04-11%20at%209.56.19%20PM.png)
https://www.mdpi.com/2076-3417/12/17/8482


### 2.恶意软件检出方法
恶意软件检测过程是发现和识别被调查文件的恶意活动所必须实施的机械化过程。检测恶意软件方法不断改进，但没有100% 的成功率。

恶意软件的检测主要基于两个特征，即签名和行为；使用三种恶意软件检测方法，即基于签名的方法、基于行为的方法和基于启发式的方法。

![](../../../../../../Assets/Pics/Screenshot%202024-04-11%20at%2010.02.29%20PM.png)
https://www.mdpi.com/2076-3417/12/17/8482 （table 2）
#### 基于特征（signiture）（已有规则/模式匹配）
https://www.mdpi.com/2076-3417/12/17/8482

为了改进恶意软件检测和分类模型，已经开展了多项研究，这些研究依赖于先前静态或动态提取并存储的独特签名，并将其与收集到的调查文件签名进行比较。这些签名包括但不限于一组 API 调用、操作码或字节码系列以及熵量。文献[35,60]通过使用频率向量表示所获得的字符串，生成了基于字符串的静态签名，用于检测 VBasic 恶意软件；文献[61]则生成了基于 n-grams 和二进制向量的静态签名。此外，[38] 还利用操作码的统计值形成了恶意静态签名。另一方面，行为签名是基于动态收集的数据构建的。文献[48,62,63]的作者利用恶意软件在运行期间调用的 API 调用创建了行为签名。特定的 API 调用集被认定为反映了恶意活动，因此行为恶意签名就是利用这些 API 调用构建的。基于静态和行为签名的恶意软件检测模型在对可能与未知恶意软件或已知恶意软件的不同变种相关联的未知签名进行分类时，检测率较低。

---
https://arxiv.org/abs/2403.12482
基于规则的方法通常依赖于有关软件包元数据（如软件包名称）、可疑导入和方法调用的预定义规则。许多研究 [7,8,9,41] 侧重于检测静态特征，如访问网络的库、访问文件系统、包元数据中的特征、动态分析，或与语言无关的特征，如提交日志和存储库元数据，从而使用启发式规则将包标记为可疑包。

差异分析包括将先前版本与目标版本进行比较，以分析差异并识别恶意行为。这些工具 [19,24,32,33] 利用 artifacts、文件哈希值 (file hashes)和 "幽灵行(phantom lines) "来显示软件包和源代码库版本之间的差异。

#### 基于行为（已有规则/模式匹配 + 当前行为分析）
https://www.mdpi.com/2076-3417/12/17/8482

在隔离环境中监控可执行文件并收集表现出的行为后，开发了特征提取技术来提取敏感特征，通过这些敏感特征，开发的模型可以对已知的恶意行为以及任何与之相似的行为进行分类，从而识别假阳性行为。与基于签名的方法相比，这种方法能够在运行时收集行为的基础上识别已知行为之外的新型恶意软件行为，因此更有价值。因此，文献综述中的大多数研究都侧重于使用基于行为的方法，以连续、连续和常见行为的形式来提高恶意软件的检测率。
一些研究是基于提取的连续行为进行的，这些行为由机器活动表示。文献[41]的作者对 Windows 平台很感兴趣，他们使用 Cuckoo 沙盒提取机器活动数据（CPU、内存、接收和发送的数据包）。之后，观察结果被转化为向量，用于训练和评估分类算法。以前的研究大多关注提取 API 调用、系统调用、操作码等，将其按顺序（顺序行为）或有序模式形成，以了解恶意功能。顺序或有序模式可以是 API 调用、注册表数据和网络数据 [13,40,45] 或操作码序列 [76]。此外，在二元分类模型中，恶意软件和良性样本所执行的共同行为可用作将被调查文件划分为恶意软件或良性类别的指标。此外，在多分类模型中，可以在每个恶意软件家族中观察到这些共同行为。所开发的模型只根据常见行为对测试文件进行分类，从而缩短了匹配过程的时间。文献[10,77]通过观察每个恶意软件系列中最常见的行为图，提出了基于常见行为图的恶意软件检测和分类模型。此外，参考文献 参考文献[78]根据每个恶意软件系列提供的常见 API 调用序列，提出了使用（LSTM）长短期模型的二进制和多分类模型。
#### 基于启发（根据已有规则自我学习扩展规则并匹配 + 当前行为分析）
https://www.mdpi.com/2076-3417/12/17/8482
各种研究都采用了基于启发式的方法，通过动态或静态分析生成通用规则来调查提取的数据，以支持所提出的恶意意图检测模型。生成的规则可以使用机器学习技术、YARA 工具和其他工具自动开发，也可以根据专家分析师的经验和知识手动开发。
- 已有多项研究开发了恶意软件检测模型，根据使用机器学习技术和 YARA 工具创建的自动行为规则做出决策 [45,47,54]。
- 另一方面，参考文献[34]基于静态提取的字符串数据，关注手动生成通用规则，以识别恶意软件使用 HTML 元素和 JavaScript 函数可能实现的恶意活动。
- 此外，文献[76]还开发了基于（DNS）域名系统的规则，以建立僵尸网络攻击检测模型。所提出的模型根据人工制定的通用规则做出最终决定，这些规则可以检测到 DNS 查询和响应中的异常情况。
#### 基于AI模型（也算是启发式？）
##### 基于传统ML
https://arxiv.org/abs/2403.12482

研究 [18,25]评估了各种有监督的 ML 模型，以确定有效的 ML 模型来检测恶意软件。
此外，还有多项关于检测错别字攻击(typosquat attacks)的研究 [31,33]。

---
https://link.springer.com/article/10.1007/s10207-022-00626-2
对相关工作的回顾表明，在恶意代码的静态分析中采用了各种机器学习模型和模型特征。最常见的模型和学习算法包括决策树（DT）、支持向量机（SVM）、奈夫贝叶斯（NB）、逻辑回归（LR）、集合学习（EL）、在线学习（OL）、K-近邻（KNN）和神经网络（如 RNN、CNN、MLP、LSTM）。
此外，Android 恶意软件检测模型还选择了多种特征，包括应用程序权限、API 调用、意图、操作码序列、程序图（如函数调用图、控制流图）以及从 Android apk 文件中获取的硬件特征 [8]-[19]。

进一步回顾学习方法在恶意代码检测中的应用可以发现，操作码序列经常被用于恶意软件检测。
- 例如，McLaughlin 等人提出了一种基于 CNN 的恶意软件检测方法 [20]。他们使用 Baksmali [44] 工具提取操作码序列，并提出了一种分层去噪网络模型，通过使用编码器来解决 LSTM 的梯度消失问题。因此，基本思路是使用 Baksmali 将每个 apk 文件拆解为 smali 文件，然后删除操作数，以获取所有 smali 文件中每个方法的操作码序列。将操作码序列汇集成单个操作码序列，就可以表示整个应用程序。然后将应用程序的文本表示输入 CNN 模型以进行检测。这项研究的主要优点是不需要对数据准备进行复杂的人工预处理。
- Parker 等人使用相同的数据准备和反汇编工具进行了类似的研究[21]。不过，他们使用了两种不同的分类方法，即加权序列模型和修正多层向量空间模型。他们的方法没有明确针对安卓恶意软件检测。他们的结果达到了 79% 的准确率。
- 在另一项研究中，Li 等人采用了相同的数据预处理方法，使用不同的反汇编器（即 Apktool）来收集 smali 文件[22]。他们使用了 k-max 池模型，并将其模型与 RF、DT、SVM、Naïve Bayes 和 MLP 等一系列经典机器学习模型进行了比较。他们的模型准确率达到 99%，表现优于其他模型。

---
https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub

机器学习是一种可用于执行自动分析流程的技术，它从定义的特征中获得训练，也有利于检测零日漏洞[375]。在分析了最近的研究论文后，发现共有 44 种机器学习算法。其中五种算法较为流行。根据图 14 中的图表，SVM、随机森林、奈夫贝叶斯网络、kNN 和决策树被大多数研究人员使用。
- [83,120] 在他们的研究中提到，与随机树和其他机器学习技术相比，SVM 的准确率较高，因此表现良好。
- Rana 等人[347]比较了各种机器学习算法的性能。结果表明，SVM、随机森林和 kNN 与其他算法相比表现出色，准确率超过 90%。
- Kumar 等人[219]使用机器学习，比较了从各种算法中提取的结果，发现 SVM 性能更好，准确率超过 95%。
- 一种新的并行机器学习方法，他们同时使用了不同的分类器，如基于规则的、基于函数的、基于树的和基于概率的分类器，这些分类器被并行使用，它们的结果被组合在一起，并获得了很高的准确率[160]。但这项研究之后，这种方法并没有得到广泛应用。
- Ma 等人[376]开发了一种新方法，其中使用了 2 层机器学习，他们在第一层使用了 SVM，然后在第二层使用了 NB-SVM、RBF-SVM 和 2 层线性-SVM，并发现 RBF-SVM 取得了很好的效果。
- 如图7所示，分类算法根据其工作类别进行分类。它将其分为 9 个不同的类别，并相应地组织了各种参与算法。从图中可以看出，深度学习拥有大量算法，根据最近的研究论文，共提到了 16 种方法。与其他深度学习算法相比，CNN 是最受欢迎的算法。但与其他算法相比，它排在第 6 位，因为只有 16 篇论文使用了 CNN 进行应用分类。生成对抗网络（GAN）也在最新研究[51,258,376]中进行了讨论，用于评估恶意软件检测器的性能。生成对抗样本会误导检测过程，从而找出机器学习分类系统中的漏洞 [258,360,361]。

![](../../../../../../Assets/Pics/Screenshot%202024-04-13%20at%209.37.59%20PM.png)
<small>https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub</small>

![](../../../../../../Assets/Pics/Screenshot%202024-04-13%20at%209.28.44%20PM.png)
<small>https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub</small>
##### 基于NLP大模型
https://link.springer.com/article/10.1007/s10207-022-00626-2
许多研究采用自然语言处理（NLP）深度学习模型来开发恶意软件检测方法。
- Karbab 等人利用 NLP 模型，提出了一个依靠 API 方法调用序列来检测和分类安卓恶意软件的框架 [24]。他们使用 Python 的 zip 库从 apk 文件中获取 dex 文件，用于提取 API 调用。使用 dexdump 从 dex 文件中获取 Dalvik 汇编代码。然后利用正则表达式提取 API 调用序列。这些序列用 word2vec 生成语义向量，然后输入 CNN（卷积神经网络）模型进行检测和分类。建议的框架达到了 96-99% 的检测准确率。
- 在一项类似的研究[26]中，Ma 等人提出了一种名为 Droidetec 的方法，该方法利用 API 调用以自然语言序列表示应用程序。他们使用 Androguard [43] 工具从 apk 文件中检索 dex 文件。在提取 API 序列并进行一些预处理后，使用单击向量嵌入和 Skip-Gram 模型来建立序列的输入向量。通过将此输入转发给基于 LSTM 的检测模型来进行检测。除了恶意软件检测，Droidetec 还采用了一种关注机制，利用 API 的权重分布来定位潜在的恶意代码，并输出一份报告，提供恶意代码段的具体信息。Droidetec 的检测准确率超过 97%，恶意代码检测命中率达到 91%。
- Wu 等人[25]采用了类似的语义视图进行恶意软件检测。研究人员使用从 Android 清单文件 AndroidManifest.xml 中提取的请求权限来代替 API 调用。提取之后，采用阈值机制过滤出标准权限。然后，通过 word2vec，权限被表示为单击向量，输入 LSTM 模型进行恶意软件检测。
- Xie 等人提出了一种不同的方法，即基于 LSTM 的动态分析方法[27]。他们使用系统调用作为模型特征，用系统调用序列（即他们术语中的行为语言）来表示程序的行为。该模型在基于主机和基于 Android 的数据集上进行了测试，准确率分别达到 99% 和 95%。
- 在另一项研究中，作者同时使用了静态和动态分析技术，为恶意软件分析提供了混合方法的范例[33]。在静态分析中，他们使用 Apktool 从 Android 清单文件中提取应用程序的权限。使用模拟器和特征收集平台收集了电池、粘合剂、内存和权限，然后将其作为动态分析中的特征。研究人员在 RNN（循环神经网络）和 LSTM 模型上使用了不同的特征组合进行比较分析。结果显示，LSTM 的性能优于 RNN，静态分析的检测率达到 97%，动态分析的检测率达到 93%。
- 最近，一个恶意软件分类框架，即 ROCKY，通过从反编译源代码而不是 Dalvik 字节码或 smali 代码中提取 API 调用、权限、关键词和标记来进行恶意代码检测[28]。它利用 N 标记序列（包括停止标记、特征标记和长尾标记）对源代码进行词法分析。开发人员将 ROCKY 与之前工作中报告的其他神经网络模型进行了比较。他们的研究结果表明，ROCKY 的准确率达到了 97.5%，优于其他模型和特征。
- 与使用 API 调用和权限等特征应用基于语义的技术的研究不同，我们的模型（<a>https://link.springer.com/article/10.1007/s10207-022-00626-2</a>）使用安卓应用程序的 smali 代码，利用 LSTM 模型学习应用程序的行为。

除了前面提到的以操作码序列为重点的研究外，还有许多研究在 LSTM 模型中采用了操作码序列或源代码等特征。
- 例如，Deeprefiner 是一种基于语义的双层恶意软件检测方法[29]。Deeprefiner 的第一层通过向 MLP 模型输入 Android 清单文件和资源目录下其他 XML 文件的向量表示来执行初始检测。然后，未分类的应用程序被转发到第二检测层进行更彻底的检测。在第二层中，Apktool 提取的 dex 字节码使用 Skip-Gram 建模表示为向量，然后送入 LSTM 模型。字节码的预处理包括将所有 dex 指令减少到 15 个指令类别，但不去除类名、字段和方法等信息。
- 其他将操作码序列用于 LSTM 模型的研究包括[31]，其中使用 Apktool 获取操作码序列。然后将操作码转换为 16 位代码表示。该模型还利用操作码序列编码器来减少特征维度。
- 在 [34] 中，Amin 等人采用了类似的方法，使用运算码序列和 LSTM 进行恶意软件检测和家族归属。作者用其他神经网络架构进行了实验。他们指出，BiLSTM 的性能优于其他模型，而且无需对特征进行人工预处理。
- 一项类似的研究使用了从指令调用图中检索到的操作码序列[23]。Androguard 工具用于反编译应用程序，以获取所有执行路径。然后将嵌入的操作码序列输入 LSTM 模型，并通过评估 LSTM 的图表示特征进行检测。
- 在 [32] 中，研究人员报告了在两个数据集上应用 CNN 和 LSTM 模型的实验。对于 LSTM 模型，作者使用 Apktool 提取了 Android 字节码。然后通过单次编码将字节表示为向量，再输入 LSTM 模型。所提出的 LSTM 架构在小型数据集上的准确率为 70%，在大型数据集上的准确率为 95.3%。
- 在我们的研究中（<a>https://link.springer.com/article/10.1007/s10207-022-00626-2</a>），我们使用了从 smali 文件中获得的指令，没有进行任何人工预处理。我们还在指令中加入了操作码以外的操作数，以避免进行简化假设。我们研究的一个独特方面是对反汇编工具作用的调查。我们使用 Apktool、JEB 和 IDA Pro 对 apk 文件进行反汇编，以获得 smali 文件，并报告其差异。

### 3.恶意软件特征提取与展现
![](../../../../../../Assets/Pics/Screenshot%202024-04-11%20at%2010.09.43%20PM.png)
https://www.mdpi.com/2076-3417/12/17/8482


![](../../../../../../Assets/Pics/Screenshot%202024-04-11%20at%2010.17.29%20PM.png)
https://www.mdpi.com/2076-3417/12/17/8482
**Table 3.** Summary of detection approaches, extraction, and representation methods.

#### 特征提取（Feature Extraction）
总结：
1. **基于N-gram的提取**：尽管使用 N-gram 方法提取特征似乎颇受作者欢迎，但这种技术会产生大量特征，使基于 N-gram 的模型受到高维度的困扰。
2. **基于频率的提取**：基于频率的特征提取方法只提取最常出现的特征，从而减少了提取特征的数量，这有助于克服高维空间的问题。然而，混淆技术可以调整每个变体中某些特征的频率，从而使基于频率的方法失效。
3. **基于通用图谱的提取**：虽然不可能为每种类型的恶意软件开发出独一无二的图谱，但一些研究采用了基于图谱的特征提取方法，利用共同特征构建通用图谱。另一方面，匹配程序导致基于图的模型随着时间的推移而变得非常复杂。有些研究将构建的图表示为向量，在表示阶段就对时间匹配问题进行了研究，并提出了解决方案。
4. **基于文本的提取**：另一方面，文本特征已被赋予权重，以指示哪些特征应被提取。基于文本挖掘的模型特别容易受到混淆技术的影响，因为这些权重是通过基于频率的技术（如 TF-IDF）得出的。
5. **基于灰度的提取**：另一个方向是，当生成的数据可以可视化时，使用基于灰色的方法作为特征提取器。可视化提取器的局限性在于，提取的特征将以图像的形式存储，这需要更多的存储空间。无论单词嵌入方法如何捕捉特征（单词）之间的上下文关系，单词的各个方面都可能会提高计算成本，降低模型的整体性能。

![](../../../../../../Assets/Pics/Screenshot%202024-04-13%20at%208.04.28%20PM.png)
<small>Summary of detection approaches, extraction, and representation methods. https://www.mdpi.com/2076-3417/12/17/8482</small>

##### N-gram
##### Text Mining
##### Graph-based Extractor
##### Frequency-Based Vector
##### Word Embedding
##### Iterative-Based Extractor
##### Gray Scale Image-Based Extractor
#### 特征展示（Feature Representation）
总结：
1. **基于二进制展示与频率展示**：根据调查文件中存在的每个特征，可以为该特征分配 0 或 1 的值，从而使用二进制向量来表示被调查的文件。同样，在二进制向量表示方法中使用的值不是 0 或 1，而是计算每个特征的出现次数，从而使用基于频率的向量来描述样本。遗憾的是，特征的存在可以从一种变体变为另一种变体，从而实现相同的恶意活动，同时存在不相关的特征。此外，当恶意软件开发者使用混淆技术提供样本时，基于频率的向量表示方法就会失效。
2. **基于权重展示**：为了缓解基于二进制/频率的表示方法的弱点，一些研究人员尝试使用统计方法对每个特征的权重值进行排序，从而使用权重向量来表示被调查的文件。然而，将文本特征转换为数字特征并不能捕捉到特征之间的上下文关系。
3. **基于图像特征展示**：此外，二进制文件使用向量表示，向量由从恶意软件和良性图像中提取的数字信息组成，这些图像是通过将字节转换为像素生成的，像素颜色从0度到250度逐渐由白变黑，但生成图像需要大量时间，而且将行为存储为图像需要很大的存储容量。
4. **基于规则的展示**：一些研究人员利用 YARA 工具等特定工具生成的规则来描述提取阶段产生的特征。使用基于规则的表示方法，只能识别所创建规则中指定的有害行为。因此，这种表示方法消除了匹配过程的低效率。
##### Binary-Based Vector
##### Frequency-Based Vector
##### Weight-Based Vector
##### Image Characterization-Based Vector
##### Weighted Dependency Graph
##### Rule-Based Representation


### 恶意软件检测数据集
#### 安卓恶意软件检测数据集
https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub

根据以往的研究，有许多数据集可供实验使用。这些数据集包含具体的良性、恶意或两种应用的信息。根据对以往研究论文的分析，大约使用了 66 个不同的数据集。表 8 列出了数据集的相关信息，包括数据集的类型、在实验中使用该数据集的论文数量以及论文的引用情况。其中包括来自不同项目、网站、杀毒软件公司、第三方应用程序商店等的数据集。

图 15 显示了再中心研究中使用的各种数据集的条形图，并按降序排列。图中红色条代表恶意数据集，绿色条代表良性数据集，蓝色条代表恶意和良性数据集。在恶意数据集方面，大多数研究使用了 Drebin 和安卓恶意软件基因组项目，而在良性应用方面，一般使用谷歌 playstore。加拿大网络安全研究所（CIC）也在提供最新的安卓恶意软件数据集[154,176]。CIC 在其网站上为研究界提供了大量恶意软件数据集，即 ISCX Android Botnet 数据集 2015、ISCX Android Validation 数据集 2014、Android Adware and General Malware Dataset (CIC-AAGM2017)、Android Malware Dataset (CIC-AndMal2017)、Android Malware Investigation (CIC-InvesAndMal2019)、CICMalDroid 2020、CCCS-CIC-AndMal2020。Kadir 等人[384] 编制了名为 ISCX Android 僵尸网络数据集的数据集，其中包括来自 14 个僵尸网络家族的 1929 个恶意软件样本，这些数据集相对用于基于机器学习的检测系统。

![](../../../../../../Assets/Pics/Screenshot%202024-04-13%20at%209.32.49%20PM.png)

![](../../../../../../Assets/Pics/Screenshot%202024-04-13%20at%209.33.08%20PM.png)


### 恶意软件检测难题
↗ [Anti-Reverse Engineering & Software Protection](../Anti-Reverse%20Engineering%20&%20Software%20Protection/Anti-Reverse%20Engineering%20&%20Software%20Protection.md)
#### 混淆技术
https://www.mdpi.com/2076-3417/12/17/8482
这些技术最初用于保护软件接触者的知识产权，但最后，恶意程序的编写者利用这些技术将其恶意软件转移到更难分析和检测的不同形式[106,107]。插入死码、注册表重新分配、指令重新排序和指令替换等技术被用来更新恶意软件的特征，同时实现相同的功能[108,109]。根据文献[87]，近 50%的未知恶意程序是旧恶意程序的不同变种，而文献[75]报告称，只有 20% 的新恶意软件是未见过的恶意软件，其中 80% 是相同恶意软件的不同变种。因此，由于恶意软件有多个变种，且各具特色，因此基于特征、序列或频率建立的恶意软件检测和分类模型的检测准确率很低。
#### 逃逸技术
https://www.mdpi.com/2076-3417/12/17/8482
通过执行特定操作，规避型恶意软件能够识别它们是在受控环境还是真实环境中运行。当恶意软件发现显示受控环境的特征时，它们会立即改变自己的行为，表现出与良性行为类似的不同行为，或者停止执行[25]。此外，回避型恶意软件还可以通过利用与沙箱、调试器、虚拟机或监视器相关的特定信息来识别执行环境的性质，并等待用户的动作，如鼠标移动、鼠标点击或其他动作，以此作为开始执行的条件[110]。此外，根据文献[111]，由于反分析技术的使用，64%的反病毒扫描仪在一年后无法检测到约 1%的扫描恶意软件。因此，通过在受控环境中运行样本来获取特征的恶意软件检测和分类模型很难检测到规避性恶意软件。
#### 零日漏洞
https://www.mdpi.com/2076-3417/12/17/8482
以前未被发现的恶意软件通常会通过其恶意活动对系统造成危害，从而实现新的攻击。据我们所知，零时差恶意软件每次发动新的攻击后，在该恶意软件被发现之前可能都会有零时差[112]。未知恶意软件具有实现其目的的新特征，因此基于过去信息设计的恶意软件检测模型在试图检测零时差恶意软件时效率不高[113]。此外，采用新策略实现其目标的零时差恶意软件的比例也在增加[32,114]。根据文献[85]，每天大约产生 350,000 个零日恶意软件。因此，使用恶意软件检测模型来检测在攻击过程中呈现新特征的零时差恶意软件变得更加困难。
#### Redundancy and Irrelevant Behaviours
https://www.mdpi.com/2076-3417/12/17/8482
由于机器学习技术很难处理包含冗余和不相关特征的数据[115]，因此数据集中存在冗余和/或不必要的特征是恶意软件检测领域的问题之一[50,116]。事实上，与某一类无关的冗余/不相关行为会大大提高操作成本，并降低大多数学习者的准确性。因此，生成数据集的任务（包括特征提取和选择阶段）具有挑战性，必须不断改进，以提高所开发模型的整体性能。
#### 假阳/阴
https://www.mdpi.com/2076-3417/12/17/8482
恶意软件作者试图使制作的恶意软件以与合法行为一致的方式完成其功能 [117]。因此，恶意文件和良性样本的某些特征和指纹可能非常相似。有几种恶意软件检测方法容易受到假阳性和假阴性率的影响。虽然假阳性率或假阴性率的增加会降低模型的检测精度，但在有效的恶意软件检测模型中，假阳性率远比假阴性率重要。如果用户计算机上的合法文件被误认为恶意文件，操作系统可能无法启动，其他应用程序也可能无法工作[118]。
#### Incremental Learning
https://www.mdpi.com/2076-3417/12/17/8482
由于恶意软件编写者每天都在开发恶意软件，因此恶意软件分析和检测开发人员对分类器进行了改进，以纳入最先进的恶意活动技术。在收集阶段，首选的训练数据必须通过考虑最新的恶意软件文件来代表现代恶意软件的行为。因此，开发的模型无法捕捉到较早的恶意软件行为，导致无法检测到它们。如何在样本收集阶段充分考虑有害活动的历史趋势，使模型既能识别最近的恶意行为，也能识别较早的恶意行为，这是一个敏感的问题[119]。例如，当测试数据包含较早的恶意软件时，[58] 中提出的模型检测率很低。这是因为所建议的模型是根据最新恶意软件样本的行为进行训练的。因此，所建立的模型无法体现较早恶意软件的行为特征。


### 对各种恶意软件检测方法的评价
https://www.sciencedirect.com/science/article/abs/pii/S1574013721000137?via%3Dihub

- 与其他技术相比，静态分析技术主要用于恶意软件的检测。这是因为静态分析技术易于使用，而且无需执行代码。权限（S1）和 API 调用（S6）是大多数研究人员使用的主要特征。它们可单独使用，也可与其他参数组合使用。但 APK/API 镜像（S4）和覆盖层（S13）也可用于创建高效的恶意应用程序检测系统，因为这些是使用最少的特征。字符串（S10）、数据流（S14）和 URL（S17）也仅在 2018 年的一项机器学习研究中使用过，因此需要进行探索
- 在动态分析技术中，系统调用分析（D1）是动态检测过程中使用最多的特征。如图 18 所示，网络流量（D2）是与机器学习技术结合使用的第二大特征。它可用于跟踪静态分析中未发现的部分，但需要更加谨慎，因为攻击者会在应用程序中注入智能动态代码。在分析过程中，这些代码可能会一直处于非活动状态。因此，有必要在进行动态分析时跟踪这类智能代码。
- 据观察，在混合检测过程中，大多数研究文章都使用了权限（S1）和系统调用（D1）的组合。混合技术性能良好，但会使系统变得复杂。因此，有必要将重点放在轻量级混合分析上，它能涵盖所有分析流程并产生高准确度。
- 机器学习被广泛用于根据特征对应用程序进行良性或恶意分类。我们在回顾中发现，一些智能恶意软件家族使用代码误导算法的训练过程，以提高评估时的误报率。图 18 显示，回归是所有检测过程中使用最多的类别。深度学习和集合也在很大程度上得到了应用，但基于规则的系统、聚类和正则化是最不受欢迎的分类技术。在混合检测系统中，只有回归和集合方法是首选。另一方面，在动态系统中，回归和深度学习是首选。除此之外，许多研究还使用了集合方法。
- 我们在进行综述时，从各种研究中确定了 66 个数据集。关于机器学习，大多数文章都提到了 Drebin 和安卓恶意软件基因组项目。
- 应用程序的重新包装也非常流行，以误导无辜的应用程序用户。重新打包的应用程序发布在第三方应用程序商店中。因此，对第三方应用程序商店进行具体分析是当务之急，因为犯罪嫌疑人会利用第三方应用程序商店传播重新打包的恶意应用程序。

![](../../../../../../Assets/Pics/Screenshot%202024-04-13%20at%209.43.42%20PM.png)


### 未来方向
https://www.mdpi.com/2076-3417/12/17/8482

1. 尽管文献综述中的现有解决方案已经为开发可信的恶意软件检测和分类模型指明了道路，但**逃避型恶意软件的检测仍然具有挑战性**。
2. **为了检测规避型恶意软件，人们采取了多种方法**。例如：生成基于 API 的规避型恶意软件签名、使用多种执行环境发现规避行为，以及使用已知的规避技术来检测规避型恶意软件。
3. **据我们所知，每种规避型恶意软件检测解决方案都有自己的弱点**。例如，如何区分合法行为中使用的规避技术和恶意相关的规避技术仍是一个难题。此外，基于已知规避技术学习开发的模型很难检测和识别未知的规避技术。此外，在时间和资源方面使用多个不复杂的执行环境也是另一个挑战。
#### 可用的规避行为数据集
尽管已经开展了多项研究来提高规避型恶意软件的检测率，但目前还没有可用的数据集来表示规避行为。因此，创建一个规避行为数据集将有助于研究人员努力开发出强大的解决方案。为了检测规避型恶意软件，需要高效的特征提取和表示技术来提取和表示一个特征集，该特征集只表示与恶意行为相关的规避技术。
#### 需要高效的更新学习机制
另一方面，零日恶意软件和未知恶意软件变种的日产量大大增加，因为有了在线工具，人们可以利用这些工具创建新的恶意软件或使用混淆技术重新格式化现有恶意软件，从而引入新的变种。因此，需要高效的更新学习机制，使开发的模型能够自适应地学习即将出现的新行为。为此，可以设计和实施深度学习技术与无监督机器学习技术相结合，用于更新学习和开发能够自适应学习新恶意行为的模型。



## 大语言模型
https://arxiv.org/abs/2403.12482
LLM 现已广泛应用于软件工程中的各种任务，包括代码生成、测试、程序修复和总结 [3,40]。本研究深入探讨了 ChatGPT 在恶意软件检测中的零点学习（zero-shot learning）。零点学习（Zero-shot）是一种技术，可使模型在没有先前示例的情况下处理未知任务。零点学习在各种 NLP 任务中都取得了可喜的成果 [22,34]，思维链（CoT）或逐步推理提示增强了 LLM 生成中间推理步骤的能力 [34]。研究 [14,15,38] 发现了一些有效的 CoT 要素，如零镜头 CoT 和角色扮演提示，它们能提高推理质量。Kojima 等人 [14] 证明了 LLMs 对零镜头推理的熟练掌握，而 Kong 等人 [15] 则发现角色扮演提示能产生更有效的 CoT。Madaan 等人 [16] 观察到，使用 GPT-3.5 和 GPT-4 将 SELF-REFINE 方法应用于从对话到推理的各种任务中，能显著提高性能，并得到了人类和自动计量学的验证。Zelikman 等人 [41] 证实了自创理由对模型自我改进的实用性。

White 等人 [35,36] 的研究表明，用特定领域的信息来增强模型可以提高模型的性能，因为语言模型在生成代码摘要时发现在代码结构中检测特定标识符更有价值。Chen 等人 [6] 研究了 GPT-3 代码生成的性能。他们探索了该模型理解和生成代码的能力，为将此类模型用于代码相关任务的潜力提供了有价值的见解。Ahmed 等人[3]的研究表明，GPT 模型可以利用特定项目的训练，在代码总结方面大大超过最先进的模型。在另一项研究中，Sobania 等人 [29] 利用 ChatGPT 进行代码错误修复，进一步提高了错误修复的成功率。Purba 等人 [22] 开展了一项研究，衡量 LLM 在检测软件漏洞方面的性能。作者得出的结论是，LLM 在检测软件漏洞方面表现不佳，但模型特别善于发现漏洞代码中涉及的常见模式。作者还观察到，ChatGPT 4.0 可以解释给定代码片段的 "意图"。



## 大语言模型智能体
https://arxiv.org/abs/2403.12482
由于 LLM 海量的训练数据集和强大的推理能力，越来越多的人开始将 LLM 作为决策系统的推理核心，以构建类人自主智能体（LLM Agent）。[10,26,37] 这就要求将对 RL 环境的观察结果转化为自然语言，使语言模型更容易处理。语言模型的推理还需要转化为可行的执行操作。常用的提示词技术包括 ReAct [28] 和 Reflexion [17]。人们还探索了其他涉及微调语言模型的方法 [20]。此外，还提出了各种技术来减轻语言模型的偏差（biases）和限制（constrains），包括思维链推理（chain-of-thought reasoning）[13]、外部工具（external tools）[27,39]、外部文档（external documents）[13] 和技能库（skill libraries）[37]。



## Ref
[A study on malicious software behaviour analysis and detection techniques: Taxonomy, current trends and challenges]: https://www.sciencedirect.com/science/article/abs/pii/S0167739X21004751#

[A Malicious Code Detection Method Based on Stacked Depthwise Separable Convolutions and Attention Mechanism]: https://www.mdpi.com/1424-8220/23/16/7084

[Malicious application detection in android — A systematic literature review]: https://www.sciencedirect.com/science/article/pii/S1574013721000137

[Embodied LLM Agents Learn to Cooperate in Organized Teams]: https://arxiv.org/abs/2403.12482

[Malware Detection Issues, Challenges, and Future Directions: A Survey]: https://www.mdpi.com/2076-3417/12/17/8482

[Malicious code detection in android: the role of sequence characteristics and disassembling methods]: https://link.springer.com/article/10.1007/s10207-022-00626-2
