# Malicious Code Detection - A survey



## 恶意软件检测
### Overview

![](../../../../../../Assets/Pics/Screenshot%202024-04-11%20at%209.52.18%20PM.png)
https://www.mdpi.com/2076-3417/12/17/8482




### 1.恶意软件分析方法
https://www.mdpi.com/2076-3417/12/17/8482

恶意软件分析和数据类型对检测过程的影响相当大，而且影响越来越大，它们决定了被调查文件的分类，从而影响了检测模型的整体准确性。我们使用静态、动态和混合分析方法提取了多种类型的数据，如字节代码、操作码、API 调用、文件数据、注册表数据等，以了解和确认被检测文件的主要目的和功能，从而将其分类为恶意软件或良性文件。因此，我们将在下文讨论近期研究中采用的分析方法以及这些研究中提取的数据类型，以确定数据类型的影响和趋势。表 2 列出了每篇综述论文在分析方法和提取数据方面的特点。

#### 静态分析
#### 动态分析
#### 混合分析
#### 恶意软件分析和数据类型
下图显示了每种分析方法中使用最多的数据类型。在 x 轴上，数据类型包括字符串 (St)、PE 头 (P-h)、操作码 (Op)、API 调用 (API)、动态链接库 (DLL)、机器活动 (MA)、进程数据 (PD)、文件数据 (FD)、注册表数据 (RD)、网络数据 (ND) 和派生数据 (DD)。同样，静态、动态和混合数据也作为分析方法映射在 y 轴上。横向和纵向虚线说明了每种数据类型与每种分析方法之间的关系，显示了文献综述中每种数据类型与每种特定分析方法的使用频率。
![](../../../../../../Assets/Pics/Screenshot%202024-04-11%20at%209.56.19%20PM.png)
https://www.mdpi.com/2076-3417/12/17/8482


### 2.恶意软件检出方法
恶意软件检测多年来都是安全研究人员关注的研究问题之一。目前已经提出了几种检测恶意软件包的方法，可分为基于规则的方法[7] [8] [9] [41]、差异分析方法[19] [24] [32] [33]和机器学习（ML）方法[18] [25]。 尽管在这一领域有如此广泛的研究，Ohm 等人 [20] 在一项知识系统化 (SOK) 研究中发现，所提出的方法都不能被视为检测恶意行为的完整和孤立的解决方案。相反，这些方法是审核流程中重要的一部分，可以减少审核人员的工作量。Ohm 等人还呼吁采用更先进、更自动化的恶意软件检测方法，以获得准确、低警报和最小误报的结果。

基于规则的方法通常依赖于有关软件包元数据（如软件包名称）、可疑导入和方法调用的预定义规则。许多研究 [7] [8] [9] [41] 侧重于检测静态特征，如访问网络的库、访问文件系统、包元数据中的特征、动态分析，或与语言无关的特征，如提交日志和存储库元数据，从而使用启发式规则将包标记为可疑包。

差异分析包括将先前版本与目标版本进行比较，以分析差异并识别恶意行为。这些工具 [19] [24] [32] [33] 利用 artifacts、文件哈希值 (file hashes)和 "幽灵行(phantom lines) "来显示软件包和源代码库版本之间的差异。

研究 [18] [25] 评估了各种有监督的 ML 模型，以确定有效的 ML 模型来检测恶意软件。此外，还有多项关于检测错别字攻击(typosquat attacks)的研究 [31] [33]。

---
https://www.mdpi.com/2076-3417/12/17/8482

恶意软件检测过程是发现和识别被调查文件的恶意活动所必须实施的机械化过程。检测恶意软件方法不断改进，但没有100% 的成功率。

恶意软件的检测主要基于两个特征，即签名和行为；使用三种恶意软件检测方法，即基于签名的方法、基于行为的方法和基于启发式的方法。

![](../../../../../../Assets/Pics/Screenshot%202024-04-11%20at%2010.02.29%20PM.png)
https://www.mdpi.com/2076-3417/12/17/8482 （table 2）
#### 基于特征（signiture）（已有规则匹配）
为了改进恶意软件检测和分类模型，已经开展了多项研究，这些研究依赖于先前静态或动态提取并存储的独特签名，并将其与收集到的调查文件签名进行比较。这些签名包括但不限于一组 API 调用、操作码或字节码系列以及熵量。文献[35,60]通过使用频率向量表示所获得的字符串，生成了基于字符串的静态签名，用于检测 VBasic 恶意软件；文献[61]则生成了基于 n-grams 和二进制向量的静态签名。此外，[38] 还利用操作码的统计值形成了恶意静态签名。另一方面，行为签名是基于动态收集的数据构建的。文献[48,62,63]的作者利用恶意软件在运行期间调用的 API 调用创建了行为签名。特定的 API 调用集被认定为反映了恶意活动，因此行为恶意签名就是利用这些 API 调用构建的。基于静态和行为签名的恶意软件检测模型在对可能与未知恶意软件或已知恶意软件的不同变种相关联的未知签名进行分类时，检测率较低。
#### 基于行为（已有模式匹配 + 当前行为分析）
在隔离环境中监控可执行文件并收集表现出的行为后，开发了特征提取技术来提取敏感特征，通过这些敏感特征，开发的模型可以对已知的恶意行为以及任何与之相似的行为进行分类，从而识别假阳性行为。与基于签名的方法相比，这种方法能够在运行时收集行为的基础上识别已知行为之外的新型恶意软件行为，因此更有价值。因此，文献综述中的大多数研究都侧重于使用基于行为的方法，以连续、连续和常见行为的形式来提高恶意软件的检测率。
一些研究是基于提取的连续行为进行的，这些行为由机器活动表示。文献[41]的作者对 Windows 平台很感兴趣，他们使用 Cuckoo 沙盒提取机器活动数据（CPU、内存、接收和发送的数据包）。之后，观察结果被转化为向量，用于训练和评估分类算法。以前的研究大多关注提取 API 调用、系统调用、操作码等，将其按顺序（顺序行为）或有序模式形成，以了解恶意功能。顺序或有序模式可以是 API 调用、注册表数据和网络数据 [13,40,45] 或操作码序列 [76]。此外，在二元分类模型中，恶意软件和良性样本所执行的共同行为可用作将被调查文件划分为恶意软件或良性类别的指标。此外，在多分类模型中，可以在每个恶意软件家族中观察到这些共同行为。所开发的模型只根据常见行为对测试文件进行分类，从而缩短了匹配过程的时间。文献[10,77]通过观察每个恶意软件系列中最常见的行为图，提出了基于常见行为图的恶意软件检测和分类模型。此外，参考文献 参考文献[78]根据每个恶意软件系列提供的常见 API 调用序列，提出了使用（LSTM）长短期模型的二进制和多分类模型。
#### 基于启发（根据已有规则自我学习扩展规则并匹配 + 当前行为分析）
各种研究都采用了基于启发式的方法，通过动态或静态分析生成通用规则来调查提取的数据，以支持所提出的恶意意图检测模型。生成的规则可以使用机器学习技术、YARA 工具和其他工具自动开发，也可以根据专家分析师的经验和知识手动开发。
已有多项研究开发了恶意软件检测模型，根据使用机器学习技术和 YARA 工具创建的自动行为规则做出决策 [45,47,54]。另一方面，参考文献[34]基于静态提取的字符串数据，以人工方式生成了恶意软件检测模型。[34] 则关注手动生成通用规则，以识别恶意软件使用 HTML 元素和 JavaScript 函数可能实现的恶意活动。此外，文献[76]还开发了基于（DNS）域名系统的规则，以建立僵尸网络攻击检测模型。所提出的模型根据人工制定的通用规则做出最终决定，这些规则可以检测到 DNS 查询和响应中的异常情况。


### 3.恶意软件特征提取与展现
![](../../../../../../Assets/Pics/Screenshot%202024-04-11%20at%2010.09.43%20PM.png)

#### 特征提取（Feature Extraction）
尽管使用 N-gram 方法提取特征似乎颇受作者欢迎，但这种技术会产生大量特征，使基于 N-gram 的模型受到高维度的困扰。基于频率的特征提取方法只提取最常出现的特征，从而减少了提取特征的数量，这有助于克服高维空间的问题。然而，混淆技术可以调整每个变体中某些特征的频率，从而使基于频率的方法失效。
虽然不可能为每种类型的恶意软件开发出独一无二的图谱，但一些研究采用了基于图谱的特征提取方法，利用共同特征构建通用图谱。另一方面，匹配程序导致基于图的模型随着时间的推移而变得非常复杂。有些研究将构建的图表示为向量，在表示阶段就对时间匹配问题进行了研究，并提出了解决方案。
另一方面，文本特征已被赋予权重，以指示哪些特征应被提取。基于文本挖掘的模型特别容易受到混淆技术的影响，因为这些权重是通过基于频率的技术（如 TF-IDF）得出的。另一个方向是，当生成的数据可以可视化时，使用基于灰色的方法作为特征提取器。可视化提取器的局限性在于，提取的特征将以图像的形式存储，这需要更多的存储空间。无论单词嵌入方法如何捕捉特征（单词）之间的上下文关系，单词的各个方面都可能会提高计算成本，降低模型的整体性能。
##### N-gram
##### Text Maining
##### Graph-based Extractor
##### Frequency-Based Vector
##### Word Embedding
##### Iterative-Based Extractor
##### Gray Scale Image-Based Extractor
#### 特征展示（Feature Representation）
根据调查文件中存在的每个特征，可以为该特征分配 0 或 1 的值，从而使用二进制向量来表示被调查的文件。同样，在二进制向量表示方法中使用的值不是 0 或 1，而是计算每个特征的出现次数，从而使用基于频率的向量来描述样本。遗憾的是，特征的存在可以从一种变体变为另一种变体，从而实现相同的恶意活动，同时存在不相关的特征。此外，当恶意软件开发者使用混淆技术提供样本时，基于频率的向量表示方法就会失效。
为了缓解基于二进制/频率的表示方法的弱点，一些研究人员尝试使用统计方法对每个特征的权重值进行排序，从而使用权重向量来表示被调查的文件。然而，将文本特征转换为数字特征并不能捕捉到特征之间的上下文关系。
此外，二进制文件使用向量表示，向量由从恶意软件和良性图像中提取的数字信息组成，这些图像是通过将字节转换为像素生成的，像素颜色从0度到250度逐渐由白变黑，但生成图像需要大量时间，而且将行为存储为图像需要很大的存储容量。
一些研究人员利用 YARA 工具等特定工具生成的规则来描述提取阶段产生的特征。使用基于规则的表示方法，只能识别所创建规则中指定的有害行为。因此，这种表示方法消除了匹配过程的低效率。
##### Binary-Based Vector
##### Frequency-Based Vector
##### Weight-Based Vector
##### Image Characterization-Based Vector
##### Weighted Dependency Graph
##### Rule-Based Representation


### 恶意软件检测难题
![](../../../../../../Assets/Pics/Screenshot%202024-04-11%20at%2010.17.29%20PM.png)
https://www.mdpi.com/2076-3417/12/17/8482
**Table 3.** Summary of detection approaches, extraction, and representation methods.

#### 混淆技术
#### 逃逸技术
#### 零日漏洞
#### Redundancy and Irrelevant Behaviours
#### 假阳/阴
#### Incremental Learning


### 未来方向
https://www.mdpi.com/2076-3417/12/17/8482

1. 尽管文献综述中的现有解决方案已经为开发可信的恶意软件检测和分类模型指明了道路，但**逃避型恶意软件的检测仍然具有挑战性**。
2. **为了检测规避型恶意软件，人们采取了多种方法**。例如：生成基于 API 的规避型恶意软件签名、使用多种执行环境发现规避行为，以及使用已知的规避技术来检测规避型恶意软件。
3. **据我们所知，每种规避型恶意软件检测解决方案都有自己的弱点**。例如，如何区分合法行为中使用的规避技术和恶意相关的规避技术仍是一个难题。此外，基于已知规避技术学习开发的模型很难检测和识别未知的规避技术。此外，在时间和资源方面使用多个不复杂的执行环境也是另一个挑战。
#### 可用的规避行为数据集
尽管已经开展了多项研究来提高规避型恶意软件的检测率，但目前还没有可用的数据集来表示规避行为。因此，创建一个规避行为数据集将有助于研究人员努力开发出强大的解决方案。为了检测规避型恶意软件，需要高效的特征提取和表示技术来提取和表示一个特征集，该特征集只表示与恶意行为相关的规避技术。
#### 需要高效的更新学习机制
另一方面，零日恶意软件和未知恶意软件变种的日产量大大增加，因为有了在线工具，人们可以利用这些工具创建新的恶意软件或使用混淆技术重新格式化现有恶意软件，从而引入新的变种。因此，需要高效的更新学习机制，使开发的模型能够自适应地学习即将出现的新行为。为此，可以设计和实施深度学习技术与无监督机器学习技术相结合，用于更新学习和开发能够自适应学习新恶意行为的模型。



## 大语言模型
LLM 现已广泛应用于软件工程中的各种任务，包括代码生成、测试、程序修复和总结 [3] [40]。本研究深入探讨了 ChatGPT 在恶意软件检测中的零点学习（zero-shot learning）。零点学习（Zero-shot）是一种技术，可使模型在没有先前示例的情况下处理未知任务。零点学习在各种 NLP 任务中都取得了可喜的成果 [22] [34]，思维链（CoT）或逐步推理提示增强了 LLM 生成中间推理步骤的能力 [34]。研究 [14] [15] [38] 发现了一些有效的 CoT 要素，如零镜头 CoT 和角色扮演提示，它们能提高推理质量。Kojima 等人 [14] 证明了 LLMs 对零镜头推理的熟练掌握，而 Kong 等人 [15] 则发现角色扮演提示能产生更有效的 CoT。Madaan 等人 [16] 观察到，使用 GPT-3.5 和 GPT-4 将 SELF-REFINE 方法应用于从对话到推理的各种任务中，能显著提高性能，并得到了人类和自动计量学的验证。Zelikman 等人 [41] 证实了自创理由对模型自我改进的实用性。

White 等人 [35] [36] 的研究表明，用特定领域的信息来增强模型可以提高模型的性能，因为语言模型在生成代码摘要时发现在代码结构中检测特定标识符更有价值。Chen 等人 [6] 研究了 GPT-3 代码生成的性能。他们探索了该模型理解和生成代码的能力，为将此类模型用于代码相关任务的潜力提供了有价值的见解。Ahmed 等人[3]的研究表明，GPT 模型可以利用特定项目的训练，在代码总结方面大大超过最先进的模型。在另一项研究中，Sobania 等人 [29] 利用 ChatGPT 进行代码错误修复，进一步提高了错误修复的成功率。Purba 等人 [22] 开展了一项研究，衡量 LLM 在检测软件漏洞方面的性能。作者得出的结论是，LLM 在检测软件漏洞方面表现不佳，但模型特别善于发现漏洞代码中涉及的常见模式。作者还观察到，ChatGPT 4.0 可以解释给定代码片段的 "意图"。



## 大语言模型智能体
由于 LLM 海量的训练数据集和强大的推理能力，越来越多的人开始将 LLM 作为决策系统的推理核心，以构建类人自主智能体（LLM Agent）。[10] [26] [37] 这就要求将对 RL 环境的观察结果转化为自然语言，使语言模型更容易处理。语言模型的推理还需要转化为可行的执行操作。常用的提示词技术包括 ReAct [28] 和 Reflexion [17]。人们还探索了其他涉及微调语言模型的方法 [20]。此外，还提出了各种技术来减轻语言模型的偏差（biases）和限制（constrains），包括思维链推理（chain-of-thought reasoning）[13]、外部工具（external tools）[27] [39]、外部文档（external documents）[13] 和技能库（skill libraries）[37]。



## Ref