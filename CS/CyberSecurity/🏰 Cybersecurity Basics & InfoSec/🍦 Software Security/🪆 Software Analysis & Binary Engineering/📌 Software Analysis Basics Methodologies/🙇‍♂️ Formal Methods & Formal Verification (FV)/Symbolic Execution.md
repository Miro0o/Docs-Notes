# Symbolic Execution

[TOC]



## Res
### Related Topics
â†— [Symbolic and Algebraic Manipulation](../../../../../../ðŸ§ %20Computing%20Methodologies/Symbolic%20and%20Algebraic%20Manipulation/Symbolic%20and%20Algebraic%20Manipulation.md)

â†— [SMT (Satisfiability Modulo Theory) Solvers](../../../../../â˜ ï¸%20Kill%20Chain%20&%20Security%20Tool%20Box/ðŸ”ž%20Software%20Analysis%20Tools/â›°ï¸%20Static%20Code%20Analysis%20Tools%20(SCAT)/Logic%20Verifies%20&%20Provers/SMT%20(Satisfiability%20Modulo%20Theory)%20Solvers/SMT%20(Satisfiability%20Modulo%20Theory)%20Solvers.md)
â†— [angr](../../../../../â˜ ï¸%20Kill%20Chain%20&%20Security%20Tool%20Box/ðŸ”ž%20Software%20Analysis%20Tools/â›°ï¸%20Static%20Code%20Analysis%20Tools%20(SCAT)/Symbolic%20Execution/angr.md)


### Other Resources
https://docs.angr.io/en/latest/core-concepts/index.html
â†— [angr](../../../../../â˜ ï¸%20Kill%20Chain%20&%20Security%20Tool%20Box/ðŸ”ž%20Software%20Analysis%20Tools/â›°ï¸%20Static%20Code%20Analysis%20Tools%20(SCAT)/Symbolic%20Execution/angr.md) documentation. explains core concepts in symbolic execution.
- [Core Concepts](https://docs.angr.io/en/latest/core-concepts/toplevel.html)
- [Loading a Binary](https://docs.angr.io/en/latest/core-concepts/loading.html)
- [Symbolic Expressions and Constraint Solving](https://docs.angr.io/en/latest/core-concepts/solver.html#)
- [Machine State - memory, registers, and so on](https://docs.angr.io/en/latest/core-concepts/states.html)
- [Simulation Managers](https://docs.angr.io/en/latest/core-concepts/pathgroups.html)
- [Simulation and Instrumentation](https://docs.angr.io/en/latest/core-concepts/simulation.html)
- [Analyses](https://docs.angr.io/en/latest/core-concepts/analyses.html)
- [Symbolic Execution](https://docs.angr.io/en/latest/core-concepts/symbolic.html)
- [A final word of advice](https://docs.angr.io/en/latest/core-concepts/be_creative.html)



## Intro
> ðŸ”— https://docs.angr.io/en/latest/core-concepts/symbolic.html

Symbolic execution is a program analysis technique used to **explore multiple execution paths of a program simultaneously**. Unlike normal execution, which runs the program with specific inputs, symbolic execution treats inputs as symbolic variables rather than concrete values. This means the execution can represent a wide range of inputs with **symbolic expressions**. Symbolic execution allows, at a time in emulation, to determine for a branch all conditions necessary to take a branch or not. Every variable is represented as a symbolic value, and each branch as a constraint. ==Thus, symbolic execution allows us to see which conditions allow the program to go from point A to point B by resolving these constraints. ==The **execution paths** are then analyzed by solving constraints generated by these symbolic expressions, allowing the discovery of bugs and vulnerabilities that might be missed in standard testing.

**Example**
> ðŸ”— https://docs.angr.io/en/latest/core-concepts/symbolic.html#example

Consider the following simple program :

``` c
const char* check_value(int x) {
    if (x > 10) {
        return "Greater";
    } else {
        return "Lesser or Equal";
    }
}
```

In normal execution, ifÂ `x`Â is set to 5, the program will follow the path whereÂ `xÂ <=Â 10`Â and return â€œLesser or Equalâ€. In symbolic execution,Â `x`Â is treated as a symbolic variable,Â `X`. The execution engine explores both paths:

> - Path 1:Â `XÂ >Â 10`Â leading to the result â€œGreaterâ€
> - Path 2:Â `XÂ <=Â 10`Â leading to the result â€œLesser or Equalâ€

Constraints for both paths are generated and solved to understand all possible behaviors of the program.

In software verification, it helps ensure that the code behaves as expected across all possible inputs and states. For security analysis, symbolic execution can uncover vulnerabilities such as input validation errors, which could be exploited by attackers. Additionally, in automated testing, it aids in generating comprehensive test cases that cover edge cases and rare execution paths, enhancing the robustness and security of software systems. Overall, symbolic execution provides a powerful means to rigorously analyze and improve software and firmware reliability.


### Symbolic Expressions and Constraint Solving
Â The power of symbolic execution didn't come with the emulation, but with the ability to execute what is known as the **symbolic variables**. Instead of saying that a (symbolic) variable has aÂ _concrete_Â numerical value, we can say that it holds aÂ _symbol_, effectively just a name. Then, performing arithmetic operations with that symbol/variable will yield a tree of operations (termed anÂ _abstract syntax tree_Â orÂ _â†— [AST (Abstract Syntax Tree)](../../../../../../ðŸ”‘%20CS%20Core/ðŸ‘©â€ðŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ðŸ¢%20Programming%20Language%20Theory%20(PLT)/AST%20(Abstract%20Syntax%20Tree).md)_, from compiler theory). ASTs can be translated into **constraints** forÂ _â†— [SMT (Satisfiability Modulo Theory) Solvers](../../../../../â˜ ï¸%20Kill%20Chain%20&%20Security%20Tool%20Box/ðŸ”ž%20Software%20Analysis%20Tools/â›°ï¸%20Static%20Code%20Analysis%20Tools%20(SCAT)/Logic%20Verifies%20&%20Provers/SMT%20(Satisfiability%20Modulo%20Theory)%20Solvers/SMT%20(Satisfiability%20Modulo%20Theory)%20Solvers.md)_, like z3, in order to ask questions likeÂ â€œgiven the output of this sequence of operations, what must the input have been?â€. This latter process is known for **â†— [Constraint Solving](Constraint%20Solving.md)**.



## Ref
[ç®€å•ç†è§£ç¬¦å·æ‰§è¡ŒæŠ€æœ¯]: https://www.k0rz3n.com/2019/02/28/ç®€å•ç†è§£ç¬¦å·æ‰§è¡ŒæŠ€æœ¯/

Wikiä¸­çš„å®šä¹‰æ˜¯ï¼šåœ¨è®¡ç®—æœºç§‘å­¦ä¸­ï¼Œç¬¦å·æ‰§è¡ŒæŠ€æœ¯æŒ‡çš„æ˜¯é€šè¿‡ç¨‹åºåˆ†æžçš„æ–¹æ³•ï¼Œ**ç¡®å®šå“ªäº›è¾“å…¥å‘é‡ä¼šå¯¹åº”å¯¼è‡´ç¨‹åºçš„æ‰§è¡Œç»“æžœä¸ºæŸä¸ªå‘é‡çš„æ–¹æ³•**(ç»•)ã€‚é€šä¿—çš„è¯´ï¼Œå¦‚æžœæŠŠä¸€ä¸ªç¨‹åºæ¯”ä½œDOTAè‹±é›„ï¼Œè‹±é›„çš„æœ€ç»ˆå±žæ€§å€¼ä¸ºç¨‹åºçš„è¾“å‡ºï¼ˆåŒ…æ‹¬æ”»å‡»åŠ›ã€é˜²å¾¡åŠ›ã€è¡€æ§½ã€è“æ§½ï¼‰ï¼Œè‹±é›„çš„æ­¦å™¨å‡ºè£…ä¸ºç¨‹åºçš„è¾“å…¥ï¼ˆå‡ºAæ–è¿˜æ˜¯BKBï¼‰ã€‚é‚£ä¹ˆç¬¦å·æ‰§è¡ŒæŠ€æœ¯çš„ä»»åŠ¡å°±æ˜¯ï¼Œç»™å®šäº†ä¸€ä¸ªè‹±é›„çš„æœ€ç»ˆå±žæ€§å€¼ï¼Œåˆ†æžå‡ºè¯¥è‹±é›„å¯ä»¥é€šè¿‡å“ªäº›å‡ºè£…æ–¹å¼è¾¾åˆ°è¿™ç§æœ€ç»ˆå±žæ€§å€¼æ•ˆæžœã€‚

å¯ä»¥å‘çŽ°ï¼Œ**ç¬¦å·æ‰§è¡ŒæŠ€æœ¯æ˜¯ä¸€ç§ç™½ç›’çš„é™æ€åˆ†æžæŠ€æœ¯**ã€‚å³ï¼Œåˆ†æžç¨‹åºå¯èƒ½çš„è¾“å…¥éœ€è¦èƒ½å¤ŸèŽ·å–åˆ°ç›®æ ‡æºä»£ç çš„æ”¯æŒã€‚**åŒæ—¶ï¼Œå®ƒæ˜¯é™æ€çš„ï¼Œå› ä¸ºå¹¶æ²¡æœ‰å®žé™…çš„æ‰§è¡Œç¨‹åºæœ¬èº«ï¼Œè€Œæ˜¯åˆ†æžç¨‹åºçš„æ‰§è¡Œè·¯å¾„**ã€‚å¦‚æžœæŠŠä¸Šè¿°è‹±é›„çš„æœ€ç»ˆå±žæ€§å€¼æ›¿æ¢æˆç¨‹åºå½¢æˆçš„bugçŠ¶æ€ï¼Œæ¯”å¦‚ï¼Œå­˜åœ¨æ•°ç»„è¶Šç•Œå¤åˆ¶çš„çŠ¶æ€ï¼Œé‚£ä¹ˆï¼Œæˆ‘ä»¬å°±èƒ½å¤Ÿåˆ©ç”¨æ­¤æŠ€æœ¯æŒ–æŽ˜æ¼æ´žçš„è¾“å…¥å‘é‡äº†ã€‚

[ðŸ¤” Understanding SMT solvers: An Introduction to Z3]: https://de-engineer.github.io/SMT-Solvers/
This post was an overview of SMT solvers with the practical example of a CTF challenge and we also touched a bit on their limitations. Iâ€™m not an expert on the topic, I tried to cover all the introductory knowledge that I could put in without increasing the complexity of the blog. There is indeed far more to learn about and you can do so by checking all the links in the resources section.
- [Symbolic Execution Lecture from MIT](https://www.youtube.com/watch?v=yRVZPvHYHzw)
- [Symbolic Execution with Triton Engine](https://pwn.umasscybersec.org/lectures/index.html)
- [HexRays CTF solution with Z3](https://www.youtube.com/watch?v=kZd1Hi0ZBYc)
- [OST2 Course on Symbolic Analysis (teaches angr)](https://p.ost2.fyi/courses/course-v1:OpenSecurityTraining2+RE3201_symexec+2021_V1/course/)
- [Papers by Z3 team](https://z3prover.github.io/papers/)
- [The Path Explosion Problem in Symbolic Execution - Paper](https://studenttheses.uu.nl/bitstream/handle/20.500.12932/35856/thesis.pdf?sequence=1&isAllowed=y)
