# Symbolic Execution

[TOC]



## Res
### Related Topics
↗ [Symbolic and Algebraic Manipulation](../../../../../../🧠%20Computing%20Methodologies/Symbolic%20and%20Algebraic%20Manipulation/Symbolic%20and%20Algebraic%20Manipulation.md)

↗ [SMT (Satisfiability Modulo Theory) Solvers](../../../../../☠️%20Kill%20Chain%20&%20Security%20Tool%20Box/🔞%20Software%20Analysis%20Tools/⛰️%20Static%20Code%20Analysis%20Tools%20(SCAT)/Logic%20Verifies%20&%20Provers/SMT%20(Satisfiability%20Modulo%20Theory)%20Solvers/SMT%20(Satisfiability%20Modulo%20Theory)%20Solvers.md)
↗ [angr](../../../../../☠️%20Kill%20Chain%20&%20Security%20Tool%20Box/🔞%20Software%20Analysis%20Tools/⛰️%20Static%20Code%20Analysis%20Tools%20(SCAT)/Symbolic%20Execution/angr.md)


### Other Resources
https://docs.angr.io/en/latest/core-concepts/index.html
↗ [angr](../../../../../☠️%20Kill%20Chain%20&%20Security%20Tool%20Box/🔞%20Software%20Analysis%20Tools/⛰️%20Static%20Code%20Analysis%20Tools%20(SCAT)/Symbolic%20Execution/angr.md) documentation. explains core concepts in symbolic execution.
- [Core Concepts](https://docs.angr.io/en/latest/core-concepts/toplevel.html)
- [Loading a Binary](https://docs.angr.io/en/latest/core-concepts/loading.html)
- [Symbolic Expressions and Constraint Solving](https://docs.angr.io/en/latest/core-concepts/solver.html#)
- [Machine State - memory, registers, and so on](https://docs.angr.io/en/latest/core-concepts/states.html)
- [Simulation Managers](https://docs.angr.io/en/latest/core-concepts/pathgroups.html)
- [Simulation and Instrumentation](https://docs.angr.io/en/latest/core-concepts/simulation.html)
- [Analyses](https://docs.angr.io/en/latest/core-concepts/analyses.html)
- [Symbolic Execution](https://docs.angr.io/en/latest/core-concepts/symbolic.html)
- [A final word of advice](https://docs.angr.io/en/latest/core-concepts/be_creative.html)



## Intro
> 🔗 https://docs.angr.io/en/latest/core-concepts/symbolic.html

Symbolic execution is a program analysis technique used to **explore multiple execution paths of a program simultaneously**. Unlike normal execution, which runs the program with specific inputs, symbolic execution treats inputs as symbolic variables rather than concrete values. This means the execution can represent a wide range of inputs with **symbolic expressions**. Symbolic execution allows, at a time in emulation, to determine for a branch all conditions necessary to take a branch or not. Every variable is represented as a symbolic value, and each branch as a constraint. ==Thus, symbolic execution allows us to see which conditions allow the program to go from point A to point B by resolving these constraints. ==The **execution paths** are then analyzed by solving constraints generated by these symbolic expressions, allowing the discovery of bugs and vulnerabilities that might be missed in standard testing.

**Example**
> 🔗 https://docs.angr.io/en/latest/core-concepts/symbolic.html#example

Consider the following simple program :

``` c
const char* check_value(int x) {
    if (x > 10) {
        return "Greater";
    } else {
        return "Lesser or Equal";
    }
}
```

In normal execution, if `x` is set to 5, the program will follow the path where `x <= 10` and return “Lesser or Equal”. In symbolic execution, `x` is treated as a symbolic variable, `X`. The execution engine explores both paths:

> - Path 1: `X > 10` leading to the result “Greater”
> - Path 2: `X <= 10` leading to the result “Lesser or Equal”

Constraints for both paths are generated and solved to understand all possible behaviors of the program.

In software verification, it helps ensure that the code behaves as expected across all possible inputs and states. For security analysis, symbolic execution can uncover vulnerabilities such as input validation errors, which could be exploited by attackers. Additionally, in automated testing, it aids in generating comprehensive test cases that cover edge cases and rare execution paths, enhancing the robustness and security of software systems. Overall, symbolic execution provides a powerful means to rigorously analyze and improve software and firmware reliability.


### Symbolic Expressions and Constraint Solving
 The power of symbolic execution didn't come with the emulation, but with the ability to execute what is known as the **symbolic variables**. Instead of saying that a (symbolic) variable has a _concrete_ numerical value, we can say that it holds a _symbol_, effectively just a name. Then, performing arithmetic operations with that symbol/variable will yield a tree of operations (termed an _abstract syntax tree_ or _↗ [AST (Abstract Syntax Tree)](../../../../../../🔑%20CS%20Core/👩‍💻%20Computer%20Languages%20&%20Programming%20Methodology/🐢%20Programming%20Language%20Theory%20(PLT)/AST%20(Abstract%20Syntax%20Tree).md)_, from compiler theory). ASTs can be translated into **constraints** for _↗ [SMT (Satisfiability Modulo Theory) Solvers](../../../../../☠️%20Kill%20Chain%20&%20Security%20Tool%20Box/🔞%20Software%20Analysis%20Tools/⛰️%20Static%20Code%20Analysis%20Tools%20(SCAT)/Logic%20Verifies%20&%20Provers/SMT%20(Satisfiability%20Modulo%20Theory)%20Solvers/SMT%20(Satisfiability%20Modulo%20Theory)%20Solvers.md)_, like z3, in order to ask questions like “given the output of this sequence of operations, what must the input have been?”. This latter process is known for **↗ [Constraint Solving](Constraint%20Solving.md)**.



## Ref
[简单理解符号执行技术]: https://www.k0rz3n.com/2019/02/28/简单理解符号执行技术/

Wiki中的定义是：在计算机科学中，符号执行技术指的是通过程序分析的方法，**确定哪些输入向量会对应导致程序的执行结果为某个向量的方法**(绕)。通俗的说，如果把一个程序比作DOTA英雄，英雄的最终属性值为程序的输出（包括攻击力、防御力、血槽、蓝槽），英雄的武器出装为程序的输入（出A杖还是BKB）。那么符号执行技术的任务就是，给定了一个英雄的最终属性值，分析出该英雄可以通过哪些出装方式达到这种最终属性值效果。

可以发现，**符号执行技术是一种白盒的静态分析技术**。即，分析程序可能的输入需要能够获取到目标源代码的支持。**同时，它是静态的，因为并没有实际的执行程序本身，而是分析程序的执行路径**。如果把上述英雄的最终属性值替换成程序形成的bug状态，比如，存在数组越界复制的状态，那么，我们就能够利用此技术挖掘漏洞的输入向量了。

[🤔 Understanding SMT solvers: An Introduction to Z3]: https://de-engineer.github.io/SMT-Solvers/
This post was an overview of SMT solvers with the practical example of a CTF challenge and we also touched a bit on their limitations. I’m not an expert on the topic, I tried to cover all the introductory knowledge that I could put in without increasing the complexity of the blog. There is indeed far more to learn about and you can do so by checking all the links in the resources section.
- [Symbolic Execution Lecture from MIT](https://www.youtube.com/watch?v=yRVZPvHYHzw)
- [Symbolic Execution with Triton Engine](https://pwn.umasscybersec.org/lectures/index.html)
- [HexRays CTF solution with Z3](https://www.youtube.com/watch?v=kZd1Hi0ZBYc)
- [OST2 Course on Symbolic Analysis (teaches angr)](https://p.ost2.fyi/courses/course-v1:OpenSecurityTraining2+RE3201_symexec+2021_V1/course/)
- [Papers by Z3 team](https://z3prover.github.io/papers/)
- [The Path Explosion Problem in Symbolic Execution - Paper](https://studenttheses.uu.nl/bitstream/handle/20.500.12932/35856/thesis.pdf?sequence=1&isAllowed=y)
