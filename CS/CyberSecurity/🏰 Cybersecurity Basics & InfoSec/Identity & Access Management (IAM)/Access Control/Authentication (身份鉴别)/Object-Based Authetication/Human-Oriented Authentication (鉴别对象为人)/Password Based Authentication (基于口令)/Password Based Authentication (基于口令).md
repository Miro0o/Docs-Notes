# Password Based Authentication (基于口令)

[TOC]



## Res


## Intro



## 1️⃣ Password Authentication Protocol (PAP) (静态口令)
PAP 鉴别的优点是:简单有效，实用方便，费用低廉，使用灵活。因此，一般的系统(如 Unix，Windows NT，NetWare 等)都提供了对口令鉴别的支持。然而，基于简单口令的鉴别方法有许多脆弱性，最主要的是口令容易向外部泄露和易于猜测的弱口令。另外还有线路窃听和重放等威胁。

为提高 PAP 鉴别的安全性，对口令有一定的要求:
1. 口令有一定的长度和复杂度，不能使用简单的 111、123、123456、生日、电话号码或姓名拼音，因为这些很容易被猜测出来，一般应使用 8 位以上，混合大小写字母、数字和特殊符号的口令，防止字典攻击;
2. 口令应定期或不定期修改:口令使用较长时间后，应进行更改，防止可能的泄露;在怀疑口令可能泄露的情况下，也应及时更改口令;
3. 口令应安全保存。明文口令文件需读和写保护，加密口令文件需写保护。


### Enhanced PAP
#### PAP + Hash (引入单向加密机制)
![](../../../../../../../../../Assets/Pics/Screenshot%202023-05-31%20at%204.00.39%20PM.png)

由于散列函数具有单向性，即从输入变量值计算出函数值容易，而要从函数值逆向计算 出输入变量的值计算不可行，因此常常通过该类函数对口令进行(单向)加密，验证方只保 存口令加密后的信息。鉴别时将口令加密后的信息进行对比验证。鉴别交互示意如图 8.1 所 示。其中，p’是声称者输入的口令信息，id 是声称者的标识，h 是散列函数。p’经过 h 的计 算得到 q’。q 和 id 是验证者保留的散列之后的口令和对应的声称者标识。声称者输入 p’和 id，经过散列函数 h 计算得到 q’。q’连同声称者标识 id 传给验证者，验证者验证 q’是否与 q 相同。如相同，则鉴别通过;否则，鉴别不通过。

该方案的主要缺陷是:利用已知的散列函数，攻击者很容易构造一张 p 与 q 对应的表(称 为口令字典)，表中的 p 是猜测的口令，尽可能包含各种可能的口令值，q 是 p 的散列值。 然后攻击者通过拦截鉴别信息 q，利用口令字典就能以很高的概率获得声称者的口令，这种攻击方式称为**字典攻击**。


#### PAP + Hash + Salt（引入加扰机制）
![](../../../../../../../../../Assets/Pics/Screenshot%202023-05-31%20at%204.00.54%20PM.png)

攻击者在事先进行计算各种长度的字符组成的口令的消息摘要时，由于每个用户的salt不 同，攻击者必须把各种口令和salt进行组合进行 散列运算，使得攻击者得到字典的难度增加。


##### UNIX Crypt (1970s)

![](../../../../../../../../../Assets/Pics/Screenshot%202023-06-05%20at%209.47.46%20PM.png)


![](../../../../../../../../../Assets/Pics/Screenshot%202023-06-05%20at%209.48.18%20PM.png)



## 2️⃣ One Time Password (OTP)（动态口令）
OTP(One-Time Password)是一次性口令机制，主要目的是在登录过程中加入不确定因素，使每次登录传送的鉴别 信息都不相同，以提高登录过程安全性，对付重放攻击。

OTP 主要的实现方式有三种:
- 第一种是质询-响应方式。 鉴别时，系统随机给出一个信息，用户将该信息连同其鉴别信息(可能经过计算处理)提交 系统进行鉴别;
- 第二种方法采用时钟同步机制，与质询-响应方式的差异是随机信息是同步 时钟信息。
- 第三种方法是采用 S/KEY 一次性口令身份鉴别协议。

确定口令的方法: 
- 两端共同拥有一串随机口令，在该串的某一位置保持同步;
- 两端共同使用一个随机序列生成器，在该序列生成器的初态保持同步;
- 使用时戳，两端维持同步的时钟。


![](../../../../../../../../../Assets/Pics/Screenshot%202023-06-05%20at%209.26.15%20PM.png)


### 共享一次性口令表 (口令序列)


### 基于令牌的鉴别机制



### Challenge /Response (质询/响应 ｜ 挑战/应答)

![](../../../../../../../../../Assets/Pics/Screenshot%202023-05-31%20at%204.06.52%20PM.png)

在该机制中，产生非重复值的能力完全掌握在验证者手中。因而􏰁供了一种很好的重放 检测能力。然而，附加的复杂协议意味着这种机制不能与传统的简单口令协议结合使用。

质询—响应的身份鉴别，其安全性一方面取决于散列函数的安全性;另一方面，由于是单向鉴别，还存在着验证者的假冒和重放攻击。这可以通过双向鉴别或时间戳来解决。例如， 在系统每次输出的密文信息中附加日期与时间信息，鉴别双方都可以根据密文中的日期时间 来判断消息是否是当前的。如果是前面的消息重放，用户则拒绝给出回答。



![](../../../../../../../../../Assets/Pics/Screenshot%202023-06-05%20at%209.24.57%20PM.png)


### Time-Synchronization (时间同步)

![](../../../../../../../../../Assets/Pics/Screenshot%202023-06-05%20at%209.23.58%20PM.png)


协议安全性：
- 攻击者只知道用户的口令而没有用户的 智能卡，则不能通过服务器的鉴别;
- 攻击者只拥有用户的智能卡而不知道用 户的口令，则不能通过服务器的鉴别;
- 如果攻击者不能服务器进行时间同步， 则攻击者不能通过服务器的鉴别


### Event-Synchronization (事件同步)




### S/KEY

![](../../../../../../../../../Assets/Pics/Screenshot%202023-06-05%20at%209.53.29%20PM.png)
![](../../../../../../../../../Assets/Pics/Screenshot%202023-06-05%20at%209.53.41%20PM.png)



安全性分析:

1) 重放攻击:由于用户每次登录的口令不 同， 因此攻击者把上一次的口令传送给 服务器将通不过服务器的认证。
2) 口令以密文传输:口令散列后在通信信 道中传输，因此攻击者截获口令的散列值后要计算用户的口令是困难的。 
3) 小数攻击问题

在 S/Key 协议中，用户 U 与鉴别服务器 AS 之间的鉴别交换信息中，没有直接传输口令 的任何信息，而只是口令信息的散列结果。依据散列函数的单向性，攻击者通过拦截通信信 道获取到当前鉴别口令(OTP M-1)，但不能导出下次的鉴别口令(OTP M-2)。甚至攻击者攻 破了鉴别服务器，浏览了用户的口令记录，也无法知晓用户的真正口令。S/Key 利用告知服 务器 M 次散列结果，并逐次减少散列迭代次数，从而得到 N-1 个可用的鉴别口令序列。而每 一个鉴别口令仅使用一次，即使暴露第 i 次鉴别口令，并不影响后续口令的安全性。S/Key 成功地防范了口令窃听并重放的攻击。

但 S/KEY 系统不能防止小数攻击。假设攻击者获知散列函数 h(·)，当用户向服务器请 求鉴别时, 攻击者截取服务器传来的种子和迭代值, 并修改迭代值为较小值, 然后假冒服 务器将得到的种子和较小的迭代值发给用户。用户利用种子和迭代值计算一次性口令, 攻击 者再次截取用户传来的一次性口令，并利用已知的单向散列函数依次计算较大迭代值的一次 性口令, 就可获得该用户后续的一系列有效口令, 进而在一段时间内冒充合法用户而不被 察觉, 这就是小数攻击。

另外，S/Key 缺乏完整性保护机制。不能保护用户鉴别过程受到各种主动攻击:包括注 入虚假信息，修改传输过程中的鉴别数据，修改口令文件等。因此，S/Key 系统在实际应用 时还需进一步完善。




## Ref

