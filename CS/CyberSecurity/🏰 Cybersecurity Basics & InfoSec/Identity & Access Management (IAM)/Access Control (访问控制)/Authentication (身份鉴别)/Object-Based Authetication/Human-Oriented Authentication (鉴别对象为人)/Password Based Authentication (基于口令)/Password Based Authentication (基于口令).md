# Password Based Authentication (基于口令)

[TOC]



## Res


## Intro



## 1️⃣ 基于静态口令
口令或通行字机制是最广泛研究和使用的身份鉴别法，通常为长度为6~8的字符串（已经不安全了）。
系统事先保存每个用户的二元组信息，即用户身份信息和口令。这种口令信息是明文的或仅经过简单加密（或变换）的。
口令鉴别协议（**password authentication protocol**，**PAP)** 鉴别一般在通信连接建立阶段进行，在数据传输阶段不进行**PAP**鉴别。

口令机制（系统）有许多脆弱点
- 外部泄露
	- 教育、培训；
	- 严格组织管理办法和执行手续；
	- 口令定期改变；
	- 每个口令只与一个人有关；
	- 输入的口令不出现在终端上；
	- 使用易记的口令，不要写在纸上。
- 口令猜测
	- 教育、培训；
	- 严格限制非法登录的次数；
	- 口令验证中插入实时延迟；
	- 限制最小长度，至少10字符以上,各种字符的组合
	- 防止用户特征相关口令，
	- 口令定期改变；
	- 及时更改预设口令；
	- 使用机器产生的口令。
- 线路窃听
	- 引入散列函数
	- 加盐（**Salt**）机制
- 危及验证者
- 重放攻击

### 👉 Password Authentication Protocol (PAP)
> ↗ [PPP (Point-to-Point Protocol)](../../../../../../../../🔑%20CS_Core/🏎️%20Computer%20Networking%20and%20Communication/📌%20Computer%20Networking%20Basics/0x06%20Data%20Link%20Layer/Switched%20LAN/P2P%20Channels/PPP%20(Point-to-Point%20Protocol)/PPP%20(Point-to-Point%20Protocol).md)
> ↗ [PPP (Point-to-Point Protocol) /⭐ PAP (Password Authentication Protocol)](../../../../../../../../🔑%20CS_Core/🏎️%20Computer%20Networking%20and%20Communication/📌%20Computer%20Networking%20Basics/0x06%20Data%20Link%20Layer/Switched%20LAN/P2P%20Channels/PPP%20(Point-to-Point%20Protocol)/PPP%20(Point-to-Point%20Protocol).md#⭐%20PAP%20(Password%20Authentication%20Protocol))

PAP 鉴别的优点是:简单有效，实用方便，费用低廉，使用灵活。因此，一般的系统(如 Unix，Windows NT，NetWare 等)都提供了对口令鉴别的支持。然而，基于简单口令的鉴别方法有许多脆弱性，最主要的是口令容易向外部泄露和易于猜测的弱口令。另外还有线路窃听和重放等威胁。

为提高 PAP 鉴别的安全性，对口令有一定的要求:
1. 口令有一定的长度和复杂度，不能使用简单的 111、123、123456、生日、电话号码或姓名拼音，因为这些很容易被猜测出来，一般应使用 8 位以上，混合大小写字母、数字和特殊符号的口令，防止字典攻击;
2. 口令应定期或不定期修改:口令使用较长时间后，应进行更改，防止可能的泄露;在怀疑口令可能泄露的情况下，也应及时更改口令;
3. 口令应安全保存。明文口令文件需读和写保护，加密口令文件需写保护。
### 👉 Enhanced PAP
#### PAP + Hash (引入单向加密机制)
![](../../../../../../../../../Assets/Pics/Screenshot%202023-05-31%20at%204.00.39%20PM.png)

由于散列函数具有单向性，即从输入变量值计算出函数值容易，而要从函数值逆向计算 出输入变量的值计算不可行，因此常常通过该类函数对口令进行(单向)加密，验证方只保 存口令加密后的信息。鉴别时将口令加密后的信息进行对比验证。鉴别交互示意如图 8.1 所 示。其中，p’是声称者输入的口令信息，id 是声称者的标识，h 是散列函数。p’经过 h 的计 算得到 q’。q 和 id 是验证者保留的散列之后的口令和对应的声称者标识。声称者输入 p’和 id，经过散列函数 h 计算得到 q’。q’连同声称者标识 id 传给验证者，验证者验证 q’是否与 q 相同。如相同，则鉴别通过;否则，鉴别不通过。

该方案的主要缺陷是:利用已知的散列函数，攻击者很容易构造一张 p 与 q 对应的表(称 为口令字典)，表中的 p 是猜测的口令，尽可能包含各种可能的口令值，q 是 p 的散列值。 然后攻击者通过拦截鉴别信息 q，利用口令字典就能以很高的概率获得声称者的口令，这种攻击方式称为**字典攻击**。
解决办法：在口令后使用随机串（Salt）
#### PAP + Hash + Salt（引入加扰机制）
![](../../../../../../../../../Assets/Pics/Screenshot%202023-05-31%20at%204.00.54%20PM.png)

加盐（ **Salt** ）就是在进行散列运算时，增加**Salt**字符串的输入，通过**Salt**和口令混合加密得出散列值。攻击者在事先进行计算各种长度的字符组成的口令的消息摘要时，由于每个用户的salt不 同，攻击者必须把各种口令和salt进行组合进行散列运算，使得攻击者得到字典的难度增加。

![](../../../../../../../../../Assets/Pics/Screenshot%202023-11-08%20at%209.10.12PM.png)

该方案的主要缺陷：只能保护在多台计算机上使用相同口令的同一用户或在同一计算机上使用同一口令的不同用户。本质原因是一个用户在数据库中只能有一个记录，所以不支持对同一用户不同口令的保护。但是不同用户使用同一口令可以保护，因为ID不同，盐不同
##### UNIX Crypt (1970s)
![](../../../../../../../../../Assets/Pics/Screenshot%202023-06-05%20at%209.47.46%20PM.png)

![](../../../../../../../../../Assets/Pics/Screenshot%202023-06-05%20at%209.48.18%20PM.png)



## 2️⃣ One Time Password (OTP)（基于动态口令）
OTP(One-Time Password)是一次性口令机制，主要目的是在登录过程中加入不确定因素，使每次登录传送的鉴别信息都不相同，以提高登录过程安全性，对付重放攻击。

OTP 主要的实现方式有三种:
- 第一种是质询-响应方式。 鉴别时，系统随机给出一个信息，用户将该信息连同其鉴别信息(可能经过计算处理)提交 系统进行鉴别;
- 第二种方法采用时钟同步机制，与质询-响应方式的差异是随机信息是同步钟信息。
- 第三种方法是采用 S/KEY 一次性口令身份鉴别协议。

确定口令的方法:
- 两端共同拥有一串随机口令，在该串的某一位置保持同步;
- 两端共同使用一个随机序列生成器，在该序列生成器的初态保持同步;
- 使用时戳，两端维持同步的时钟。

![](../../../../../../../../../Assets/Pics/Screenshot%202023-11-08%20at%209.13.15PM.png)

![](../../../../../../../../../Assets/Pics/Screenshot%202023-06-05%20at%209.26.15%20PM.png)

OPT 安全性分析：
- 没有器件而知道口令p，不能导致一个简单的攻击；
- 拥有器件而不知道口令p，不能导致一个简单的攻击；
- 除非攻击者也能进行时间同步，否则重放不是一个简单的攻击；
- 知道q（例如通过浏览验证者系统文件）而不知道设备安全值dsv，不能导致一个简单的攻击。

### 共享一次性口令表 (口令序列)


### 基于令牌的鉴别机制


### Challenge /Response (质询/响应 ｜ 挑战/应答)
基于质询—应答的身份鉴别在鉴别时，由验证者给声称者发送一个确定的值（质询消息），该值参与鉴别信息的运算。产生的非重复质询消息完全由验证者决定，使得每次传输的鉴别信息不同。这能很好地防止口令窃听和重放，但需要额外的通信花销。

**A**期望从**B**获得一个消息
- 首先发给**B**一个随机值 **(challenge)**
- **B**收到这个值之后，对它作某种变换，并送回去
- **A**收到**B**的**response**，希望包含这个随机值
- 询问/应答方法不适应非连接性的应用，因为它要求在传输开始之前先有握手的额外开销，这就抵消了无连接通信的主要特点。

![](../../../../../../../../../Assets/Pics/Screenshot%202023-11-08%20at%208.35.04PM.png)

![](../../../../../../../../../Assets/Pics/Screenshot%202023-05-31%20at%204.06.52%20PM.png)

- 在该机制中，产生非重复值的能力完全掌握在验证者手中。因而提供了一种很好的重放 检测能力。
- 然而，附加的复杂协议意味着这种机制不能与传统的简单口令协议结合使用。

质询—响应的身份鉴别，其安全性取决于
1. 一方面，散列函数的安全性;
2. 另一方面，由于是单向鉴别，还存在着验证者的假冒和重放攻击。
	1. 这可以通过双向鉴别或时间戳来解决。例如，在系统每次输出的密文信息中附加日期与时间信息，鉴别双方都可以根据密文中的日期时间 来判断消息是否是当前的。如果是前面的消息重放，用户则拒绝给出回答。

![](../../../../../../../../../Assets/Pics/Screenshot%202023-06-05%20at%209.24.57%20PM.png)


### Time-Synchronization (时间同步)

![](../../../../../../../../../Assets/Pics/Screenshot%202023-06-05%20at%209.23.58%20PM.png)

协议安全性：
- 攻击者只知道用户的口令而没有用户的 智能卡，则不能通过服务器的鉴别;
- 攻击者只拥有用户的智能卡而不知道用 户的口令，则不能通过服务器的鉴别;
- 如果攻击者不能服务器进行时间同步， 则攻击者不能通过服务器的鉴别

### Event-Synchronization (事件同步)


### S/KEY

![](../../../../../../../../../Assets/Pics/Screenshot%202023-06-05%20at%209.53.29%20PM.png)
![](../../../../../../../../../Assets/Pics/Screenshot%202023-06-05%20at%209.53.41%20PM.png)

在 S/Key 协议中，用户 U 与鉴别服务器 AS 之间的鉴别交换信息中，没有直接传输口令 的任何信息，而只是口令信息的散列结果。依据散列函数的单向性，攻击者通过拦截通信信 道获取到当前鉴别口令(OTP M-1)，但不能导出下次的鉴别口令(OTP M-2)。甚至攻击者攻破了鉴别服务器，浏览了用户的口令记录，也无法知晓用户的真正口令。S/Key 利用告知服务器 M 次散列结果，并逐次减少散列迭代次数，从而得到 N-1 个可用的鉴别口令序列。而每 一个鉴别口令仅使用一次，即使暴露第 i 次鉴别口令，并不影响后续口令的安全性。S/Key 成功地防范了口令窃听并重放的攻击。
- 本质上对比的是：$h^M(pw||seed)$攻击者冒充服务器给用户传一个较小的，比如说M=1,那么攻击者就可以拿到$h^1(pw||seed)$,进而可以计算出$h^2(pw||seed)$、$h^3(pw||seed)$ ... 在已知h的情况下，由$h^M(pw||seed)$计算$h^{M+1}(pw||seed)$可行但由$h^{M+1}(pw||seed)$计算$h^M(pw||seed)$不可行，这也是小数攻击能够起作用的原因，本质上也还是有散列函数的单向性决定的

安全性分析:
1) 重放攻击:由于用户每次登录的口令不同，因此攻击者把上一次的口令传送给 服务器将通不过服务器的认证。
2) 口令以密文传输:口令散列后在通信信道中传输，因此攻击者截获口令的散列值后要计算用户的口令是困难的。 
3) 小数攻击问题
	1)  S/KEY 系统不能防止小数攻击。假设攻击者获知散列函数 h(·)，当用户向服务器请 求鉴别时, 攻击者截取服务器传来的种子和迭代值, 并修改迭代值为较小值, 然后假冒服务器将得到的种子和较小的迭代值发给用户。用户利用种子和迭代值计算一次性口令, 攻击 者再次截取用户传来的一次性口令，并利用已知的单向散列函数依次计算较大迭代值的一次 性口令, 就可获得该用户后续的一系列有效口令, 进而在一段时间内冒充合法用户而不被 察觉, 这就是小数攻击。
4) S/Key缺乏完整性保护机制。不能保护用户鉴别过程受到各种主动攻击：包括注入虚假信息，修改传输过程中的鉴别数据，修改口令文件等。因此，S/Key 系统在实际应用 时还需进一步完善。

### CAPTCHA
定义：将一串随机产生的数字或符号，生成一幅图片，在图片里加入一些干扰像素，由用户肉眼识别其中的验证码信息，输入表单提交到网站进行验证，验证成功后才能使用某项功能。

目的：
- 防止用户利用机器人自动注册，登陆，灌水。
- 有效防止某一特定注册用户用特定程序暴力破解方式进行不断的登录尝试。



## Ref

