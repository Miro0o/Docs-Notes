# Message Digest & Hash Function

[TOC]



## Intro
### Message Digest Properties
设散列函数为 h(m)，具有以下基本特性:  
(1) h(m)算法公开，不需要密钥。  
(2) 具有数据压缩功能，可将任意长度的输入数据转换成一个固定长度的输出。
(3) 对任何给定的m，h(m)易于计算。

除此之外，散列函数还必须满足以下安全性要求:  
(1) 具有**单向性**。
给定消息的散列值 h(m)，要得到消息 m 在计算上不可行;  

(2) 具有**弱抗碰撞性(Weak collision resistance)**。
也称弱抗冲突性：对任何给定的消息 m，寻找与m 不同的消息 m’，使得它们的散列值相同，即 h(m’)=h (m)，在计算上不可行。  

(3) 具有**强抗碰撞性(Strong collision resistance)** 。
也称强抗冲突性:寻找任意两个不同的消息 m和 m’， 使得 h(m)=h (m’) 在计算上不可行。  

所谓散列函数的碰撞是指若两个消息 m 与 m’，m≠m’ ，但它们的散列值相等，即 h(m) = h(m’ ) ，那么，则把这种情况称为发生了**碰撞或冲突**。

由于输入消息的长度可以是任意的，但散列函数输出的散列值的长度是固定的，如对于散列值长度为 160 位的散列函数而言，可能的散列值总数为 2160。显然，不同的消息就有可能会产生相同的散列值，即散列函数具有碰撞的**不可避免性**。

但是，散列算法的**安全性**要求找到一个碰撞在计算上是不可行的。也就是说，要求碰撞是不可预测的，攻击者不能指望对输入 消息的预期改变可以得到一个相同的散列值。


### Message Digest Applications
散列函数的主要应用有以下三个方面:
(1)保证数据的**完整性** 
例如，为保证数据或文件的完整性，可以使用散列函数对数据或文件生成其散列码，并加以安全保存，然后，每当使用数据或文件时，用户可使用散列函数重新计算其散列码，并与保存的散列码进行比较，如果相等，说明数据是完整的，没有经过改动;否则，数据表示已经被篡改过。这样，可发现病毒或入侵者对程序或文档的非授权地篡改。

(2)**单向数据加密** 
应用于诸如用户口令加密等场合。将用户口令的散列码存放到一个口令表中，使用时将用户输入的口令进行相应散列运算后，再与口令表中对应用户的口令散列码比较，从而完成口令的有效性验证， 这种方式可避免以明文的形式保存用户口令，也无需解密运算，增强了用户口令的安全性，这种单向数 据加密至今仍然在许多信息系统中得到广泛使用。

(3)**数字签名**
将散列函数应用于数字签名可以提高高签名的速度，不泄露数字签名所对应的原始消息，而且还可以将消息的签名变换与加密变换分开处理，因此散列函数在数字签名中得到普遍应用。



## Message Digest Principles
### Iterative Message Digest Models


### Design Principles of Message Digest
#### Asymmetric Cipher Based Design


#### Symmetric Block Cipher Based Design


#### Direct Design
这类散列函数并不基于任何假设和密码体制，它是通过直接构造复杂的非线性关系达到单向性要求 来设计单向散列函数。这类散列算法典型的有:MD2、MD4、MD5、SHA 系列等散列算法。目前，直 接设计散列函数的方法受到了人们的广泛关注和重视，是较普遍采用的一种设计方法，下面以 SHA-1 为例进行介绍。



## Ref

