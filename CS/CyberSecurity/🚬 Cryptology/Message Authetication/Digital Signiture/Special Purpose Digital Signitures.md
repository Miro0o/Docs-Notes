# Special Purpose Digital Signitures

[TOC]



## Res


## Intro
#TODO 



## 1️⃣ Undeniable Signature Scheme
不可否认签名的概念首先由 D.Chaum 和 Van Antwerpen 在 1989 年提出，该数字签名方案兼顾了签 名者和接收者的利益，既保证签名不能被接收者滥用，又能够在以后使签名让其他的人相信。不可否认性包括两层含义:签名的证实和否定必须与签名者合作完成;签名者不能否认他曾签过的签名。在不可否认签名方案中，若没有签名者的配合，签名就不能得到验证，从而防止未经签名者的授权，签名文件被复制和分发的可能;而在签名者的配合下，验证者可对数字签名进行验证。如果签名是伪造的，签名者和验证者的配合下能证明该签名事实上是伪造的。而当一个签名通过验证，结果表明是签名者的签名时，签名者不能否认这个签名事实。

同时，不可否认签名方案借用了法律的原理来防止签名者的抵赖行为。如果签名者拒绝参与签名验 证，在法理上就存在否认签名的嫌疑，可认定签名者的签名事实;如果在验证过程中，签名者用虚假的 方法或数据，验证算法可以发现签名者的造假行为，也可认定签名者的签名事实;如果验证者提供的签名是伪造的，则签名者也可以发现并证明，从而否认这个签名。


### USS Components 
一个不可否认数字签名方案通常由三个部分组成: 签名算法、验证算法和否认协议。 

(1)**签名生成算法**
合法的签名者可以使用该算法生成有效的数字签名，其他的任何人都不能伪造签名者的签名。 

(2)**签名的验证协议**
签名者和验证者执行交互式协议，验证协议必须具备完备性和合理性:只要签名者和验证者都是诚 实的，则签名者签署的签名总是能够通过验证协议，从而被验证者接受;同时，若一个不是由签名者签 署的签名，无论签名者如何狡辩，要使得签名通过验证协议，并使得验证者接受的概率是可以忽略的。 

(3)**签名的否认协议**
在上一步的签名验证失败时，签名者和验证者执行交互式协议，以确定签名者是否试图不诚实地否 认该数字签名;还是该签名本身的确是伪造，使得签名者能够向验证者证明该签名的确不是自己签署的。 否认协议同样也必须具备完备性和合理性。


### USS Process

#TODO 

#### Disavowal Protocol



## 2️⃣ Blind Signature
在常规的数字签名方案中，签名者总是先知道数据的内容后才实施签名，这是通常的办公事务所需 要的。但有时却需要某个人对某数据签名，而又不能让他知道数据的内容，这种签名方式称为盲数字签 名(Blind Signature)，简称盲签名。

为了更好理解盲签名，可以将这种签名方式比喻成在信封上签名，明文就是书信的内容，为了不使 签名者看到明文，给信纸再加一个具有复写能力的信封，这一过程称为盲化处理。经过盲化的文件，别 人是不能读的。然后签名者在盲化后的文件上签名，如使用硬笔在信封上签名，由于信封具有复写能力， 所以签名也会签到信封内的信纸上。这样就既实现了数字签名，而签名者又没有获悉书信的具体内容。

盲数字签名在需要实现某些参加者匿名性的密码协议中有着广泛而重要的应用，例如无记名电子投 票选举和安全的电子支付系统等。


### Blind Signature Properties
与普通数字签名比较，盲数字签名具有两个显著特点:  
(1) 消息的内容对签名者是不可见的。  
(2) 在签名被接收者公开后，签名者不能追踪签名。 


### Blind Signature Principles
盲签名的基本原理是两个可交换算法的应用，第一个算法是加密算法，它用来隐藏消息，实现盲化 处理，第二个算法为签名算法，用来对消息进行签名。  

例如，设机密消息 m 的拥有者为用户 A，签名者为 B。盲算法(及其密钥)Eka 为 A 拥有，签名算法(及其密钥)Sigkb 为 B 拥有，所有算法及其验证密钥公开，其他密钥保密，则盲签名过程为:  
(1) 用户 A 将消息加密 $C_a=E_{ka}(m)$，实现盲化变换，然后将盲化后的消息 $C_a$ 发送给签名者 B;  
(2) 签名者 B 用其签名算法及密钥对盲化消息 Ca 进行签名，$C_{ab}=Sig_{kb}(Ca)$ ，然后将 $C_{ab}$ 发送给 A; (3) 用户 A 对已签名消息 $C_{ab}$ 解盲，得到
$$C_b=D_{ka}[C_{ab}]=D_{ka}[Sig_{kb}(E_{ka}(m))]=Sig_{kb}[D_{ka}(E_{ka}(m))]=Sig_{kb}(m)$$

至此用户 A 得到了签名者 B 对消息 m 的盲签名。

盲化处理变换根据具体的签名算法而定，基本的要求是它与签名算法必须可换。


### D.Chuaum - RSA Based Blind Signature
下面介绍 D.Chaum 利用 RSA 算法设计的第一个盲数字签名方案。  

设签名者 B 的公钥为 e，私钥为 d，模数为 n。用户 A 有消息 m 需要签名者 B 对消息 m 进行盲签名。

(1) 用户 A 随机选取一个整数 $1≤k≤m$，做盲化处理:
$$t=m·ke mod n$$
将 t 发送给签名者 B;


(2) 签名B对t进行签名 $$s = td = (m·ke)d mod n=md·k mod n$$
然后发送将签名 s 给用户 A;


(3) 用户 A 收到盲签名信息 s 后，通过解盲计算得到 B 对消息 m 的签名信息 S:
$$S=s·k-1 mod n=md·k·k-1 mod n=md mod n$$

至此，用户 A 得到了签名者 B 对消息 m 的盲签名。




## 3️⃣ Group Signature
在常规的数字签名方案中，一个消息的数字签名只是将该消息和某个具体签名者个体进行了可信的 联系，而在匿名电子选举、电子货币匿名发行及网上投标等实际应用场合常常需要这样一种数字签名机 制:某个群组中的任何一个成员都可以以群组的名义匿名签发消息，验证者可以确认数字签名来自该群 组，但不能确认是群组中的哪一个成员进行的签名。但当出现争议时，借助于一个可信的机构或群成员 的联合就能识别出那个签名者。满足以上要求的数字签名就是群签名(Group signature)。

网上匿名投标是群签名技术的一个典型应用实例。这时，群组是由所有􏰀交投标报告的公司组成的 集合，群成员是每个投标公司。每个投标公司可匿名地使用群数字签名算法对投标报告进行签名，招标 机构很容易验证这是一个有效的签名标书。当某个投标被选中后，通过可信机构那个签名者能被识别出， 而其它投标的签名者仍然是匿名的。如果签名者反悔他的投标，那么无需签名者的合作，就能识别出他的身份。

### Group Signature Requirements
一般来说，群签名方案涉及的实体包括群组、群组成员(签名者)、签名验证者及一个可信机构， 并具有以下特点:
(1)只有群组的成员能代表这个群组对消息签名，并产生群签名;
(2)签名验证者能验证这个签名是该群组的一个有效签名，但不能辨认是群组中哪个成员产生的 签名;
(3)在后来发生争端的情况下，通过可信机构能识别出那个签名者。


### Group Signature Properties
因此一个安全的群签名算法必须具有以下性质: 
(1)匿名性。给定某个消息的一个有效群签名后，除了可信机构之外，任何人识别出签名人的身份在计算上是不可行的。
(2)不关联性。除了可信机构之外，确定两个不同的有效群签名是否源自同一个群成员所签，在计算上是不可行的。
(3)防伪造性。只有群成员才能代表这个群组产生有效的群签名。 
(4)可跟踪性。可信机构在必要时可以识别出群签名者的身份。
(5)可开脱性。可信机构及任何群成员都不能以其他群成员的名义产生出有效的群签名，这样群成员不必为他人产生的群签名负责。 
(6)抗合谋攻击。即使一些群成员合谋也不能产生一个有效的群签名，使得可信机构不能将群签名与其中一个群成员的身份联系起来。


### Group Signature Design Principles
一个群签名方案主要由签名算法、验证算法和识别算法组成。

下面给出一种群签名方案的基本思想。
假定有 n 个用户构成了一个群组 G，T 是一个可信机构。可信机构选取大素数 p，使得在 Zp 上的离散对数是难解问题，g 是 Zp\* 的本原元。设第 i 个成员有一个基本密钥 si，对应的基本公钥是 gsi mod p (1 ≤i≤n)。可信机构T为成员i选取一个随机数ri∈Zp\* 作为盲化因子，将其盲化公钥(gsi)ri modp(1≤i≤n)， 随机排序后予以公布。群组 G 中成员 i 使用 risi mod(p-1) 作为签名的秘密密钥。同时，可信机构保存 所有群组成员姓名、基本公钥和盲化公钥的信息表。

在签名产生阶段，群组 G 中成员可使用 ElGamal 数字签名方案、不可否认的数字签名方案对消息 m 进行签名。当签名接收者收到消息及签名时，使用公布的盲化公钥表中每个公钥进行验证，只要有一个公钥能够使签名通过验证，就表明这个签名是群组 G 的一个合法签名。

如果发生争执，签名接收者可将通过验证的公钥和签名一起􏰀交给可信机构 T，T 可利用这些消息 及他存储的公钥和群组成员名字的对应表找出相对应的签名者。从安全性考虑，该方案需要可信机构为群组成员定期更换盲化因子。



## Ref


