# ğŸ´â€â˜ ï¸ Techniques - Vulnerability Disclosure & Discovery

[TOC]



## Res
### Related Topics
â†— [Software Quality Assurance (SQA)](../../../../../Software%20Engineering/ğŸ­%20Software%20Quality%20Assurance%20(SQA)/Software%20Quality%20Assurance%20(SQA).md)
â†— [ICT System Reliability (Correctness) & Verification](../../../../â›ˆï¸%20Risk%20Management/ğŸ¦Ÿ%20Vulnerabilities/ICT%20System%20Reliability%20(Correctness)%20&%20Verification.md)

â†— [Malware (Malicious Code), Analysis, and Detection](../../ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/Malware%20(Malicious%20Code),%20Analysis,%20and%20Detection/Malware%20(Malicious%20Code),%20Analysis,%20and%20Detection.md)
â†— [Malware Discovery Tools & Scanners](../../../../â˜ ï¸%20Kill%20Chain%20&%20Security%20Tool%20Box/ğŸ”%20Software%20Analysis%20Tools/Malware%20Discovery%20Tools%20&%20Scanners.md)

â†— [Software Testing](../../../../../Software%20Engineering/ğŸ­%20Software%20Quality%20Assurance%20(SQA)/ğŸ§ª%20Software%20Testing/Software%20Testing.md)
â†— [Network Penetration (Pen-testing)](../../../../Application%20Security/ğŸ’‰%20Web%20Security/Network%20Penetration%20(Pen-testing)/Network%20Penetration%20(Pen-testing).md)

â†— [Security Audit & Security Audit Trail](../../../../â›ˆï¸%20Risk%20Management/ğŸº%20Risk%20Countermeasures%20&%20Security%20Control/Security%20Audit%20&%20Security%20Audit%20Trail/Security%20Audit%20&%20Security%20Audit%20Trail.md)
â†— [Code Review](../../../../â›ˆï¸%20Risk%20Management/ğŸº%20Risk%20Countermeasures%20&%20Security%20Control/Security%20Audit%20&%20Security%20Audit%20Trail/Code%20Review.md)

â†— [Formal Methods & Formal Verification (FV)](../../ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ™‡â€â™‚ï¸%20Formal%20Methods%20&%20Formal%20Verification%20(FV)/Formal%20Methods%20&%20Formal%20Verification%20(FV).md)

â†— [Software (Program) Analysis Basics](../../ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/Software%20(Program)%20Analysis%20Basics.md)
- â†— [DCA (Dynamic Code Analysis) & DAST](../../ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ‘™%20DCA%20(Dynamic%20Code%20Analysis)%20&%20DAST/DCA%20(Dynamic%20Code%20Analysis)%20&%20DAST.md)
	- â†— [Fuzzing (Concrete Execution)](../../ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ‘™%20DCA%20(Dynamic%20Code%20Analysis)%20&%20DAST/Fuzzing%20(Concrete%20Execution)/Fuzzing%20(Concrete%20Execution).md)
	- â†— [Software Analysis in VM & Sandbox](../../ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ‘™%20DCA%20(Dynamic%20Code%20Analysis)%20&%20DAST/Software%20Analysis%20in%20VM%20&%20Sandbox/Software%20Analysis%20in%20VM%20&%20Sandbox.md)
- â†— [SCA (Static Code Analysis) & SAST](../../ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ‘š%20SCA%20(Static%20Code%20Analysis)%20&%20SAST/SCA%20(Static%20Code%20Analysis)%20&%20SAST.md)
	- â†— [Symbolic Execution & Concolic Execution](../../ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ‘™%20DCA%20(Dynamic%20Code%20Analysis)%20&%20DAST/Symbolic%20Execution%20&%20Concolic%20Execution/Symbolic%20Execution%20&%20Concolic%20Execution.md)

â†— [LLM & Security](../../../../ğŸ«§%20AI%20x%20Security/LLM%20&%20Security/LLM%20&%20Security.md)


### Learning Resources
ğŸ“– Practical Malware Analysis
ğŸ§ª https://github.com/mikesiko/PracticalMalwareAnalysis-Labs



## Intro
â†— [Software Vulnerability & Weakness](../Software%20Vulnerability%20&%20Weakness.md)


### Static Vulnerability Discovery
> Y. Shoshitaishvili et al., "SOK: (State of) The Art of War: Offensive Techniques in Binary Analysis," 2016 IEEE Symposium on Security and Privacy (SP), San Jose, CA, USA, 2016, pp. 138-157, doi: 10.1109/SP.2016.17. https://ieeexplore.ieee.org/document/7546500?denied=

Static techniques reason about a program without executing it. Usually, a program is interpreted over anÂ _abstract domain_. Memory locations containing bits of ones and zeroes contain other abstract entities (at the familiar end, this might simply be integers, but, as we explain below, these can include more abstract constructs). Additionally, program constructs such as the layout of memory, or even the execution path taken, may be abstracted as well.

Here, we split static analyses into two paradigms: those that model program properties as graphs (i.e., aÂ _control-flow graph_) and those that model the data itself.

Static vulnerability identification techniques have two main drawbacks, relating to the trade-offs discussed inÂ Section II-A. First, the results are notÂ _replayable_: detection by static analysis must be verified by hand, as information onÂ _how_Â to trigger the detected vulnerability is not recovered. Second, these analyses tend to operate on simpler data domains, reducing theirÂ _semantic insight_. In short, they over-approximate: while they can often authoritatively reason about theÂ _absence_Â of certain program properties (such as vulnerabilities), they suffer from a high rate of false positives when making statements regarding theÂ _presence_Â of vulnerabilities.

...
- A. Recovering Control Flow
- B. Vulnerability Detection with Flow Modeling
- C. Vulnerability Detection with Data Modeling


### Dynamic Vulnerability Discovery
> Y. Shoshitaishvili et al., "SOK: (State of) The Art of War: Offensive Techniques in Binary Analysis," 2016 IEEE Symposium on Security and Privacy (SP), San Jose, CA, USA, 2016, pp. 138-157, doi: 10.1109/SP.2016.17. https://ieeexplore.ieee.org/document/7546500?denied=

Dynamic approaches are analyses that examine a program's execution, in an actual or emulated environment, as it acts given a specific input. In this section, we will focus specifically on dynamic techniques that are used for identifying vulnerabilities, rather than the general binary analysis techniques on which they are based.

Dynamic techniques are split into two main categories: concrete and symbolic execution. These techniques produce inputs that are highlyÂ _replayable_, but vary in terms ofÂ _semantic insight_.

...
- A. Dynamic Concrete Execution
	- fuzzing
- B. Dynamic Symbolic Execution
	- symbolic-assisted fuzzing
	- under-constrained symbolic execution



## Exploitation
> Y. Shoshitaishvili et al., "SOK: (State of) The Art of War: Offensive Techniques in Binary Analysis," 2016 IEEE Symposium on Security and Privacy (SP), San Jose, CA, USA, 2016, pp. 138-157, doi: 10.1109/SP.2016.17. https://ieeexplore.ieee.org/document/7546500?denied=

Vulnerability discovery analyses actually discoverÂ _crashing inputs_. Triaging these crashing inputs â€“ that is, understanding which crashes represent actual security issues, is outside of the scope of most such approaches. However, some work does exist on the reproduction and analysis of the discovered vulnerabilities. In this section, we go through the process of reproducing an identified crash, automatically generating the exploit to verify the security impact of the crash, and hardening the exploit to make it resilient in the presence of modern mitigation techniques.


### A. Crash Reproduction
Most vulnerability discovery analyses execute a tested application in less-than-realistic conditions. For example, many fuzzers willÂ _de-randomize_Â execution. That is, they will hard-code any sources of randomness, such as the PID of the executable, the current time, and so on. This is done for two main reasons. First, in most modern fuzzing approaches, there is an implicit assumption that the same input, provided to two instantiations of an application, will produce the same result both times. Second, the modeling of randomness in other techniques, such as dynamic symbolic execution, is not a well-explored research area.

Because of de-randomization, the crashes reported by vulnerability discovery techniques might not be trivially replayable outside of the analysis environment. Consider the case of an application that generates a random token and requires the token to be provided by the user before entering an unsafe section of code and crashing. In the de-randomized analysis environment, the generated token will always have the same value, and the crashing input identified by the analysis will always take the same path, resulting in a crash. However,Â _outside_Â of the analysis environment, the token will always be different, and the previously-crashing input might instead take aÂ _non-crashing_Â path.
environment, and a new crashing input might be found. Analyses exist that specialize in the identification of data leaksÂ [42], but we have not yet implemented such analyses inÂ angr.

In the latter case, the de-randomized crashing input must be converted into anÂ _input specification_Â that defines how to communicate with an application in terms of the relationship between data received from the application and data later provided to it. One approach that does this is ReplayerÂ [43], which computes preconditions on program paths to understand how to reproduce a program path under real-world conditions.


### B. Exploit Generation
With a productive vulnerability excavation engine utilizing one or more of the methods described above, many crashes might be produced for a tested application. However, not all of these crashes will be exploitable. An example of a non-exploitable input is a NULL-pointer dereference. Because modern operating systems disallow the mapping of memory at address 0, these previously-exploitable situations have been reduced to non-exploitable crashes. Understanding whether a crash is exploitable helps with theÂ _triaging_Â of bugs (that is, understanding which bugs to investigate and fix first).

The obvious way to test if a crash would be exploitable is to try to exploit it. To this end, several systems have been proposed that attempt to take a crashing input and automatically convert it into an exploit for the applicationÂ [4],Â [31],Â [51].


### C. Exploit Hardening
In recent years, binary hardening techniques, such as non-executable stack regions and Address Space Layout Randomization (ASLR), have severely reduced the efficacy of traditional exploits, such as those generated by first-generation automatic exploitation engines. Thus, even an exploitable vulnerability might be mitigated by modern protections.

Current automatic exploitation techniques were designed before the widespread adoption of modern mitigation techniques, and modern software protections make the exploits they produce non-functional. To circumvent this, approaches have been created to automaticallyÂ _harden_Â the exploits generated using current techniques against such defenses. Such techniques work by translating a traditional, shellcode-based exploit into an equivalent exploit utilizing Return-Oriented ProgrammingÂ [52]. As such, an automatic approach to constructing Return-Oriented Programs is required, and several such approaches have been developedÂ [18],Â [48].



## Ref
[ä»"æ–°"å¼€å§‹å­¦ä¹ æ¶æ„ä»£ç åˆ†æâ€”â€”é™æ€åˆ†æ]: https://www.anquanke.com/post/id/207594#h2-0

[ğŸ‘ Hunting for Malicious Packages on PyPI]: https://jordan-wright.com/blog/post/2020-11-12-hunting-for-malicious-packages-on-pypi/
About a year ago, the Python Software FoundationÂ [opened a Request for Information (RFI)](https://discuss.python.org/t/what-methods-should-we-implement-to-detect-malicious-content/2240)Â to discuss how we could detect malicious packages being uploaded to PyPI. Whether itâ€™sÂ [taking over abandoned packages](https://blog.npmjs.org/post/141577284765/kik-left-pad-and-npm),Â [typosquatting on popular libraries](https://github.com/dateutil/dateutil/issues/984), orÂ [hijacking packages using credential stuffing](https://github.com/ChALkeR/notes/blob/master/Gathering-weak-npm-credentials.md), itâ€™s clear this is a real issue affecting nearly every package manager. 

The truth is that package managers like PyPI are critical infrastructure that almost every company relies on. I could write for days on this topic, but Iâ€™ll just let this xkcd suffice for now.

![](../../../../../../../Assets/Pics/Pasted%20image%2020240915011047.png)

[ğŸ‘ Finding malicious PyPI packages through static code analysis: Meet GuardDog]: https://securitylabs.datadoghq.com/articles/guarddog-identify-malicious-pypi-packages/
