# Models of Computation & Abstract Machines

[TOC]



## Res
### Related Topics
â†— [Model Theory (æ¨¡å‹è®º)](../../Model%20Theory%20(æ¨¡å‹è®º)/Model%20Theory%20(æ¨¡å‹è®º).md)

â†— [Theory of Computation](../Theory%20of%20Computation.md)
- â†— [Automata Theory and (Formal) Language Theory](../ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)
- â†— [Computability (Recursion) Theory - Turing Machine and R.E. Language](../Computability%20(Recursion)%20Theory%20-%20Turing%20Machine%20and%20R.E.%20Language/Computability%20(Recursion)%20Theory%20-%20Turing%20Machine%20and%20R.E.%20Language.md)
- â†— [Complexity Theory & Computational Complexity](../Complexity%20Theory%20&%20Computational%20Complexity/Complexity%20Theory%20&%20Computational%20Complexity.md)

â†— [Formal System, Formal Logics, and Its Semantics](../../ğŸ“%20Formal%20System,%20Formal%20Logics,%20and%20Its%20Semantics/Formal%20System,%20Formal%20Logics,%20and%20Its%20Semantics.md)
- â†— [Classical Logic (Standard Formal Logic)](../../ğŸ“%20Formal%20System,%20Formal%20Logics,%20and%20Its%20Semantics/Classical%20Logic%20(Standard%20Formal%20Logic)/Classical%20Logic%20(Standard%20Formal%20Logic).md)
- â†— [Lambda Calculus (Î»-Calculus)](../../ğŸ“%20Formal%20System,%20Formal%20Logics,%20and%20Its%20Semantics/ğŸ©%20Higher-Order%20Languages%20&%20Logics%20(HOL)/Lambda%20Calculus%20(Î»-Calculus)/Lambda%20Calculus%20(Î»-Calculus).md)

â†— [Computer Languages & Programming Methodology](../../../../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/Computer%20Languages%20&%20Programming%20Methodology.md)
â†— [Programming Language Theory (PLT)](../../../../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Programming%20Language%20Theory%20(PLT).md)
â†— [Logic Programming Languages](../../../../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/Other%20Languages%20for%20Specific%20Areas/Logic%20Programming%20Languages/Logic%20Programming%20Languages.md)

â†— [(Formal) Model Checking](../../../../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ™‡â€â™‚ï¸%20Formal%20Methods%20&%20Formal%20Verification%20(FV)/(Formal)%20Model%20Checking/(Formal)%20Model%20Checking.md)
â†— [Probabilistic Models (Distributions) & Stochastic Process](../../../ğŸ§%20Mathematical%20Analysis%20(&%20Analytical%20Mathematics)/ğŸ“%20Measures%20(Measure%20Theory)/ğŸ“Š%20Probability%20Theory%20&%20Statistics/ğŸŒğŸ»â€â™‚ï¸%20Probabilistic%20Models%20(Distributions)%20&%20Stochastic%20Process/Probabilistic%20Models%20(Distributions)%20&%20Stochastic%20Process.md)

â†— [Higher-Order Languages & Logics (HOL)](../../ğŸ“%20Formal%20System,%20Formal%20Logics,%20and%20Its%20Semantics/ğŸ©%20Higher-Order%20Languages%20&%20Logics%20(HOL)/Higher-Order%20Languages%20&%20Logics%20(HOL).md)

â†— [AI Basics & Major Techniques](../../../../ğŸ§ %20Computing%20Methodologies/ğŸ‘½%20Artificial%20Intelligence/ğŸ—ï¸%20AI%20Basics%20&%20Major%20Techniques/AI%20Basics%20&%20Major%20Techniques.md)
- â†— [Reflex-Based Models](../../../../ğŸ§ %20Computing%20Methodologies/ğŸ‘½%20Artificial%20Intelligence/ğŸ—ï¸%20AI%20Basics%20&%20Major%20Techniques/Agent%20Decision%20Models%20(Semantic%20Level)/Reflex-Based%20Models.md)
- â†— [Logic-Based Models](../../../../ğŸ§ %20Computing%20Methodologies/ğŸ‘½%20Artificial%20Intelligence/ğŸ—ï¸%20AI%20Basics%20&%20Major%20Techniques/Agent%20Decision%20Models%20(Semantic%20Level)/Logic-Based%20Models.md)
- â†— [State-Based Models](../../../../ğŸ§ %20Computing%20Methodologies/ğŸ‘½%20Artificial%20Intelligence/ğŸ—ï¸%20AI%20Basics%20&%20Major%20Techniques/Agent%20Decision%20Models%20(Semantic%20Level)/State-Based%20Models.md)
- â†— [Variables-Based Models](../../../../ğŸ§ %20Computing%20Methodologies/ğŸ‘½%20Artificial%20Intelligence/ğŸ—ï¸%20AI%20Basics%20&%20Major%20Techniques/Agent%20Decision%20Models%20(Semantic%20Level)/Variables-Based%20Models.md)
â†— [Knowledge Representation (Syntax Level) and Reasoning (KRR)](../../../../ğŸ§ %20Computing%20Methodologies/ğŸ‘½%20Artificial%20Intelligence/ğŸ—ï¸%20AI%20Basics%20&%20Major%20Techniques/Knowledge%20Representation%20(Syntax%20Level)%20and%20Reasoning%20(KRR)/Knowledge%20Representation%20(Syntax%20Level)%20and%20Reasoning%20(KRR).md)


### Other Resources



## Intro
> [!links]
> â†— [Mathematical Modeling & Real World Problem Solving](../../../Mathematical%20Modeling%20&%20Real%20World%20Problem%20Solving.md)
> â†— [(Formal) Model Checking /1ï¸âƒ£ System Modeling](../../../../CyberSecurity/ğŸ°%20Cybersecurity%20Basics%20&%20InfoSec/ğŸ¦%20Software%20Security/ğŸª†%20Software%20(Program)%20Analysis%20&%20Binary%20Engineering/ğŸ“Œ%20Software%20(Program)%20Analysis%20Basics/ğŸ™‡â€â™‚ï¸%20Formal%20Methods%20&%20Formal%20Verification%20(FV)/(Formal)%20Model%20Checking/(Formal)%20Model%20Checking.md#1ï¸âƒ£%20System%20Modeling)
> â†— [The Essence of Computing - Programs & The Semantics of Programs](../../../../ğŸ—º%20CS%20Overview/The%20Essence%20of%20Computing%20-%20Programs%20&%20The%20Semantics%20of%20Programs.md)
> â†— [Formal Semantics and Programming Language](../../../../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ğŸ¢%20Programming%20Language%20Theory%20(PLT)/Formal%20Semantics%20and%20Programming%20Language/Formal%20Semantics%20and%20Programming%20Language.md)
> 
> â†— [Proof Theory](../../Proof%20Theory/Proof%20Theory.md)
> - â†— [Computational Trilogy & Curryâ€“Howard(â€“Lambek) Correspondence](../../Proof%20Theory/Computational%20Trilogy%20&%20Curryâ€“Howard(â€“Lambek)%20Correspondence.md)
> â†— [Model Theory (æ¨¡å‹è®º)](../../Model%20Theory%20(æ¨¡å‹è®º)/Model%20Theory%20(æ¨¡å‹è®º).md)

![Drawing 2025-09-09 22.37.45.excalidraw | 800](../../../../../Assets/Illustrations/Computer%20Language/Language_and_Programming_Language_Processing.md)
<small>The process of compilation</small>


> ğŸ”— https://en.wikipedia.org/wiki/Model_of_computation

In computer science, and more specifically in computability theory and computational complexity theory, a model of computation is a model which describes how an output of a mathematical function is computed given an input. A model describes how units of computations, memories, and communications are organized. The computational complexity of an algorithm can be measured given a model of computation. Using a model allows studying the performance of algorithms independently of the variations that are specific to particular implementations and specific technology.


### Sequential Models
Sequential models include:
- [Finite-state machines](https://en.wikipedia.org/wiki/Finite-state_machine "Finite-state machine")
- Post machines ([Postâ€“Turing machines](https://en.wikipedia.org/wiki/Post%E2%80%93Turing_machine "Postâ€“Turing machine")Â andÂ [tag machines](https://en.wikipedia.org/wiki/Tag_system "Tag system")).
- [Pushdown automata](https://en.wikipedia.org/wiki/Pushdown_automata "Pushdown automata")
- [Register machines](https://en.wikipedia.org/wiki/Register_machine "Register machine")
    - [Random-access machines](https://en.wikipedia.org/wiki/Random-access_machine "Random-access machine")
- [Turing machines](https://en.wikipedia.org/wiki/Turing_machine "Turing machine")
- [Decision tree model](https://en.wikipedia.org/wiki/Decision_tree_model "Decision tree model")
- [External memory model](https://en.wikipedia.org/wiki/External_memory_model "External memory model")


### Functional Models
Functional models include:
- [Abstract rewriting systems](https://en.wikipedia.org/wiki/Abstract_rewriting_system "Abstract rewriting system")
- [Combinatory logic](https://en.wikipedia.org/wiki/Combinatory_logic "Combinatory logic")
- [General recursive functions](https://en.wikipedia.org/wiki/General_recursive_function "General recursive function")
- [Lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus "Lambda calculus")


### Concurrent Models
Concurrent models include:
- [Actor model](https://en.wikipedia.org/wiki/Actor_model "Actor model")
- [Cellular automaton](https://en.wikipedia.org/wiki/Cellular_automaton "Cellular automaton")
- [Interaction nets](https://en.wikipedia.org/wiki/Interaction_nets "Interaction nets")
- [Kahn process networks](https://en.wikipedia.org/wiki/Kahn_process_networks "Kahn process networks")
- [Logic gates](https://en.wikipedia.org/wiki/Logic_gate "Logic gate")Â andÂ [digital circuits](https://en.wikipedia.org/wiki/Circuit_\(computer_science\) "Circuit (computer science)")
- [Petri nets](https://en.wikipedia.org/wiki/Petri_nets "Petri nets")
- [Process calculus](https://en.wikipedia.org/wiki/Process_calculus "Process calculus")
- [Synchronous Data Flow](https://en.wikipedia.org/wiki/Synchronous_Data_Flow "Synchronous Data Flow")

Some of these models have bothÂ [deterministic](https://en.wikipedia.org/wiki/Deterministic_model#In_computer_science "Deterministic model")Â andÂ [nondeterministic](https://en.wikipedia.org/wiki/Nondeterministic_model_of_computation "Nondeterministic model of computation")Â variants. Nondeterministic models correspond to limits of certain sequences of finite computers, but do not correspond to any subset of finite computers;[_[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed "Wikipedia:Citation needed")_]Â they are used in the study ofÂ [computational complexity](https://en.wikipedia.org/wiki/Computational_complexity "Computational complexity")Â of algorithms.

Models differ in their expressive power; for example, each function that can be computed by aÂ _finite-state machine_Â can also be computed by aÂ _Turing machine_, but not vice versa.



## (Symbolic) Transition System â­
> [!links]
> â†— [Graph Theory](../../../ğŸ§‘â€ğŸ¦¯â€â¡ï¸%20Operations%20Research%20(OR)/Combinatorics%20(Combinatorial%20Mathematics)/ğŸ«†%20Graph%20Theory/Graph%20Theory.md)
> â†— [Graph Basics](../../../ğŸ§‘â€ğŸ¦¯â€â¡ï¸%20Operations%20Research%20(OR)/Combinatorics%20(Combinatorial%20Mathematics)/ğŸ«†%20Graph%20Theory/ğŸ“Œ%20Graph%20Theory%20Basics/Graph%20Basics.md)
> 
> â†— [The Essence of Computing - Programs & The Semantics of Programs](../../../../ğŸ—º%20CS%20Overview/The%20Essence%20of%20Computing%20-%20Programs%20&%20The%20Semantics%20of%20Programs.md)
> - programs are transition systems
> - hardware circuits are transition systems
> - communication processes are transition systems
> - etc.

> ğŸ”— https://en.wikipedia.org/wiki/Transition_system

InÂ [theoretical computer science](https://en.wikipedia.org/wiki/Theoretical_computer_science "Theoretical computer science"), aÂ **transition system**Â is a concept used in the study ofÂ [computation](https://en.wikipedia.org/wiki/Computation "Computation"). ==It is used to describe the potential behavior ofÂ [discrete systems](https://en.wikipedia.org/wiki/Discrete_system "Discrete system").== It consists ofÂ [states](https://en.wikipedia.org/wiki/State_\(computer_science\) "State (computer science)")Â and transitions between states, which may be labeled with labels chosen from a set; the same label may appear on more than one transition. If the label set is aÂ [singleton](https://en.wikipedia.org/wiki/Singleton_\(mathematics\) "Singleton (mathematics)"), the system is essentially unlabeled, and a simpler definition that omits the labels is possible.

Transition systems coincide mathematically withÂ [abstract rewriting systems](https://en.wikipedia.org/wiki/Abstract_rewriting_system "Abstract rewriting system")Â (as explained further in this article) andÂ [directed graphs](https://en.wikipedia.org/wiki/Directed_graph "Directed graph"). They differ fromÂ [finite-state automata](https://en.wikipedia.org/wiki/Finite-state_automata "Finite-state automata")Â in several ways:
- The set of states is not necessarily finite, or even countable.
- The set of transitions is not necessarily finite, or even countable.
- No "start" state or "final" states are given.

Transition systems can be represented as **directed graphs**.


### Syntax (Formal Definition) of Transition System
**Formal Definition of Transition System**

Formally, aÂ **transition system**Â is a pairÂ $(S,T)$Â whereÂ $S$Â is a set of states andÂ $T$, theÂ _transition relation_, is a subset ofÂ $S\times S$. We say that there is a transition from stateÂ $p$Â to stateÂ $q$Â ifÂ $(p,q)\in T$, and denote itÂ $p\to q$.

AÂ **labelled transition system**Â is a tupleÂ $(S,\Lambda,T)$Â whereÂ $S$Â is a set of states,Â $\Lambda$Â is a set of labels, andÂ $T$, theÂ _labelled transition relation_, is a subset ofÂ $S\times\Lambda\times S$. We say that there is a transition from stateÂ $p$Â to stateÂ $q$Â with labelÂ $\alpha \iffÂ (p,\alpha ,q)\in T$Â and denote it $p\xrightarrow {\alpha } q$.

Labels can represent different things depending on the language of interest. Typical uses of labels include representing input expected, conditions that must be true to trigger the transition, or actions performed during the transition. Labelled transitions systems were originally introduced asÂ _named_Â transition systems.


**Special cases**
- If, for any givenÂ $p$Â andÂ $\alpha$, there exists only a single tupleÂ $(p,Î±,q)$Â inÂ $T$, then one says thatÂ $Î±$Â is ==deterministicÂ (forÂ $p$)==.
- If, for any givenÂ $p$Â andÂ $\alpha$, there exists at least one tupleÂ $(p,\alpha,q)$Â inÂ $T$, then one says thatÂ $\alpha$Â isÂ ==executable (forÂ $p$)==.


**Coalgebra Formulation**
The formal definition can be rephrased as follows. Labelled state transition systems onÂ $S$Â with labels fromÂ $\Lambda$Â correspondÂ [one-to-one](https://en.wikipedia.org/wiki/Bijection "Bijection")Â with functionsÂ $S\to P(\Lambda\times S)$, whereÂ $P$Â is the (covariant)Â [powerset functor](https://en.wikipedia.org/wiki/Power_set "Power set"). Under this bijectionÂ $(S,\Lambda,T)$Â is sent to $\xi _{T}:S\to {\mathcal {P}}(\Lambda \times S)$, defined by $$p\mapsto \{\,(\alpha ,q)\in \Lambda \times S\mid p\xrightarrow {\alpha } q\,\}$$
In other words, a labelled state transition system is aÂ [coalgebra](https://en.wikipedia.org/wiki/F-coalgebra "F-coalgebra")Â for the functorÂ $P(\Lambda \times {-})$

InÂ [model checking](https://en.wikipedia.org/wiki/Model_checking "Model checking"), a transition system is sometimes defined to include an additional labeling function for the states as well, resulting in a notion that encompasses that ofÂ [Kripke structure](https://en.wikipedia.org/wiki/Kripke_structure "Kripke structure").


**Forward and backwards reachability**
We sometimes need to talk about how states can reach each other.
The set of direct successors of a state s is defined as $ğ‘ƒğ‘œğ‘ ğ‘¡(ğ‘ ) = {ğ‘  âˆ£ âˆƒğ›¼. ğ‘  ğ›¼â†’ğ‘ â€²}$
Similarly, we can define the direct predecessors of a state s as $ğ‘ƒğ‘Ÿğ‘’(ğ‘ ) = {ğ‘  âˆ£ âˆƒğ›¼. ğ‘ â€² ğ›¼â†’ğ‘ }$
The above definitions can be lifted to sets of states A.
ğ‘ƒğ‘œğ‘ ğ‘¡(ğ´) = . . .
ğ‘ƒğ‘Ÿğ‘’(ğ´) = . . .
Successors/predecessors in any number of transitions can be defined likewise.
On a related note, one is typically interested in the part of a transition system that is
reachable from the initial state(s).


**Non-deterministic & Deterministic Transition System**
A transition system is action-deterministic iff
(1) There is no more than 1 initial state $|ğ¼| â‰¤ 1$
(2) For every state s and every action a, there is only one outgoing transition from s
labelled with a. $|{ğ‘ â€² âˆ£ ğ‘  ğ‘â†’ğ‘ â€²}| â‰¤ 1$


**Terminal States**
A state is a terminal state if it has no outgoing transition.
We can write this formally in several ways: a state s is terminal iff
Â¬âˆƒğ‘ â€²
. ğ‘  â†’ ğ‘ â€²
ğ‘ƒğ‘œğ‘ ğ‘¡(ğ‘ ) = âˆ…
Terminal states usually represent final states (the system finished doing its job)
â€¦or deadlock states (the system is stuck).

**Transition systems with no terminals**
From now on we consider w.l.o.g. transition systems with no terminal states.
If you have a terminal state, just add a self-loop.
If you are interested in marking the state as â€œterminalâ€ and distinguish it from proper self-loops, just add as special label to it.
####  Kripke Structure (of Transition System)
> ğŸ”— https://en.wikipedia.org/wiki/Kripke_structure_(model_checking)

AÂ **Kripke structure**Â is a variation of theÂ [transition system](https://en.wikipedia.org/wiki/Transition_system "Transition system"), originally proposed byÂ [Saul Kripke](https://en.wikipedia.org/wiki/Saul_Kripke "Saul Kripke"),Â used inÂ [model checking](https://en.wikipedia.org/wiki/Model_checking "Model checking")Â to represent the behavior of a system. It consists of aÂ [graph](https://en.wikipedia.org/wiki/Graph_\(discrete_mathematics\) "Graph (discrete mathematics)")Â whose nodes represent the reachable states of the system and whose edges represent state transitions, together with a labelling function which maps each node to a set of properties that hold in the corresponding state.Â [Temporal logics](https://en.wikipedia.org/wiki/Temporal_logic "Temporal logic")Â are traditionally interpreted in terms of Kripke structures.

---
**Formal Definition of Kripke Structure**

A transition system (of Kripke Structure) $TS$ is a tuple $(S,Act,\to,I,AP,L)$ where
- $S$ is a set of states,
- $Act$ is a set of actions,
- $\to \subseteq S \times Act \times S$ is a transition relation,
	-  or use $\delta$ to express $\to$
- $I \subseteq S$ is a set of initial states,
	- $\sigma\in I$
	- or, when using $\tau$ or $\pi$ to symbol a trace on $TS$, $\tau_0 = \sigma \in I$ or $\pi_0=\sigma\in I$
- $AP$ is a set of atomic propositions, 
- $L$: $Sâ†’AP^2$ is a labeling function.

$TS$ is called **finite** if $S$, $Act$, and $AP$ are **finite**.

It is important to realize that in case a state has more than one outgoing transition, the
â€œnextâ€ transition is chosen in a purely **nondeterministic** fashion. That is, the outcome of
this selection process is not known a priori, and, hence, no statement can be made about the likelihood with which a certain transition is selected. Similarly, when the set of initial states consists of more than one state, the start state is selected nondeterministically.

For convenience, we write $s \xrightarrow[]{\alpha}s'$ instead of $(s,Î±,s') \in \to$.

The labeling function $L$ relates a set $L(s) \in AP^2$ of atomic propositions to any state $s$. $L(s)$ intuitively stands for exactly those atomic propositions $a \in AP$ which are satisfied by state $s$. Given that $Î¦$ is a propositional logic formula, then $s$ satisfies the formula $Î¦$ if the evaluation induced by $L(s)$ makes the formula Î¦ true; that is: $s \models \Phi \iff L(s) \models \Phi$.

![](../../../../../../../../Assets/Pics/Screenshot%202025-09-23%20at%2018.33.15.png)
<small><a>https://www.cs.cmu.edu/~emc/15414-f12/lecture/temporal_logics.pdf#page=1.00</a></small>
![](../../../../../../../../Assets/Pics/Screenshot%202025-09-23%20at%2018.34.43.png)
<small><a>https://www.cs.cmu.edu/~emc/15414-f12/lecture/temporal_logics.pdf#page=1.00</a></small>
#### Action Language
[Action languages](https://en.wikipedia.org/wiki/Action_language "Action language")Â are extensions of transition systems, adding a set ofÂ _fluents_Â _F_, a set of valuesÂ _V_, and a function that mapsÂ _F_Â Ã—Â _S_Â toÂ _V_.
#### Automata & State Machine
â†— [Automata Theory and (Formal) Language Theory](../ğŸ%20Automata%20Theory%20and%20(Formal)%20Language%20Theory/Automata%20Theory%20and%20(Formal)%20Language%20Theory.md)

> [!quote]
> Transition systems coincide mathematically withÂ [abstract rewriting systems](https://en.wikipedia.org/wiki/Abstract_rewriting_system "Abstract rewriting system")Â (as explained further in this article) andÂ [directed graphs](https://en.wikipedia.org/wiki/Directed_graph "Directed graph"). They differ fromÂ [finite-state automata](https://en.wikipedia.org/wiki/Finite-state_automata "Finite-state automata")Â in several ways:
> - The set of states is not necessarily finite, or even countable.
> - The set of transitions is not necessarily finite, or even countable.
> - No "start" state or "final" states are given.
#### Probabilistic Version of Transition Systems
â†— [Probability Theory & Statistics](../../../ğŸ§%20Mathematical%20Analysis%20(&%20Analytical%20Mathematics)/ğŸ“%20Measures%20(Measure%20Theory)/ğŸ“Š%20Probability%20Theory%20&%20Statistics/Probability%20Theory%20&%20Statistics.md)
â†— [Markov Process & Markov Chain (MC)](../../../ğŸ§%20Mathematical%20Analysis%20(&%20Analytical%20Mathematics)/ğŸ“%20Measures%20(Measure%20Theory)/ğŸ“Š%20Probability%20Theory%20&%20Statistics/ğŸŒğŸ»â€â™‚ï¸%20Probabilistic%20Models%20(Distributions)%20&%20Stochastic%20Process/Markov%20Process%20&%20Markov%20Chain%20(MC)/Markov%20Process%20&%20Markov%20Chain%20(MC).md)
- â†— [Discrete-Time Markov Chains (DTMC)](../../../ğŸ§%20Mathematical%20Analysis%20(&%20Analytical%20Mathematics)/ğŸ“%20Measures%20(Measure%20Theory)/ğŸ“Š%20Probability%20Theory%20&%20Statistics/ğŸŒğŸ»â€â™‚ï¸%20Probabilistic%20Models%20(Distributions)%20&%20Stochastic%20Process/Markov%20Process%20&%20Markov%20Chain%20(MC)/Discrete-Time%20Markov%20Chains%20(DTMC)/Discrete-Time%20Markov%20Chains%20(DTMC).md)
- â†— [Markov Decision Processes (MDP) & Stochastic Dynamic Program](../../../ğŸ§%20Mathematical%20Analysis%20(&%20Analytical%20Mathematics)/ğŸ“%20Measures%20(Measure%20Theory)/ğŸ“Š%20Probability%20Theory%20&%20Statistics/ğŸŒğŸ»â€â™‚ï¸%20Probabilistic%20Models%20(Distributions)%20&%20Stochastic%20Process/Markov%20Process%20&%20Markov%20Chain%20(MC)/Markov%20Decision%20Processes%20(MDP)%20&%20Stochastic%20Dynamic%20Program/Markov%20Decision%20Processes%20(MDP)%20&%20Stochastic%20Dynamic%20Program.md)
$$\text{Data} \ \overset{Statistics}{\to} \ \text{Models (Rules)} \ \overset{Probability}{\to} \ Data ()$$

### Semantics of Transition System
> [!links]
> â†— [Graph Basics](../../../ğŸ§‘â€ğŸ¦¯â€â¡ï¸%20Operations%20Research%20(OR)/Combinatorics%20(Combinatorial%20Mathematics)/ğŸ«†%20Graph%20Theory/ğŸ“Œ%20Graph%20Theory%20Basics/Graph%20Basics.md)
#### Execution & Trace
**Execution**
An execution fragment is a sequence of transitions.
$s_0\overset{click}{\to}s_1\overset{click}{\to}s_2...$

An execution is finite/infinite if the sequence is finite/infinite.
$s_0\overset{click}{\to}s_1 \text{ or }(s_2\overset{click}{\to}s_2)^w$

An execution is initial if the first state of the sequence is in I.

An execution is maximal if it cannot be extended: either it is finite and the last state is a terminal state, or it is infinite.

NOTE: by our assumption of â€œno terminal stateâ€, only the second case applies.
NOTE: often, we drop the arrows.


**Trace**
Executions may contain too much information, i.e. actual states.
Often, one is interested in the **atomic properties** of states.
Replacing every state in an execution by its atomic properties yields a trace.

We may even drop the transitions and their actions.
#### Computational Tree
Executions and traces can be seen as the system running with a fixed scheduler.
They are not appropriate if we want to see how the system makes choices.
Computation trees can save the day!

**A computation tree is a tree whose nodes are states of a TS (or their atomic propositions).**

The successor of each state in the computation tree is the immediate successor of the state as it appears in the TS.
A computation tree is the unfolding of the transition system.

![](../../../../../../../../Assets/Pics/Screenshot%202025-12-08%20at%2012.19.55.png)


### Composing Transition System
Often, systems (and their models) are made of several components, which interact with each other.
There is a plethora of interaction mechanisms:
- Shared memory / objects / storage (consistent, weak, safe, etc.)
- Networks (synchronous/asynchronous, binary/multi-party, value-passing /rendezvous, etc.)

The transition system of the composition S1âŠ—S2 of two systems S1, S2 can be obtained in two ways.
1. Build TS(S1) and TS(S2), then compose
2. Build the composed TS directly from S1,S2

![](../../../../../../../../Assets/Pics/Screenshot%202025-12-11%20at%2018.27.55.png)

We will see 2 examples of (1): pure interleaving and action-synchronisation and 1 example of (2): concurrent threads with shared memory
#### Interleaving & Synchronised Composition
Interleaving composition of concurrent threads with shared memory: 
- ![](../../../../../../../../Assets/Pics/Screenshot%202025-12-11%20at%2018.28.36.png)
- ![](../../../../../../../../Assets/Pics/Screenshot%202025-12-11%20at%2018.29.13.png)

Formal semantics of the composition typically specified using operational semantics (common in programming languages).

- Synchronised Composition of Transition Systems
	- ![](../../../../../../../../Assets/Pics/Screenshot%202025-12-11%20at%2018.29.29.png)
##### Examples of TS Composition
- ![|400](../../../../../../../../Assets/Pics/Screenshot%202025-12-11%20at%2018.30.21.png)
- ![|400](../../../../../../../../Assets/Pics/Screenshot%202025-12-11%20at%2018.31.12.png)
- ![|400](../../../../../../../../Assets/Pics/Screenshot%202025-12-11%20at%2018.31.31.png)
- ![|400](../../../../../../../../Assets/Pics/Screenshot%202025-12-11%20at%2018.31.44.png)
#### State Space Explosion
In general, the size of the interleaving of n transition systems of m states each is $m^n$
Synchronizations may reduce the size composition but the worstcase is still exponential in the number of components.



## Turing Machine Equivalents / Turing Complete Models
> ğŸ”— https://en.wikipedia.org/wiki/Turing_machine_equivalents


### Turing Machine Variants


### Register Machine
> [!links]
> â†— [CPU (Central Processing Unit)](../../../../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Computer%20Architecture/Computer%20Microarchitectures%20(Computer%20Organization)%20&%20von%20Neumann%20Model/ğŸš¦%20Computer%20Processors%20&%20Logic%20Chips%20(Theory%20Part)/ğŸ“Œ%20Microprocessor%20&%20Microprocessors%20Unit%20(MPU)/ğŸ§ %20CPU%20(Central%20Processing%20Unit)/CPU%20(Central%20Processing%20Unit).md)
> - â†— [Register](../../../../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Computer%20Architecture/Computer%20Microarchitectures%20(Computer%20Organization)%20&%20von%20Neumann%20Model/ğŸš¦%20Computer%20Processors%20&%20Logic%20Chips%20(Theory%20Part)/ğŸ“Œ%20Microprocessor%20&%20Microprocessors%20Unit%20(MPU)/ğŸ§ %20CPU%20(Central%20Processing%20Unit)/ğŸ“Œ%20Inside%20CPU%20Core%20(Core%20Microarchitecture)/Register.md)
> 
> â†— [Instruction Set Architecture (ISA) & Processor Architecture](../../../../ğŸ”‘%20CS%20Core/ğŸ‘·ğŸ¾â€â™‚ï¸%20Computer%20(Host)%20System/Computer%20Architecture/Instruction%20Set%20Architecture%20(ISA)%20&%20Processor%20Architecture/Instruction%20Set%20Architecture%20(ISA)%20&%20Processor%20Architecture.md)
> â†— [ASM (Assembly Languages)](../../../../ğŸ”‘%20CS%20Core/ğŸ‘©â€ğŸ’»%20Computer%20Languages%20&%20Programming%20Methodology/ASM%20(Assembly%20Languages)/ASM%20(Assembly%20Languages).md)

> ğŸ”— https://en.wikipedia.org/wiki/Turing_machine_equivalents#Register_machine_models

[Peter van Emde Boas](https://en.wikipedia.org/wiki/Peter_van_Emde_Boas "Peter van Emde Boas")Â includes all machines of this type in one class, "the register machine".Â However, historically the literature has also called the most primitive member of this group i.e. "the counter machine" â€“ "the register machine". And the most primitive embodiment of a "counter machine" is sometimes called the "Minsky machine".

> ğŸ”— https://en.wikipedia.org/wiki/Register_machine

InÂ [mathematical logic](https://en.wikipedia.org/wiki/Mathematical_logic "Mathematical logic")Â andÂ [theoretical computer science](https://en.wikipedia.org/wiki/Theoretical_computer_science "Theoretical computer science"), aÂ **register machine**Â is a generic class ofÂ [abstract machines](https://en.wikipedia.org/wiki/Abstract_machine "Abstract machine"), analogous to aÂ [Turing machine](https://en.wikipedia.org/wiki/Turing_machine "Turing machine")Â and thusÂ [Turing complete](https://en.wikipedia.org/wiki/Turing_completeness "Turing completeness"). Unlike a Turing machine that uses a tape and head, a register machine utilizes multiple uniquely addressed registers to store non-negative integers. There are several sub-classes of register machines, includingÂ [counter machines](https://en.wikipedia.org/wiki/Counter_machine "Counter machine"),Â [pointer machines](https://en.wikipedia.org/wiki/Pointer_machine "Pointer machine"),Â [random-access machines (RAM)](https://en.wikipedia.org/wiki/Random-access_machine "Random-access machine"), andÂ [Random-Access Stored-Program Machine (RASP)](https://en.wikipedia.org/wiki/Random-access_stored-program_machine "Random-access stored-program machine"), each varying in complexity. These machines, particularly in theoretical studies, help in understanding computational processes. The concept of register machines can also be applied toÂ [virtual machines](https://en.wikipedia.org/wiki/Virtual_machine "Virtual machine")Â in practical computer science, for educational purposes and reducing dependency on specific hardware architectures.

---
**Overview**

The register machine gets its name from its use of one or more "[registers](https://en.wikipedia.org/wiki/Processor_register "Processor register")". In contrast to the tape and head used by aÂ [Turing machine](https://en.wikipedia.org/wiki/Turing_machine "Turing machine"), theÂ [model](https://en.wikipedia.org/wiki/Model "Model")Â usesÂ **multiple uniquely addressed registers**, each of which holds a single non-negativeÂ [integer](https://en.wikipedia.org/wiki/Integer "Integer").

There are at least four sub-classes found in theÂ [literature](https://en.wikipedia.org/wiki/Literature "Literature"). In ascending order of complexity:
- [Counter machine](https://en.wikipedia.org/wiki/Counter_machine "Counter machine")Â â€“ the most primitive and reducedÂ [theoretical](https://en.wikipedia.org/wiki/Theoretical "Theoretical")Â model ofÂ [computer hardware](https://en.wikipedia.org/wiki/Computer_hardware "Computer hardware"). This machine lacks indirect addressing, and instructions are in theÂ [finite state machine](https://en.wikipedia.org/wiki/Finite-state_machine "Finite-state machine")Â in the manner of theÂ [Harvard architecture](https://en.wikipedia.org/wiki/Harvard_architecture "Harvard architecture").
- [Pointer machine](https://en.wikipedia.org/wiki/Pointer_machine "Pointer machine")Â â€“ a blend of the counter machine and RAM models which is less common and more abstract than either model. Instructions are in the finite state machine in the manner of Harvard architecture.
- [Random-access machine](https://en.wikipedia.org/wiki/Random-access_machine "Random-access machine")Â (RAM) â€“ a counter machine with indirect addressing and, usually, an augmented instruction set. Instructions are in the finite state machine in the manner of the Harvard architecture.
- [Random-access stored-program machine](https://en.wikipedia.org/wiki/Random-access_stored-program_machine "Random-access stored-program machine")Â model (RASP) â€“ a RAM with instructions in its registers analogous to theÂ [Universal Turing machine](https://en.wikipedia.org/wiki/Universal_Turing_machine "Universal Turing machine"), making it an example of theÂ [von Neumann architecture](https://en.wikipedia.org/wiki/Von_Neumann_architecture "Von Neumann architecture"). But unlike a computer, the model isÂ _idealized_Â with effectively infinite registers (and if used, effectively infinite special registers such asÂ [accumulators](https://en.wikipedia.org/wiki/Accumulator_\(computing\) "Accumulator (computing)")). As compared to a modern computer, however, the instruction set is still reduced in number and complexity.

Any properly defined register machine model isÂ [Turing complete](https://en.wikipedia.org/wiki/Turing_completeness "Turing completeness"). Computational speed is very dependent on the model specifics.

In practical computer science, a related concept known as aÂ [virtual machine](https://en.wikipedia.org/wiki/Virtual_machine "Virtual machine")Â is occasionally employed to reduce reliance on underlying machine architectures. TheseÂ [virtual machines](https://en.wikipedia.org/wiki/Virtual_machine "Virtual machine")Â are also utilized in educational settings. In textbooks, the term "register machine" is sometimes used interchangeably to describe a virtual machine.[[1]](https://en.wikipedia.org/wiki/Register_machine#cite_note-Abelson-Sussman_1996-1)

#### Counter Machines

#### Pointer Machines

#### Random-Access Machines (RAM)

#### Random-Access Stored-Program Machine (RASP)


### Lambda Calculus
â†— [Lambda Calculus (Î»-Calculus)](../../ğŸ“%20Formal%20System,%20Formal%20Logics,%20and%20Its%20Semantics/ğŸ©%20Higher-Order%20Languages%20&%20Logics%20(HOL)/Lambda%20Calculus%20(Î»-Calculus)/Lambda%20Calculus%20(Î»-Calculus).md)


### Markov Algorithm
> [!links]
> â†— [Markov Process & Markov Chain (MC)](../../../ğŸ§%20Mathematical%20Analysis%20(&%20Analytical%20Mathematics)/ğŸ“%20Measures%20(Measure%20Theory)/ğŸ“Š%20Probability%20Theory%20&%20Statistics/ğŸŒğŸ»â€â™‚ï¸%20Probabilistic%20Models%20(Distributions)%20&%20Stochastic%20Process/Markov%20Process%20&%20Markov%20Chain%20(MC)/Markov%20Process%20&%20Markov%20Chain%20(MC).md)

> ğŸ”— https://en.wikipedia.org/wiki/Markov_algorithm

InÂ [theoretical computer science](https://en.wikipedia.org/wiki/Theoretical_computer_science "Theoretical computer science"), aÂ **Markov algorithm**Â is aÂ [string rewriting system](https://en.wikipedia.org/wiki/String_rewriting_system "String rewriting system")Â that usesÂ [grammar](https://en.wikipedia.org/wiki/Formal_grammar "Formal grammar")-like rules to operate onÂ [strings](https://en.wikipedia.org/wiki/String_\(computer_science\) "String (computer science)")Â of symbols. Markov algorithms have been shown to beÂ [Turing-complete](https://en.wikipedia.org/wiki/Turing-complete "Turing-complete"), which means that they are suitable as a general model ofÂ [computation](https://en.wikipedia.org/wiki/Computation "Computation")Â and can represent anyÂ [mathematical expression](https://en.wikipedia.org/wiki/Mathematical_expression "Mathematical expression")Â from its simple notation. Markov algorithms are named after the Soviet mathematicianÂ [Andrey Markov, Jr.](https://en.wikipedia.org/wiki/Andrey_Markov_Jr. "Andrey Markov Jr.")

[Refal](https://en.wikipedia.org/wiki/Refal "Refal")Â is aÂ [programming language](https://en.wikipedia.org/wiki/Programming_language "Programming language")Â based on Markov algorithms.


### General Recursive Function
> [!links]
> â†— [Natural Number & Peano Axioms](../../ğŸ›’%20Set%20Theory%20&%20Axiomatic%20Set%20Theory/Number%20Sets%20&%20Field%20Construction%20(Completion)%20and%20Extension/Natural%20Number%20&%20Peano%20Axioms.md)
> â†— [Function & Mapping of Set](../../ğŸ›’%20Set%20Theory%20&%20Axiomatic%20Set%20Theory/Function%20&%20Mapping%20of%20Set/Function%20&%20Mapping%20of%20Set.md)
> â†— [Computability (Recursion) Theory - Turing Machine and R.E. Language](../Computability%20(Recursion)%20Theory%20-%20Turing%20Machine%20and%20R.E.%20Language/Computability%20(Recursion)%20Theory%20-%20Turing%20Machine%20and%20R.E.%20Language.md)

> ğŸ”— https://en.wikipedia.org/wiki/General_recursive_function

InÂ [mathematical logic](https://en.wikipedia.org/wiki/Mathematical_logic "Mathematical logic")Â andÂ [computer science](https://en.wikipedia.org/wiki/Computer_science "Computer science"), aÂ **general recursive function**,Â **partial recursive function**, orÂ **Î¼-recursive function**Â is aÂ [partial function](https://en.wikipedia.org/wiki/Partial_function "Partial function")Â fromÂ [natural numbers](https://en.wikipedia.org/wiki/Natural_number "Natural number")Â to natural numbers that is "computable" in an intuitive sense â€“ as well as in aÂ [formal one](https://en.wikipedia.org/wiki/Computable_function "Computable function"). If the function isÂ [total](https://en.wikipedia.org/wiki/Total_function "Total function"), it is also called aÂ **total recursive function**Â (sometimes shortened toÂ **recursive function**).Â InÂ [computability theory](https://en.wikipedia.org/wiki/Computability_theory_\(computation\) "Computability theory (computation)"), it is shown that the Î¼-recursive functions are precisely the functions that can be computed byÂ [Turing machines](https://en.wikipedia.org/wiki/Turing_machine "Turing machine")Â (this is one of the theorems that supports theÂ [Churchâ€“Turing thesis](https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis "Churchâ€“Turing thesis")). The Î¼-recursive functions are closely related toÂ [primitive recursive functions](https://en.wikipedia.org/wiki/Primitive_recursive_function "Primitive recursive function"), and their inductive definition (below) builds upon that of the primitive recursive functions. However, not every total recursive function is a primitive recursive functionâ€”the most famous example is theÂ [Ackermann function](https://en.wikipedia.org/wiki/Ackermann_function "Ackermann function").

Other equivalent classes of functions are the functions ofÂ [lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus "Lambda calculus")Â and the functions that can be computed byÂ [Markov algorithms](https://en.wikipedia.org/wiki/Markov_algorithm "Markov algorithm").

The subset of allÂ _total_Â recursive functions with values inÂ {0,1}Â is known inÂ [computational complexity theory](https://en.wikipedia.org/wiki/Computational_complexity_theory "Computational complexity theory")Â as theÂ [complexity class R](https://en.wikipedia.org/wiki/R_\(complexity\) "R (complexity)").



## Ref
